# LeetCode 笔记

## 我的 LeetCode 记录

### 2021年

|  日期  |                              1                               |                              2                               |                     3                      |              4              |                              5                               |                     6                     |                   7                   |                 8                 |                    9                    |                    10                     |                      11                      |                12                 |                13                |  14  |                              15                              |                   16                   |  17  |                  18                  |                          19                           |                20                 |              21               |                          22                           |                 23                 |               24                |  25  |                    26                     |  27  |  28  |                   29                    |                              30                              |                  31                  |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------: | :-------------------------: | :----------------------------------------------------------: | :---------------------------------------: | :-----------------------------------: | :-------------------------------: | :-------------------------------------: | :---------------------------------------: | :------------------------------------------: | :-------------------------------: | :------------------------------: | :--: | :----------------------------------------------------------: | :------------------------------------: | :--: | :----------------------------------: | :---------------------------------------------------: | :-------------------------------: | :---------------------------: | :---------------------------------------------------: | :--------------------------------: | :-----------------------------: | :--: | :---------------------------------------: | :--: | :--: | :-------------------------------------: | :----------------------------------------------------------: | :----------------------------------: |
|  四月  |                                                              |                                                              |                                            |                             |                                                              |                                           |                                       |                                   |                                         |                                           |                                              |                                   |                                  |      |                                                              |                                        |      |                                      |                                                       |                                   |                               |                                                       |                                    |                                 |      |      <a href="#112-路径总和">112</a>      |      |      |                                         |                                                              |                  ——                  |
|  五月  |                                                              |                                                              |                                            |                             |                                                              |                                           |                                       |                                   |    <a href="#344-反转字符串">344</a>    |                                           |                                              |                                   |                                  |      |                                                              |                                        |      |                                      |                                                       |                                   |                               |                                                       |                                    |                                 |      |                                           |      |      |                                         |                                                              |                                      |
|  九月  |                                                              |                                                              |                                            |                             |                                                              |                                           |                                       |                                   |                                         |                                           |                                              |                                   |                                  |      |                                                              |                                        |      |                                      | <a href="#105-从前序与中序遍历序列构造二叉树">105</a> |                                   |                               | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |                                    |                                 |      |                                           |      |      |                                         |                                                              |                  ——                  |
|  十月  |                                                              |                                                              |                                            |                             |                                                              |                                           |                                       |                                   |                                         |                                           |                                              |                                   |                                  |      | <a href="#146-LRU 缓存机制">146</a>、<a href="#1857-有向图中最大颜色值">1857</a> | <a href="#146-LRU 缓存机制">146(2)</a> |      | <a href="#23-合并K个升序链表">23</a> |        <a href="#3-无重复字符的最长子串">3</a>        | <a href="#35-搜索插入位置">35</a> | <a href="#15-三数之和">15</a> |          <a href="#112-路径总和">112(2)</a>           | <a href="#113-路径总和 II">113</a> | <a href="#739-每日温度">739</a> |      | <a href="#147-对链表进行插入排序">147</a> |      |      | <a href="#104-二叉树的最大深度">104</a> | <a href="#62-不同路径">62</a>、<a href="#63-不同路径 II">63</a> | <a href="#344-反转字符串">344(2)</a> |
| 十一月 | <a href="#200-岛屿数量">200</a>、<a href="#980-不同路径 III">980</a> | <a href="#237-删除链表中的节点">237</a>、<a href="#509-斐波那契数">509</a> | <a href="#1137-第 N 个泰波那契数">1137</a> | <a href="#42-接雨水">42</a> | <a href="#11-盛最多水的容器">11</a>、<a href="#70-爬楼梯">70</a> | <a href="#746-使用最小花费爬楼梯">746</a> | <a href="#695-岛屿的最大面积">695</a> | <a href="#463-岛屿的周长">463</a> | <a href="#1444-切披萨的方案数">1444</a> | <a href="#1293-网格中的最短路径">1293</a> | <a href="#1293-网格中的最短路径">1293(2)</a> | <a href="#93-复原 IP 地址">93</a> | [1254](#1254-统计封闭岛屿的数目) |      |                                                              |                                        |      |                                      |                                                       |                                   |                               |                                                       |                                    |                                 |      |                                           |      |      |                                         |                                                              |                  ——                  |
| 十二月 |                                                              |                                                              |                                            |                             |                                                              |                                           |                                       |                                   |                                         |                                           |                                              |                                   |                                  |      |                                                              |                                        |      |                                      |                                                       |                                   |                               |                                                       |                                    |                                 |      |                                           |      |      |                                         |                                                              |                                      |

### 日常做题感受与初次总结

|  完成时间  |                       题目编号                        | 感受                                                         |
| :--------: | :---------------------------------------------------: | :----------------------------------------------------------- |
| 2021.04.26 |            <a href="#112-路径总和">112</a>            |                                                              |
| 2021.05.09 |           <a href="#344-反转字符串">344</a>           |                                                              |
| 2021.09.19 | <a href="#105-从前序与中序遍历序列构造二叉树">105</a> |                                                              |
| 2021.09.22 | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |                                                              |
| 2021.10.15 |          <a href="#146-LRU 缓存机制">146</a>          |                                                              |
| 2021.10.15 |      <a href="#1857-有向图中最大颜色值">1857</a>      |                                                              |
| 2021.10.16 |        <a href="#146-LRU 缓存机制">146(2)</a>         |                                                              |
| 2021.10.18 |         <a href="#23-合并K个升序链表">23</a>          | 思路一致，具体代码实现有差别                                 |
| 2021.10.19 |        <a href="#3-无重复字符的最长子串">3</a>        | 很巧合，与答案思想差不多，实现不同                           |
| 2021.10.20 |           <a href="#35-搜索插入位置">35</a>           | 思考的不够简洁，但是挺有逻辑性，官方的或者他人的要简洁些，但是理解上需要总结一下规律 |
| 2021.10.21 |             <a href="#15-三数之和">15</a>             | 一开始完全没有头绪，只能想到暴力破解，最后去重，于是直接查看答案，并按照答案写出来 |
| 2021.10.22 |          <a href="#112-路径总和">112(2)</a>           | 哈哈，这次做的逻辑简化后和答案一模一样                       |
| 2021.10.23 |          <a href="#113-路径总和 II">113</a>           | 可以尝试做，但是没有明确思路，就按照答案做了                 |
| 2021.10.24 |            <a href="#739-每日温度">739</a>            | 用了比官方暴力解法更为暴力的方法哈哈哈                       |
| 2021.10.26 |       <a href="#147-对链表进行插入排序">147</a>       | 同样都是实现插入排序，整体思路一致，但也有些差别，代码实现自然也就不同了 |
| 2021.10.29 |        <a href="#104-二叉树的最大深度">104</a>        | 这道题很简单，之前做过比这道题更难的相似的题，所以完成不难   |
| 2021.10.30 |             <a href="#62-不同路径">62</a>             | 一开始完全没想到是动态规划，以为是递归回溯，但是知道是动态规划后就一下子知道怎么做了 |
| 2021.10.30 |           <a href="#63-不同路径 II">63</a>            | 和上一题类似，难了一些，多了些条件判断                       |
| 2021.10.31 |         <a href="#344-反转字符串">344(2)</a>          | 看答案前我想着超简单，就是简单的数组头尾数据交换，以后可以不再复习，然而这题官方答案居然使用了双指针，这种思想我没想到，看来还是得要注意下 |
| 2021.11.01 |          <a href="#980-不同路径 III">980</a>          | 还是看别人的做法完成的，官方做法还有些看不懂                 |
| 2021.11.01 |            <a href="#200-岛屿数量">200</a>            | 由于今天是先做了P980再做的此题，使用DFS，方便了许多，和官方答案的DFS思路与代码差不多，实现略微不同 |
| 2021.11.02 |        <a href="#237-删除链表中的节点">237</a>        | 差点没读懂题目，虽然做出来了，但是还是不够答案聪明，做得复杂了一点点 |
| 2020.11.02 |           <a href="#509-斐波那契数">509</a>           | 以前都没有想到过可以用动态规划做这个题，一直以为是递归就行了，但是现在才发现不仅如此，还可以有官方答案的使用矩阵或者特征方程等方式作答 |
| 2021.11.03 |      <a href="#1137-第 N 个泰波那契数">1137</a>       | 今天才静下心来看了下这个快速矩阵幂的解答方式，线性代数真是厉害 |
| 2021.11.04 |              <a href="#42-接雨水">42</a>              | 虽然花的时间比较久，但是还是完成了，并且效率还比较高         |
| 2021.11.05 |          <a href="#11-盛最多水的容器">11</a>          | 由于昨天做了第42题，类型差不多，也有双指针解法，并且比此题难，所以能做出来不意外，但是其实还是对双指针掌握得不够 |
| 2021.11.05 |              <a href="#70-爬楼梯">70</a>              | 这是一道爬楼梯题，解题方式和前面的斐波那契数几乎一样         |
| 2021.11.06 |       <a href="#746-使用最小花费爬楼梯">746</a>       | 这是一道计算爬楼梯最低花费的题，比上一题难了一些，不过由于之前我已经学过做过背包问题，这道题相比较它来说，就很简单了 |
| 2021.11.07 |         <a href="#695-岛屿的最大面积">695</a>         | 这道题和P200是DFS/BFS类型的题，代码实现上只有些微差别。今后这几天就专注于递归、回溯、DFS/BFS等之类的题了，它们之间的关系有点绕 |
| 2021.11.08 |           <a href="#463-岛屿的周长">463</a>           | 此题也是属于岛屿类型的题目，比P200和P695简单许多，并且还有几种不需要DFS的解答方式，有点类似于智力题 |
| 2021.11.08 |           <a href="#827-最大人工岛">827</a>           | 这道题是以上几道岛屿类型的题目中的最难的一道，可以“填海造陆”了。虽然花的时间比较久，但是还是做出来了，不过有一点疑惑，我采用Set保存了水域，最后“填海造陆”时就不用遍历整个二维数组了，但是它的效率在LeetCode上貌似还不如前者。另外，我貌似没看懂官方答案，还有看到有些使用并查集也能做，这个算法或者技巧我还没学过 |
| 2021.11.09 |        <a href="#1444-切披萨的方案数">1444</a>        | 本以为这是一道DFS题，感觉也是能够做出来的，我知道重复计算了一些，也优化了一下，可惜最终LeetCode上的测试用例没有通过完。中途也有想过这是不是一道动态规划的题，但是没有想到怎么用动态规划来做。搞了几个小时后，就去看别人怎么做的了，也是看了好久才理解到，真是难想啊，天，这道题连官方解答都没有，题解数加评论数才刚满100，哎，深深叹息。 |
| 2021.11.10 |       <a href="#1293-网格中的最短路径">1293</a>       | 这道题有点像岛屿问题，也想网格中的不同路径问题，还有点像是动态规划的题。于是做这道题时，就在思考是否是用DFS，因为是求一个点到另一个点的最短路径嘛，然后由于有可以移除障碍物的功能在，就想这难道是一道动态规划的题？因为可以递归的求假设只能移除一个，然后求移除两个？然后又觉得不对，因为这题从四个方向都可以走，这个方程的值可能一直在变动，得不到最优解。然后就用DFS+回溯的方式去，先假设后续DFS完成后再回溯更改就行了，最后测试了一些感觉还真是写对了，但是在LeetCode上碰到如果是一个很大的二维数组的测试用例时，会出现超时，这也难怪，因为是求最短路径，这路径数是真的多。最后，看到别人用的BFS来做，我就想着自己也去试，哎，自己对BFS不熟练，写不出来，只有照着做了。这道题也是真的难，现在只看了一个题解，居然还用到了贪心算法，之前只是在学习的时候学过，印象不深，当然也就不会。感觉这个贪心是在如果使用动态规划做不到全局最优解时，才使用贪心来做一个局部最优解？还是得不能太大胆去做困难题啊，真是做不来，不过做了看了，希望以后碰到简单题，来个降维打击哈哈。 |
| 2021.11.11 |     <a href="#1293-网格中的最短路径">1293(2)</a>      | 今天又用了一天硬是要搞这道题的DFS解法，太累人了，虽然最终通过了，但是耗时还是太多了，并且不能保证所有的以后的案例也能够通过。不过这两三天的硬着头皮做这几道难题，对DFS倒是熟悉了不少，哈哈。 |
| 2021.11.12 |           <a href="#93-复原 IP 地址">93</a>           | 这道题我是没想出来，对我来说还是蛮难的，最后还是在官方代码基础上更改的，并没本质提升。 |
| 2021.11.13 |           [1254](#1254-统计封闭岛屿的数目)            | 这道题目属于岛屿问题，与P200很类似，之前做过比此更难的，因此相对来说已经不难了，但是还是有些细节上的问题没有一开始就想到 |

## 算法理论/问题/区别/总结

###### 1.递归、回溯和深度优先搜索(DFS)的区别？动态规划？记忆化搜索（递归？）？

从第<a href="#509-斐波那契数">509</a>题貌似可以看到动态规划其实在有些时候是递归的一种优化？减少递归过程中的计算次数？

2.迭代？和深度优先搜索有关系吗？

P463

3.是不是动态规划不适合的时候，就要考虑贪心？——2021.11.10

4.回溯就是在DFS的基础上记忆曾经遍历的过程，在回退过程中会被修改？——2021.11.12

P93

## 算法分类

### 排序算法

| 排序算法 | 字符串 | 数组 |               （单向）链表                |  栈  | 队列 | 树（二叉树） |
| :------: | :----: | :--: | :---------------------------------------: | :--: | :--: | :----------: |
| 冒泡排序 |        |      |                                           |      |      |              |
| 选择排序 |        |      |                                           |      |      |              |
| 插入排序 |        |      | <a href="#147-对链表进行插入排序">147</a> |      |      |              |
| 希尔排序 |        |      |                                           |      |      |              |
| 快速排序 |        |      |                                           |      |      |              |
| 归并排序 |        |      |                                           |      |      |              |
| 基数排序 |        |      |                                           |      |      |              |
|  堆排序  |        |      |                                           |      |      |              |

### 查找算法

| 查找算法 |               数组                |
| :------: | :-------------------------------: |
| 二分查找 | <a href="#35-搜索插入位置">35</a> |
| 插值查找 |                                   |

> 线性查找、斐波那契（黄金分割法）查找

### 基础算法

> 使用单一算法就能解决的问题

|       算法       |              字符串               |                           一维数组                           |                           二维数组                           |              （单向）链表               |                              栈                              |                             队列                             | 树（二叉树） |  图  |                        其它（数学题）                        |
| :--------------: | :-------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------: | :--: | :----------------------------------------------------------: |
|     基本操作     |                                   |                 <a href="#42-接雨水">42</a>                  |                                                              | <a href="#237-删除链表中的节点">237</a> |                                                              |                                                              |              |      |                                                              |
|       迭代       |                                   |                                                              |              <a href="#463-岛屿的周长">463</a>               |                                         |                                                              |                                                              |              |      |                                                              |
|       递归       |                                   |                                                              |                                                              |                                         |                                                              |                                                              |              |      | <a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a> |
|       回溯       | <a href="#93-复原 IP 地址">93</a> |                                                              |                                                              |                                         |                                                              |                                                              |              |      |                                                              |
|     分治算法     |                                   |                                                              |                                                              |  <a href="#23-合并K个升序链表">23</a>   |                                                              |                                                              |              |      |                                                              |
|     动态规划     |                                   | <a href="#42-接雨水">42</a>、<a href="#746-使用最小花费爬楼梯">746</a> | <a href="#62-不同路径">62</a>、<a href="#980-不同路径 III">980</a>、<a href="#1444-切披萨的方案数">1444</a> |                                         |                                                              |                                                              |              |      | <a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a> |
|     贪心算法     |                                   |                                                              |                                                              |                                         |                                                              |                                                              |              |      |                                                              |
| 深度优先搜索 DFS |                                   |                                                              | <a href="#200-岛屿数量">200</a>、<a href="#463-岛屿的周长">463</a>、<a href="#695-岛屿的最大面积">695</a>、<a href="#827-最大人工岛">827</a>、[1254](#1254-统计封闭岛屿的数目) |                                         | <a href="#200-岛屿数量">200</a>、<a href="#695-岛屿的最大面积">695</a> |                                                              |              |      |                                                              |
| 广度优先搜索 BFS |                                   |                                                              |                                                              |                                         |                                                              | <a href="#200-岛屿数量">200</a>、<a href="#695-岛屿的最大面积">695</a>、[1254](#1254-统计封闭岛屿的数目) |              |      |                                                              |
|    普里姆算法    |                                   |                                                              |                                                              |                                         |                                                              |                                                              |              |      |                                                              |
|  克鲁斯卡尔算法  |                                   |                                                              |                                                              |                                         |                                                              |                                                              |              |      |                                                              |
|  迪杰斯特拉算法  |                                   |                                                              |                                                              |                                         |                                                              |                                                              |              |      |                                                              |

> 动态规划可以通过滚动数组思想减小空间复杂度，如题509，貌似42中也是（使用双指针解决时）

### 多种算法

> 同时使用到多种算法才能解决的问题，大部分这类题都属于困难题了

|       算法       | 字符串 | 一维数组 |              二维数组               | （单向）链表 |  栈  |                   队列                    | 树（二叉树） |  图  |
| :--------------: | :----: | :------: | :---------------------------------: | :----------: | :--: | :---------------------------------------: | :----------: | :--: |
|       递归       |        |          |                                     |              |      |                                           |              |      |
|       回溯       |        |          |                                     |              |      |                                           |              |      |
| 深度优先搜索 DFS |        |          |                                     |              |      |                                           |              |      |
|    BFS + 贪心    |        |          |                                     |              |      | <a href="#1293-网格中的最短路径">1293</a> |              |      |
|    DFS + 回溯    |        |          | <a href="#980-不同路径 III">980</a> |              |      |                                           |              |      |

### 其它技巧

| 其它技巧 |                 字符串                  |                           一维数组                           |                 二维数组                  |             栈              |                        其它（数学题）                        |                             解释                             |
| :------: | :-------------------------------------: | :----------------------------------------------------------: | :---------------------------------------: | :-------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 数学公式 |                                         |                                                              | <a href="#62-不同路径">62</a>（组合数学） |                             | 【矩阵快速幂、通项公式】(<a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>） | 有些题根据题意可以使用数学上的某些公式或现有定理直接计算得出答案 |
| 滑动窗口 | <a href="#3-无重复字符的最长子串">3</a> |                                                              |                                           |                             |                                                              |                                                              |
|  单调栈  |                                         |                                                              |                                           | <a href="#42-接雨水">42</a> |                                                              |                                                              |
|  双指针  |                                         | <a href="#11-盛最多水的容器">11</a>、<a href="#42-接雨水">42</a>（感觉像是对动态规划的优化） |                                           |                             |                                                              |                                                              |
|  并查集  |                                         |                                                              |     [1254](#1254-统计封闭岛屿的数目)      |                             |                                                              |                                                              |

## 题目合集（待定）

> 对做过的题目中遇到的相似问题或者难度上渐进的系列问题进行汇总

### 网格中的岛屿问题

P200、P695、P980

### 网格中的不同路径问题、最短路径问题

P62、P63、980

## Problems

### 题目记录

| 题目编号                                                     |   数据结构    |                 算法                 | 难度 | 初次完成时间 | 最近完成时间 | 完成次数 | 第一次是否独立完成 | 最近一次完成是否是独立完成 | 是否有不同于官方答案的解题思路 | 是否需要重点复习(ABCD四个等级) |                       页内跳转                        |
| :----------------------------------------------------------- | :-----------: | :----------------------------------: | :--: | :----------: | :----------: | :------: | ------------------ | :------------------------: | :----------------------------: | :----------------------------: | :---------------------------------------------------: |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) |    字符串     |               滑动窗口               | 中等 |  2021.10.19  |  2021.10.19  |    1     | 是                 |             是             |               是               |               C                |        <a href="#3-无重复字符的最长子串">3</a>        |
| [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/) |     数组      |                双指针                | 中等 |  2021.11.05  |  2021.11.05  |    1     | 是                 |             是             |               否               |               C                |          <a href="#11-盛最多水的容器">11</a>          |
| [15. 三数之和](https://leetcode-cn.com/problems/3sum/)       |      数组      | 排序+双指针 | 中等 |  2021.10.21  |  2021.10.21  |    1     | 否                 |             否             |               否               |               C               |   <a href="#15-三数之和">15</a>   |
| [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) |     链表      |                 分治                 | 困难 |  2021.10.18  |  2021.10.18  |    1     | 是                 |             是             |               否               |               A                |         <a href="#23-合并K个升序链表">23</a>          |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) |     数组      |               二分查找               | 简单 |  2021.10.20  |  2021.10.20  |    1     | 是                 |             是             |               是               |               C                |           <a href="#35-搜索插入位置">35</a>           |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) |     数组      |       动态规划、单调栈、双指针       | 困难 |  2021.11.04  |  2021.11.04  |    1     | 是                 |             是             |               是               |               A                |              <a href="#42-接雨水">42</a>              |
| [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/) |     数组      |          动态规划/组合数学           | 中等 |  2021.10.30  |  2021.10.30  |    1     | 是                 |             是             |               是               |               B                |             <a href="#62-不同路径">62</a>             |
| [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) |     数组      |               动态规划               | 中等 |  2021.10.30  |  2021.10.30  |    1     | 是                 |             是             |               是               |               B                |           <a href="#63-不同路径 II">63</a>            |
| [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) |    数学题     | 递归、动态规划、矩阵快速幂、通项公式 | 简单 |  2021.11.05  |  2021.11.05  |    1     | 是                 |             是             |               否               |               D                |              <a href="#70-爬楼梯">70</a>              |
| [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/) | 字符串 | 回溯 | 中等 | 2021.11.12 | 2021.11.12 | 1 | 否 | 否 | 否 | B | <a href="#93-复原 IP 地址">93</a> |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |    二叉树     |               DFS、BFS               | 简单 |  2021.10.29  |  2021.10.29  |    1     | 是                 |             是             |               否               |               C                |        <a href="#104-二叉树的最大深度">104</a>        |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |    二叉树     |                 递归                 | 中等 |  2021.09.19  |  2021.09.19  |    1     | 否                 |             否             |               否               |               A                | <a href="#105-从前序与中序遍历序列构造二叉树">105</a> |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) |    二叉树     |                 递归                 | 中等 |  2021.09.22  |  2021.09.22  |    1     | 否                 |             否             |               否               |               A                | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  |    二叉树     |              递归、DFS               | 简单 |  2021.04.26  |  2021.10.22  |    2     | 否                 |             是             |               否               |              A->C              |            <a href="#112-路径总和">112</a>            |
| [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) |    二叉树     |               DFS、BFS               | 中等 |  2021.10.23  |  2021.10.23  |    1     | 否                 |             否             |               否               |               B                |          <a href="#113-路径总和 II">113</a>           |
| [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/) | 哈希表+双链表 |                                      | 中等 |  2021.10.15  |  2021.10.16  |    2     | 否                 |             否             |               是               |               A                |          <a href="#146-LRU 缓存机制">146</a>          |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) |     链表      |               插入排序               | 中等 |  2021.10.26  |  2021.10.26  |    1     | 是                 |             是             |               是               |               B                |       <a href="#147-对链表进行插入排序">147</a>       |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/) |     数组      |               DFS、BFS               | 中等 |  2021.11.01  |  2021.11.01  |    1     | 是                 |             是             |               否               |               A                |            <a href="#200-岛屿数量">200</a>            |
| [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) |     链表      |             链表基础操作             | 简单 |  2021.11.02  |  2021.11.02  |    1     | 是                 |             是             |               否               |               D                |        <a href="#237-删除链表中的节点">237</a>        |
| [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/) |     数组      |                双指针                | 简单 |  2021.05.09  |  2021.10.31  |    2     | 是                 |             是             |               是               |               D                |           <a href="#344-反转字符串">344</a>           |
| [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/) | 数组 | 迭代、DFS | 简单 | 2021.11.08 | 2021.11.08 | 1 | 是 | 是 | 否 | B | <a href="#463-岛屿的周长">463</a> |
| [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/) |    数学题     | 递归、动态规划、矩阵快速幂、通项公式 | 简单 |  2021.11.02  |  2020.11.02  |    1     | 是                 |             是             |               否               |               D                |           <a href="#509-斐波那契数">509</a>           |
| [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/) | 数组 | DFS、BFS | 中等 | 2021.11.07 | 2021.11.07 | 1 | 是 | 是 | 否 | A | <a href="#695-岛屿的最大面积">695</a> |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) |     数组      |    单调栈    | 中等 |  2021.10.24  |  2021.10.24  |    1     | 是                 |             是             |               是               |               B               |            <a href="#739-每日温度">739</a>            |
| [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/) |     数组      |               动态规划               | 简单 |  2021.11.06  |  2021.11.06  |    1     | 是                 |             是             |               是               |               C                |       <a href="#746-使用最小花费爬楼梯">746</a>       |
| [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/) | 数组 | DFS | 困难 | 2021.11.08 | 2021.11.08 | 1 | 是 | 是 | 是 | A | <a href="#827-最大人工岛">827</a> |
| [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/) |     数组      |          回溯+DFS、动态规划          | 困难 |  2021.11.01  |  2021.11.01  |    1     | 否                 |             否             |               否               |               A                |          <a href="#980-不同路径 III">980</a>          |
| [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/) |    数学题     |      递归、动态规划、矩阵快速幂      | 简单 |  2021.11.03  |  2021.11.03  |    1     | 是                 |             是             |               否               |               D                |      <a href="#1137-第 N 个泰波那契数">1137</a>       |
| [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/) | 数组 | DFS、BFS、并查集 | 中等 | 2021.11.13 | 2021.11.13 | 1 | 是 | 是 | 否 | B | <a href="#1254-统计封闭岛屿的数目">1254</a> |
| [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/) | 队列 | BFS+贪心 | 困难 | 2021.11.10 | 2021.11.10 | 2 | 否 | 否 | 是 | A+ | <a href="#1293-网格中的最短路径">1293</a> |
| [1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/) | 数组 | 动态规划 | 困难 | 2021.11.09 | 2021.11.09 | 1 | 否 | 否 | 否 | A+ | <a href="#1444-切披萨的方案数">1444</a> |
| [1857. 有向图中最大颜色值](https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/) |      图       |             动态规划+BFS             | 困难 |  2021.10.15  |  2021.10.15  |    1     | 否                 |             否             |               否               |               A                |      <a href="#1857-有向图中最大颜色值">1857</a>      |

> 页内跳转：#后 字符省略，空格变为 -
>
> <a href="#"></a>

> #### 数组——暂定可删
>

> | 题目编号                                                     | 数据结构——数组 |    算法     | 难度 | 初次完成时间 | 最近完成时间 | 完成次数 | 第一次是否独立完成 | 最近一次完成是否是独立完成 | 是否有不同于官方答案的解题思路 | 是否需要重点复习(ABCD四个等级) |                             备注                             |             页内跳转              |
> | :----------------------------------------------------------- | :------------: | :---------: | :--: | :----------: | :----------: | :------: | ------------------ | :------------------------: | :----------------------------: | :---------------------------: | :----------------------------------------------------------: | :-------------------------------: |
> | [15. 三数之和](https://leetcode-cn.com/problems/3sum/)       |      数组      | 排序+双指针 | 中等 |  2021.10.21  |  2021.10.21  |    1     | 否                 |             否             |               否               |               C               | 2021.10.21_一开始完全没有头绪，只能想到暴力破解，最后去重，于是直接查看答案，并按照答案写出来 |   <a href="#15-三数之和">15</a>   |
> | [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) |      数组      |  二分查找   | 简单 |  2021.10.20  |  2021.10.20  |    1     | 是                 |             是             |               是               |               C               | 2021.10.20_思考的不够简洁，但是挺有逻辑性，官方的或者他人的要简洁些，但是理解上需要总结一下规律 | <a href="#35-搜索插入位置">35</a> |
> | [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) |     数组      |    单调栈    | 中等 |  2021.10.24  |  2021.10.24  |    1     | 是                 |             是             |               是               |               B               | 2021.10.24_用了比官方暴力解法更为暴力的方法哈哈哈 |            <a href="#739-每日温度">739</a>            |
>

### 题目汇总

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
class P3_Solution {
    /**
     * @param s 要查找的字符串
     * @return maxLen 字符串 s 中不含有重复字符的 最长子串 的长度
     */
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        } else if (s.length() == 1) {
            return 1;
        }
        StringBuilder longestSubstring = new StringBuilder();
        // 初始化 将字符串 s 中的第一个字符加入子串中
        longestSubstring.append(s.charAt(0));
        // 初始化 最大长度 为 1 或者 0 均可
        int maxLen = 1;
        // 字符串中待比较的字符下标
        int indexStr = 1;
        // 字符串中待比较的字符在子串中的下标 如果有,返回下标;如果没有,返回 -1
        int indexSub = 0;
        while (indexStr < s.length()) {
            // indexSub = longestSubstring.indexOf(s.charAt(indexStr) + ""); // 效率不及下者
            // indexSub = longestSubstring.indexOf(String.valueOf(s.charAt(indexStr))); // 效率不及下者
            indexSub = longestSubstring.toString().indexOf(s.charAt(indexStr));
            // 如果子串中没有找到该字符,将该字符加入到子串中,并且 indexStr++,比较下一个字符
            if (indexSub == -1) {
                longestSubstring.append(s.charAt(indexStr));
                indexStr++;
            } else {
                // 如果子串中找到了该字符,说明此时子串为当前的最大子串,maxLen 为前一个 maxLen 和 当前子串长度 两者中的较大值
                maxLen = Math.max(maxLen, longestSubstring.length());
                // 在子串中删除找到的字符以前的所有字符(包括这个字符)
                // 例如 s = abcdbe 中,当比较到第二个 b 时,子串为 abcd, 重复的字符为 b, 删除 ab, 即(包含) indexSub 之前的所有字符
                // 删除后为 cd
                longestSubstring.delete(0, indexSub + 1);
                // 再在末尾加上这个重复的字符 即此时子串为 cdb
                longestSubstring.append(s.charAt(indexStr));
                // 继续比较下一个
                indexStr++;
            }
        }
        return Math.max(maxLen, longestSubstring.length());
    }
}
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```java
class P15_Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int len = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        if (len < 3) {
            return ans;
        }
        Arrays.sort(nums);
        if (nums[0] > 0) {
            return ans;
        }
        int first, second, third;
        // 枚举 a
        for (first = 0; first < len; first++) {
            // 和上一次枚举的数不相同
            if(first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            third = len - 1;
            // 枚举 b c
            for (second = first + 1; second < len; second++) {
                // 和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > -nums[first]) {
                    third--;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了,可以退出循环
                if (second == third) {
                    break;
                }
                // 找到
                if (nums[second] + nums[third] == -nums[first]) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}
```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

##### 双指针

2021.11.05

> 与官方解题思路一致，实现代码上有些微区别

```java
/**
 * 双指针
 */
class P11_Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                area = Math.max(area, (right - left) * height[left]);
                left++;
            } else {
                area = Math.max(area, (right - left) * height[right]);
                right--;
            }
            // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
        }
        return area;
    }

    // 逻辑优化 —— 不计算中间过程中肯定小于等于已知最大 area 的面积
    // 但是会多了很多其它代码以及逻辑判断
    public int maxArea1(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        int temp;
        while (left < right) {
            while (height[left] < height[right]) {
                temp = left;
                area = Math.max(area, (right - left) * height[left]);
                left++;
                while (left < right && height[left] <= height[temp]) {
                    left++;
                }
                // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
            }
            while (height[left] >= height[right]) {
                temp = right;
                area = Math.max(area, (right - left) * height[right]);
                right--;
                while (left < right && height[right] <= height[temp]) {
                    right--;
                }
                // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
                if (right <= left) {
                    break;
                }
            }
        }
        return area;
    }
}
```



#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class P23_Solution {
    // 分治合并
    public ListNode mergeKLists(ListNode[] lists) {
        int k = lists.length;
        // 链表为空，直接返回
        if (k == 0) {
            return null;
        }

        while (true) {
            if (k == 1) {
                return lists[0];
            } else if (k == 2) {
                return mergeTwoLists(lists[0], lists[k - 1]);
            }
            // 有奇数个链表,先将最后一个链表合并到第一个链表中,就可以看作有偶数个链表
            if (k % 2 == 1) {
                lists[0] = mergeTwoLists(lists[0], lists[k - 1]);
            }
            k = k / 2;
            // 将偶数(2k)个链表分别两两合并(第 i 个和第 i + k 个)成为前(k)个链表, 类似于归并排序——分治
            for (int i = 0; i < k; i++) {
                lists[i] = mergeTwoLists(lists[i], lists[i + k]);
            }
        }
    }

    // 顺序合并
    public ListNode mergeKLists2(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            // 链表为空,直接返回
            return null;
        } else if (len == 1) {
            // 只有一个链表,直接返回该链表
            return lists[0];
        }

        // 将其它链表依次插入到第一个链表中，类似于插入排序,性能不如前一个
        for (int i = 1; i < len; i++) {
            lists[0] = mergeTwoLists(lists[0], lists[i]);
        }

        return lists[0];
    }

    // 我的 mergeTwoLists
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) {
            list1 = list2;
            return list1;
        } else if (list2 == null) {
            return list1;
        }

        ListNode fromList;
        ListNode toList;
        // 将两个链表中的第一个节点值较小的那个链表认为被插入链表 toList
        if (list1.val <= list2.val) {
            fromList = list2;
            toList = list1;
        } else {
            fromList = list1;
            toList = list2;
        }
        // cur 初始化为被插入链表 toList 的第一个节点
        ListNode cur = toList;
        ListNode pre = new ListNode();
        // pre 指向被插入链表 toList 的第一个节点
        pre.next = cur;
        ListNode temp;
        // 将 fromList 链表中的元素插入到 toList 链表中
        while (fromList != null && cur != null) {
            // toList 链表中的当前节点的值小于等于当前 fromList 链表中的第一个节点的值时
            // 改变 toList 链表中的 pre 和 cur 指针
            if (cur.val <= fromList.val) {
                pre = cur;
                cur = cur.next;
            } else {
                // 此时,fromList 链表中的第一个节点的值小于 cur 节点处的值,大于等于 pre 节点处的值
                // 将 fromList 链表中的第一个节点 插入到 pre 和 cur 之间
                temp = fromList.next;
                pre.next = fromList;
                fromList.next = cur;
                pre = fromList;
                fromList = temp;
            }
        }
        if (cur == null) {
            pre.next = fromList;
        }
        return toList;
    }

    // 官方的 mergeTwoLists, 实现更简洁
    public ListNode mergeTwoLists1(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null) {
            return list1 != null ? list1 : list2;
        }

        ListNode head = new ListNode();
        ListNode tail = head;
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }

        tail.next = list1 == null ? list2 : list1;
        return head.next;
    }
}
```

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```java
class P35_Solution {
    public int searchInsert1(int[] nums, int target) {
        if (nums.length == 1) {
            if (nums[0] >= target) {
                return 0;
            } else {
                return 1;
            }
        }
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        if (mid == 0) {
            if (nums[0] > target) {
                return 0;
            } else if (nums[1] > target) {
                return 1;
            }
        } else if (mid == nums.length - 1) {
            if (nums[mid] < target) {
                return mid + 1;
            } else if (nums[mid - 1] < target) {
                return mid;
            }
        } else {
            if (nums[mid - 1] > target) {
                return mid - 1;
            } else if (nums[mid] > target) {
                return mid;
            } else if (nums[mid + 1] > target) {
                return mid + 1;
            }
        }
        return 0;
    }

    public int searchInsert(int[] nums, int target) {
        if (nums.length == 1) {
            if (nums[0] >= target) {
                return 0;
            } else {
                return 1;
            }
        }
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        // left > right 的情形, 数组中无目标值
        // 表示最后一步从 right = middle - 1 分支跳出, 也即 nums[middle] > target, 重新插入位置即为 mid
        if (right < mid) {
            return mid;
        }
        // 表示 nums[mid] < target, 重新插入位置为 mid + 1, 此时的 mid + 1 也等于 left
        return mid + 1;
        // 也等价于 return right == mid - 1 ? mid : mid + 1;
        // 也等价于 return left == mid + 1 ? left : mid;
    }
}
```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

##### 我的解法

###### 2021.11.04

> 2021.11.04 解法，首次完成

```java
class P42_Solution {
    public int trap(int[] height) {
        int len = height.length;
        if (len <= 2) {
            return 0;
        }
        // 左边柱子 和 右边柱子
        int left = 0, right;
        // 遍历到 left 时, left [左边]所有柱子的高度和
        int leftSum;
        // 遍历到 right 时, right [左边]所有柱子的高度和
        // 初始时 rightSum 为第一个柱子的高度
        int rightSum = height[0];
        // 水滴, 也就是面积
        int water = 0;

        // 1.左边部分
        // 每次循环都是找到以 left 为左边, right 为右边围成的坑, 直到最高柱子结束循环
        // 此处 while(true) 也对
        while (left < len) {

            leftSum = rightSum;
            right = left + 1;
            // 从 left 柱子的下一个柱子开始遍历
            while (right < len) {
                rightSum += height[right];
                // 在 left 柱子的右侧找到第一个比 left 柱子更高或者相等高度的柱子 right
                if (height[right] >= height[left]) {
                    // 计算 left 与 right 之间能装多少水滴
                    water += (right - left - 1) * height[left] - (rightSum - leftSum - height[right]);
                    break;
                }

                // 没有找到就找下一个柱子是否比 left 柱子高
                right++;
            }
            // 退出内层 while 时, 如果 right < len, 说明在 left 到 height.length - 1 之间, 找到了 right 柱子,
            // right 柱子比 left 柱子高或者高度相等, 直接进行下次外层 while 循环
            if (right < len) {
                // 下一次外层 while 循环是从 right 处找到以 right 为左边条边的坑
                left = right;
            } else if (right == len) {
                // 退出内层 while 时, 如果 right == len, 那么此时 left 柱子的高度值 height[left] 最大,
                // 当然在 left 到 height.length - 1 之间也就找不到 right 柱子满足要求了,
                // 于是直接退出外层 while 循环, 从数组末尾开始往前找
                break;
            }
        }
//        // 测试, 输出结束时的柱子总高度
//        System.out.println("1 ---- < " + leftSum);
//        System.out.println("1 ---- > " + rightSum);

        // 2.右边部分
        // 记录最高柱子的下标
        int max = left;
        right = len - 1;
        // 重设为 0;
        // 此处
        // 遍历到 left 时, left [右边]所有柱子的高度和
        // 初始时 leftSum 为最后一个柱子的高度
        leftSum = height[len - 1];
        // 遍历到 right 时, right [右边]所有柱子的高度和
        rightSum = 0;
        while (right >= max) {

            rightSum = leftSum;
            left = right - 1;

            while (left >= max) {
                leftSum += height[left];
                if (height[left] >= height[right]) {
                    water += (right - left - 1) * height[right] - (leftSum - rightSum - height[left]);
                    break;
                }

                left--;
            }
            if (left >= max) {
                right = left;
            }
            // 右边条边为最高柱子时结束外层 while 循环, 此时 water 值即为答案
            if (right == max) {
                break;
            }
        }
//        // 测试, 输出结束时的柱子总高度
//        System.out.println("2 ---- < " + leftSum);
//        System.out.println("2 ---- > " + rightSum);
        return water;
    }
}
```

```java
/**
 * 相比较于上一个, 此处将上述的步骤进行了封装, 并且小小改变了一下计算 water 的方式,
 * 由于只需要知道 leftSum 和 rightSum 之间的差值即可,
 * 故将 water 公式中的 leftSum 与 rightSum 之差更改为 midSum
 */
class P42_Solution1 {
    // 水滴, 也就是面积
    private int water;

    public int trap(int[] height) {
        if (height.length <= 2) {
            return 0;
        }
        // 初始化水滴数为 0
        water = 0;
        // 得到最高柱子的下标, 同时也会计算最高柱子前的所有水滴数
        int max = leftWater(height);
        // 得到最终的 water 数
        rightWater(height, max);
        return water;
    }

    /**
     * 1.左边部分
     * 从左往右遍历, 计算最高柱子之前的坑中的水滴数, 返回最高柱子的下标
     *
     * @param height 数组
     * @return left 结束时 left 为最高柱子的下标
     */
    public int leftWater(int[] height) {
        // 左边柱子 和 右边柱子
        int left = 0, right;
        // left 与 right 之间(包含height[right])的所有方格数(柱子高度)总和
        int midSum;

        int len = height.length;
        // 每次循环都是找到以 left 为左边, right 为右边围成的坑, 直到最高柱子结束循环
        while (left < len) {
            // 从 left 柱子的下一个(右边)柱子开始往右遍历
            right = left + 1;
            // 新一轮循环, 置为 0
            midSum = 0;
            while (right < len) {
                midSum += height[right];
                // 在 left 柱子的右侧找到第一个比 left 柱子更高或者相等高度的柱子 right
                if (height[right] >= height[left]) {
                    // 计算 left 与 right 之间能装多少水滴
                    // water += (right - left - 1) * height[left] - (midSum - height[right]);
                    water += calWater(left, right, height[left], height[right], midSum);
                    break;
                }

                // 没有找到就找下一个柱子是否比 left 柱子高
                right++;
            }
            // 退出内层 while 时, 如果 right < len, 说明在 left 到 height.length - 1 之间, 找到了 right 柱子,
            // right 柱子比 left 柱子高或者高度相等, 直接进行下次外层 while 循环
            if (right < len) {
                // 下一次外层 while 循环是从 right 处找到以 right 为左边条边的坑
                left = right;
            } else if (right == len) {
                // 退出内层 while 时, 如果 right == len, 那么此时 left 柱子的高度值 height[left] 最大,
                // 当然在 left 到 height.length - 1 之间也就找不到 right 柱子满足要求了,
                // 于是直接退出外层 while 循环, 从数组末尾开始往前找
                break;
            }
        }
        // 最高柱子下标
        return left;
    }

    /**
     * 2.右边部分
     * 从右往左遍历, 计算从末尾到最高柱子之间的坑中的水滴数
     *
     * @param height 数组
     * @param max    最高柱子下标
     */
    public void rightWater(int[] height, int max) {
        // 左边柱子 和 右边柱子
        int left, right = height.length - 1;
        // left 与 right 之间(包含height[left])的所有方格数(柱子高度)总和
        int midSum;
        // 倒序遍历
        while (right >= max) {
            // 从 right 柱子的下一个(左边)柱子开始往左遍历
            left = right - 1;
            // 新一轮循环, 置为 0
            midSum = 0;
            while (left >= max) {
                midSum += height[left];
                if (height[left] >= height[right]) {
                    // 计算 left 与 right 之间能装多少水滴
                    // water += (right - left - 1) * height[right] - (midSum - height[left]);
                    water += calWater(left, right, height[left], height[right], midSum);
                    break;
                }

                left--;
            }
            if (left >= max) {
                right = left;
            }
            // 右边条边为最高柱子时结束外层 while 循环, 此时 water 值即为答案
            if (right == max) {
                break;
            }
        }
    }

    /**
     * 计算 left 与 right 之间的水滴数
     *
     * @param left        左边柱子的下标
     * @param right       右边柱子的下标
     * @param leftHeight  左边柱子的高度
     * @param rightHeight 右边柱子的高度
     * @param midSum      左右两边柱子之间的所有柱子的高度和(包含 leftHeight 与 rightHeight 中的较大值)
     * @return waterSum   left 与 right 之间的水滴数
     */
    public int calWater(int left, int right, int leftHeight, int rightHeight, int midSum) {
        int waterSum = 0;
        if (leftHeight > rightHeight) {
            waterSum = (right - left - 1) * rightHeight - (midSum - leftHeight);
        } else {
            waterSum = (right - left - 1) * leftHeight - (midSum - rightHeight);
        }
        return waterSum;
    }
}
```

> 2021.11.04 凌晨
>
> 我还没看官方答案，等白天再来看是否比官方答案差很多。
>
> 我的思路是：因为接水滴，肯定要有一个坑，就是有left边和right边，那么从左往右遍历，找到比left边高或者高度相等的right 边，找到了的话就可以计算这个坑的水滴了，然后下一次遍历将这个right边作为left边，去找它的right边，如果没有找到，说明现在这个left边的高度是最高的，那么就从末尾倒序开始用同样的思维找，直到这个最高边为止。
>
> 不同之处在于，从前往后遍历时，left是固定的，找的是 right边；而倒序查找时，固定的是 right 边，找的是 left边。
>
> 想想复杂度
>
> 时间复杂度：当找到最高柱子时，遍历了`j + n - j` 次，j 为最高柱子的下标，然后反向又要遍历 `n - j` 次，可能不是很精确，这公式只有常数次误差 ，那么总共就是 `2n - j`，如果最高柱子在末尾，就为 n , 在数组头， 就为 2n，时间复杂度为 `O(n)`
>
> 空间复杂度：我就只创建了几个整形int变量，所以为`O(1)`
>
> 2021.11.04 下午
>
> 在看了之前其他人的代码后，发现我这思路其它人也有写过，哈哈，巧了。
>
> 至于官方参考答案，
>
> 方法一的动态规划是在有水滴的地方，一列一列加的，总共遍历了 3n 次
>
> 方法二的单调栈是在有水滴的地方，一行一行加的，次数应该是为 2n 次，不知道具体是否准确
>
> 方法三的双指针是在方法一的动态规划上将遍历次数减少，将方法一循环中的 `ans += Math.min(leftMax[i], rightMax[i]) - height[i];` 变成了 方法三中的 `if ... else ...`， 在动态规划的同时，计算雨水 ans，而方法一，是将动态规划做完后，再从头遍历一遍得到的雨水量 ans。 还有一点区别是，方法一的动态规划是用了两个数组保存了所有位置处的左边最高柱子和右边最高柱子的下标，空间复杂度为O(n)，而方法三由于边遍历边计算，不需要保留每个位置处的左边最高柱子和右边最高柱子的下标，采用了两个整型变量`leftMax`和`rightMax `代替了这两个数组，于是降低了空间复杂度。
>
> 方法一三都是一列一列计算的，而我的思路是一个水坑一个水坑计算的。

##### 暴力解法

##### 动态规划

##### 单调栈

##### 双指针

> 双指针好难理解啊

###### 官方的第一个参考解法

```Java
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= left_max) {
                left_max = height[left];
            } else {
                ans += (left_max - height[left]);
            }
            ++left;
        } else {
            if (height[right] >= right_max) {
                right_max = height[right];
            } else {
                ans += (right_max - height[right]);
            }
            --right;
        }
    }
    return ans;
}
```

###### 官方的第二个参考解法

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}
```

###### 我修改后

> 根据 官方的第二个参考解法 修改

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = height[left], rightMax = height[right];
        while (left < right) {
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left; 
                leftMax = Math.max(leftMax, height[left]);
            } else {
                ans += rightMax - height[right];
                --right;
                rightMax = Math.max(rightMax, height[right]);
            }
        }
        return ans;
    }
}
```



#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

```java
public class P62_UniquePaths {
    public static void main(String[] args) {
        int m = 3;
        int n = 3;
        P62_Solution solution = new P62_Solution();
        System.out.println(solution.uniquePaths(m, n));
        System.out.println(solution.uniquePaths1(m, n));
        System.out.println(solution.uniquePaths2(m, n));
    }
}

class P62_Solution {
    // 简单的动态规划
    // 时间复杂度：O(mn)
    // 空间复杂度：O(mn)
    public int uniquePaths(int m, int n) {
        int[][] arr = new int[m + 1][n + 1];
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (i == m - 1 && j == n - 1) {
                    arr[m - 1][n - 1] = 1;
                } else {
                    arr[i][j] = arr[i + 1][j] + arr[i][j + 1];
                }
            }
        }
        return arr[0][0];
    }

    // 动态规划, 上一个方法的等价, 不用每次循环内判断
    // 此方法和代码实现与官方答案一极为类似, 可以等价
    // 时间复杂度：O(mn)
    // 空间复杂度：O(mn)
    public int uniquePaths1(int m, int n) {
        // 只有一行, 返回 1
        if (m == 1) {
            return 1;
        }
        int[][] arr = new int[m][n];
        // 最后一行置为 1
        for (int j = 0; j < n; j++) {
            arr[m - 1][j] = 1;
        }
        // 最后一列置为 1
        for (int i = 0; i < m; i++) {
            arr[i][n - 1] = 1;
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                arr[i][j] = arr[i + 1][j] + arr[i][j + 1];
            }
        }
        return arr[0][0];
    }

    // 优化上一个方法的空间复杂度, 只用一个一维数组来记录路径长度,
    // 并且由于交换m,n的值对答案无影响, 因此该数组长度最好为 min(m,n)
    // 时间复杂度：O(mn)
    // 空间复杂度：O(min(m,n))
    public int uniquePaths2(int m, int n) {
        // 只有一行, 返回 1
        if (m == 1) {
            return 1;
        }
        // m 为较大值(代表行), n 为较小值(代表列)
        if (m < n) {
            int temp = m;
            m = n;
            n = temp;
        }
        int[] arr = new int[n];
        arr[n - 1] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                arr[j] += +arr[j + 1];
            }
        }
        return arr[0];
    }
}
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```java
class P63_Solution {
    // 时间复杂度: O(nm), 其中 m 为网格的行数, n 为网格的列数, 只需要遍历所有网格一次即可
    // 空间复杂度: O(m)O(m), 利用滚动数组优化, 可以只用 O(n) 大小的空间来记录当前行到右下角的 path 值
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 行
        int m = obstacleGrid.length;
        // 列
        int n = obstacleGrid[0].length;
        // 右下角为障碍物, 返回 0
        if (obstacleGrid[m - 1][n - 1] == 1) {
            return 0;
        }
        // 只有一行且无障碍物, 返回 1
        if (m == 1) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[0][j] == 1) {
                    return 0;
                }
            }
            return 1;
        }
        // 只有一列且无障碍物, 返回 1
        if (n == 1) {
            for (int i = 0; i < m; i++) {
                if (obstacleGrid[i][0] == 1) {
                    return 0;
                }
            }
            return 1;
        }

        // 「滚动数组思想」把空间复杂度优化成 O(n)
        int[] dp = new int[n];
        dp[n - 1] = 1;

        for (int i = m - 1; i >= 0; i--) {
            // 等价于 dp[n - 1] = (obstacleGrid[i][n - 1] != 1) ? dp[n - 1] : 0;
            if (obstacleGrid[i][n - 1] == 1) {
                dp[n - 1] = 0;
            }
            for (int j = n - 2; j >= 0; j--) {
                // 等价于 dp[j] = (obstacleGrid[i][j] != 1) ? dp[j] + dp[j + 1] : 0;
                // 如果该格子是障碍物, 则不能从该格子走到右下角, dp[j] 为 0
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else {
                    // 如果不是障碍物, 则从该格子走到右下角的路径数为
                    // 下边一个格子走到右下角的路径数 (dp[j]) 与右边一个格子走到右下角的路径数 (dp[j + 1]) 的和
                    dp[j] += dp[j + 1];
                }
            }
        }
        return dp[0];
//        // 也可以为
//        // 「滚动数组思想」把空间复杂度优化成 O(n)
//        int[] dp = new int[n + 1];
//        dp[n - 1] = 1;
//
//        for (int i = m - 1; i >= 0; i--) {
//            for (int j = n - 1; j >= 0; j--) {
//                // 等价于 dp[j] = (obstacleGrid[i][j] != 1) ? dp[j] + dp[j + 1] : 0;
//                if (obstacleGrid[i][j] == 1) {
//                    dp[j] = 0;
//                    continue;
//                }
//                dp[j] += dp[j + 1];
//            }
//        }
//        return dp[0];
    }
}
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

##### 递归

##### 记忆化递归

##### 动态规划

2021.11.05

> 之前做过斐波那契数列，这题和它一模一样

```java
// 最初我还以为这个状态转移方程不对
class P70_Solution {
    // 动态规划
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 2;
        }
        int[] dp = new int[]{1, 2, 0};
        for (int i = 3; i <= n; i++) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
}
```

##### 矩阵快速幂

##### 通项公式

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

##### 回溯

> 在官方代码基础上更改的，并没本质提升，这题我自己挺难做的

```java
// 回溯
class P93_Solution {
    static final int SEG_COUNT = 4;
    int len;
    int[] segments = new int[SEG_COUNT];
    List<String> ans;
    // List<String> ans = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        ans = new ArrayList<>();
        if (s == null) {
            return ans;
        }
        this.len = s.length();
        if (len < 4 || len > 12) {
            return ans;
        }

        if (len == 4) {
            StringBuilder ipAddr = new StringBuilder();
            for (int i = 0; i < 4; i++) {
                ipAddr.append(s.charAt(i));
                if (i <= 2) {
                    ipAddr.append('.');
                }
            }
            ans.add(ipAddr.toString());
            return ans;
        }

        dfs(s, 0, 0);
        return ans;
    }

    public void dfs(String s, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) {
            if (segStart == len) {
                StringBuilder ipAddr = new StringBuilder();
                for (int i = 0; i < SEG_COUNT; i++) {
                    ipAddr.append(segments[i]);
                    if (i <= 2) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串, 那么提前回溯
        if (segStart == len) {
            return;
        }

        // 删除此 if 不影响结果
        if (len - segStart > (SEG_COUNT - segId) * 3) {
            return;
        } else if (len - segStart == (SEG_COUNT - segId) * 3) {
            for (int i = 0; i < SEG_COUNT - segId; i++) {
                int temp = s.charAt(segStart + i * 3) - '0';
                if (temp == 0 || temp > 2) {
                    return;
                }
                if (temp == 2) {
                    int temp1 = s.charAt(segStart + i * 3 + 1) - '0';
                    if (temp1 >= 6) {
                        return;
                    }
                    if (temp1 == 5 && (s.charAt(segStart + i * 3 + 2) - '0') >= 6) {
                        return;
                    }
                }
            }
            StringBuilder ipAddr = new StringBuilder();
            for (int i = 0; i < SEG_COUNT; i++) {
                if (i < segId) {
                    ipAddr.append(segments[i]);
                } else {
                    ipAddr.append(s.substring(segStart, segStart + 3));
                }
                if (i <= 2) {
                    ipAddr.append('.');
                }
            }
            ans.add(ipAddr.toString());
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int i = segStart; i < len; i++) {
            addr = addr * 10 + (s.charAt(i) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, i + 1);
            } else {
                break;
            }
        }
    }
}
```



#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

class P104_Solution {
    // DFS
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else if (root.left == null && root.right == null) {
            return 1;
        }
        int leftDepth = 0;
        int rightDepth = 0;
        // 左子树的深度
        if (root.left != null) {
            leftDepth = maxDepth(root.left);
        }
        // 右子树的深度
        if (root.right != null) {
            rightDepth = maxDepth(root.right);
        }
        return Math.max(leftDepth, rightDepth) + 1;
    }

    // DFS 对上方法的逻辑简化
    public int maxDepth1(TreeNode root) {
        if (root == null) {
            return 0;
        } else if (root.left == null && root.right == null) {
            return 1;
        }
        return Math.max(maxDepth1(root.left), maxDepth1(root.right)) + 1;
    }
}
```



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 必须放在这里，后续两方法中都要使用到这个属性
    // 使用k,v记录中序遍历数组中各节点值与其索引值,通过前序遍历中的第一个值就为头节点,然后在该map中找到对应中序遍历数组中的该值的下标
    private Map<Integer, Integer> indexMap = null;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;

        indexMap = new HashMap<Integer, Integer>();

        for(int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int pre_left, int pre_right, int in_left, int in_right) {
        // 一个左右子树对应的那部分数组长度大于等于1时才有节点,只有一个节点的情况是pre_left等于pre_right,那么没有节点的情况是pre_left>pre_right
        if (pre_left > pre_right) {
            return null;
        }
        // 前序遍历中第一个结点为根节点,保存其值
        int rootValPre = preorder[pre_left];
        // 中序遍历得到根节点所在位置索引值
        int rootIndexIn = indexMap.get(rootValPre);
        // 构造根节点
        TreeNode rootNode = new TreeNode(rootValPre);
        // 统计左子树中有多少个节点
        int left_size = rootIndexIn - in_left;
        // 递归遍历左子树,得到左节点
        rootNode.left = myBuildTree(preorder, inorder, pre_left + 1, pre_left + left_size, in_left, rootIndexIn - 1);
        // 递归遍历右子树,得到右节点
        rootNode.right = myBuildTree(preorder, inorder, pre_left + left_size + 1, pre_right, rootIndexIn + 1, in_right);
        return rootNode;
    }
}
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private Map<Integer, Integer> indexMap = null;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;

        indexMap = new HashMap<Integer,Integer>();

        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        return myBuildTree(inorder, postorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] inorder, int[] postorder, int in_left, int in_right, int post_left, int post_right) {

        if (post_left > post_right) {
            return null;
        }
        // 获取后序遍历中最后一位的值,即为根节点
        int rootVal = postorder[post_right];
        // 在中序遍历MAP中找到相应rootVal所在中序遍历数组中的索引位置
        int rootIndexIn = indexMap.get(rootVal);
        // 构造根节点
        TreeNode rootNode = new TreeNode(rootVal);
        // 计算左子树长度
        int left_size = rootIndexIn - in_left;
        // 递归遍历左子树,得到左节点
        rootNode.left = myBuildTree(inorder, postorder, in_left, rootIndexIn - 1, post_left, post_left + left_size - 1);
        // 递归遍历右子树,得到右节点
        rootNode.right = myBuildTree(inorder, postorder, rootIndexIn + 1, in_right, post_left + left_size, post_right - 1);
        return rootNode;
    }
}
```



#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

已定义节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
```

##### 2021.04.26

我的做法（第一种）

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return Order(root, targetSum);
    }
    
    public boolean Order(TreeNode node, int pathSum) {
        if (node == null) {
            return false;
        }
        
        pathSum = pathSum - node.val;
        boolean leftRet = false;
        boolean rightRet = false;
        
        if (node.left == null && node.right == null) {
            if(pathSum == 0) {
                return true;
            }
        }
        if (node.left != null) {
            leftRet = Order(node.left, pathSum);
        }
        if (node.right != null) {
            rightRet = Order(node.right, pathSum);
        }
        
        return leftRet || rightRet;
    }
}
```

我的方法（第二种）较第一种小改，无本质变化

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return Order(root, targetSum);
    }
    
    public boolean Order(TreeNode node, int pathSum) {
        if (node == null) {
            return false;
        }
        
        pathSum = pathSum - node.val;
        
        if (node.left == null && node.right == null) {
            if(pathSum == 0) {
                return true;
            }
        }
        
        return Order(node.left, pathSum) || Order(node.right, pathSum);
    }
}
```

##### 2021.10.22——第二次做——独立完成

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

class P112_Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }
        targetSum = targetSum - root.val;
        if (root.left != null) {
            if (hasPathSum(root.left, targetSum)) {
                return true;
            }
        }
        if (root.right != null) {
            return hasPathSum(root.right, targetSum);
        }
        return false;
    }

    // 对上一个方法的简化, 发现和官方解法一样了
    public boolean hasPathSum1(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```



官方做法（递归）

思路及算法

观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。
>
> 空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(log N)。

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

**给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。**

**叶子节点 是指没有子节点的节点。**

前言
注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。

方法一：深度优先搜索
思路及算法

我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

```Java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    Deque<Integer> path = new LinkedList<Integer>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }

    public void dfs(TreeNode root, int sum) {
        if (root == null) {
            return;
        }
        path.offerLast(root.val);
        sum -= root.val;
        if (root.left == null && root.right == null && sum == 0) {
            ret.add(new LinkedList<Integer>(path));
        }
        dfs(root.left, sum);
        dfs(root.right, sum);
        path.pollLast();
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为 O(N)，并且每一条路径的节点个数也为 O(N)，因此要将这些路径全部添加进答案中，时间复杂度为 O(N^2)。
>
> 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。

方法二：广度优先搜索
思路及算法

我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。

```java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    Map<TreeNode, TreeNode> map = new HashMap<TreeNode, TreeNode>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queueNode = new LinkedList<TreeNode>();
        Queue<Integer> queueSum = new LinkedList<Integer>();
        queueNode.offer(root);
        queueSum.offer(0);

        while (!queueNode.isEmpty()) {
            TreeNode node = queueNode.poll();
            int rec = queueSum.poll() + node.val;

            if (node.left == null && node.right == null) {
                if (rec == targetSum) {
                    getPath(node);
                }
            } else {
                if (node.left != null) {
                    map.put(node.left, node);
                    queueNode.offer(node.left);
                    queueSum.offer(rec);
                }
                if (node.right != null) {
                    map.put(node.right, node);
                    queueNode.offer(node.right);
                    queueSum.offer(rec);
                }
            }
        }

        return ret;
    }

    public void getPath(TreeNode node) {
        List<Integer> temp = new LinkedList<Integer>();
        while (node != null) {
            temp.add(node.val);
            node = map.get(node);
        }
        Collections.reverse(temp);
        ret.add(new LinkedList<Integer>(temp));
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，其中 N 是树的节点数。分析思路与方法一相同。
>
> 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数。

##### 2021.10.23

第一次做，没做出来，这是答案DFS的解法

```java
class P113_Solution {
    List<List<Integer>> ans = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return ans;
    }

    public void dfs(TreeNode root, int targetSum) {
        if (root == null) {
            return;
        }
        path.offerLast(root.val);
        targetSum = targetSum - root.val;
        if (root.left == null && root.right == null && targetSum == 0) {
            ans.add(new LinkedList<Integer>(path));
        }
        dfs(root.left, targetSum);
        dfs(root.right, targetSum);
        path.pollLast();
    }
}
```



#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

###### 方法一：**线性表**

因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。

因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        List<ListNode> list = new ArrayList<ListNode>();
        ListNode node = head;
        while (node != null) {
            list.add(node);
            node = node.next;
        }
        int i = 0, j = list.size() - 1;
        while (i < j) {
            list.get(i).next = list.get(j);
            i++;
            if (i == j) {
                break;
            }
            list.get(j).next = list.get(i);
            j--;
        }
        list.get(i).next = null;
    }
}
```

> **复杂度分析**
>
> 时间复杂度：O(N)*O*(*N*)，其中 N*N* 是链表中的节点数。
>
> 空间复杂度：O(N)*O*(*N*)，其中 N*N* 是链表中的节点数。主要为线性表的开销。

###### 方法二：寻找链表中点 + 链表逆序 + 合并链表

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1.找到原链表的中点（参考「876. 链表的中间结点」）。

​	我们可以使用快慢指针来 O(N) 地找到链表的中间节点。
2.将原链表的右半端反转（参考「206. 反转链表」）。

​	我们可以使用迭代法实现链表的反转。
3.将原链表的两端合并。

​	因为两链表长度相差不超过1，因此直接合并即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    public void mergeList(ListNode l1, ListNode l2) {
        ListNode l1_tmp;
        ListNode l2_tmp;
        while (l1 != null && l2 != null) {
            l1_tmp = l1.next;
            l2_tmp = l2.next;

            l1.next = l2;
            l1 = l1_tmp;

            l2.next = l1;
            l2 = l2_tmp;
        }
    }
}
```

> **复杂度分析**
>
> 时间复杂度：O(N)，其中 N是链表中的节点数。
>
> 空间复杂度：O(1)。

#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

第一次

```java
// 使用 哈希表 + 双向链表
// 时间复杂度：对于 put 和 get 都是 O(1)O(1)。
// 空间复杂度：O(\text{capacity})O(capacity)，因为哈希表和双向链表最多存储 \text{capacity} + 1capacity+1 个元素。
class LRUCache {

    static class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;

        public DLinkedNode() {
        }

        public DLinkedNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final Map<Integer, DLinkedNode> cache = new HashMap<>();
    private int size;
    private final int capacity;
    private final DLinkedNode head;
    private final DLinkedNode tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 新节点添加到双向链表的头部
            addToHead(newNode);
            size++;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tailNode = tail.prev;
                removeNode(tailNode);
                // 删除哈希表中对应的项
                cache.remove(tailNode.key);
                size--;
            }
        } else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
}
```





#### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class P147_Solution {
    // 从前往后找插入点
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;
        head.next = null;
        // 表示最终找到插入位置时的后一个结点
        ListNode cur;
        ListNode temp;
        // 每次插入一个结点, 都从头遍历到合适位置
        while (node != null) {
            temp = node.next;
            // 表示最终找到插入位置时的前一个结点
            ListNode prev = new ListNode();
            prev.next = head;
            cur = head;
            while (cur != null && cur.val < node.val) {
                prev = cur;
                cur = cur.next;
            }
            // 退出 while 时要么是该 node.val 为已排链表的最大值(cur == null), 添加在末尾
            // 要么 不是最大值, 添加在中间某处(prev 与 cur 之间, cur 不为 null)
            if (cur == null) {
                prev.next = node;
                node.next = null;
            } else {
                node.next = cur;
                prev.next = node;
                // 如果 node.val 的值比头结点的值小, 需要将该 node 结点设为头结点
                if (cur == head) {
                    head = node;
                }
            }
            node = temp;
        }
        return head;
    }

    // 从前往后找插入点, 对上一个方法的代码逻辑简化
    public ListNode insertionSortList1(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;
        head.next = null;
        // 表示最终找到插入位置时的后一个结点
        ListNode cur;
        ListNode temp;
        // 每次插入一个结点, 都从头遍历到合适位置
        while (node != null) {
            temp = node.next;
            // 表示最终找到插入位置时的前一个结点
            ListNode prev = new ListNode();
            prev.next = head;
            cur = head;
            while (cur != null && cur.val < node.val) {
                prev = cur;
                cur = cur.next;
            }
            // 退出 while 时要么是该 node.val 为已排链表的最大值(cur == null), 添加在末尾
            // 要么 不是最大值, 添加在中间某处(prev 与 cur 之间, cur 不为 null)
            node.next = cur;
            prev.next = node;
            // 如果 node.val 的值比头结点的值小, 需要将该 node 结点设为头结点
            if (cur == head) {
                head = node;
            }
            node = temp;
        }
        return head;
    }
}
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

##### 2021.11.01

###### 深度优先搜索 DFS

```java
// 使用 深度优先搜索
class P200_Solution {
    char[][] grid;

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        // numOfIslands 表示岛屿数量
        int numOfIslands = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                // 每进行一次深度优先搜索, 表示有一个岛屿
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    numOfIslands++;
                }
            }
        }
        return numOfIslands;
    }

    public void dfs(int i, int j) {
        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length) {
            if (grid[i][j] == '1') {
                // 每次遇到 '1' ,就将其改为 '2', 表示已经遍历了该陆地 '1'
                grid[i][j] = '2';
                // 按照"左上右下"的顺序遍历该陆地的相邻区域(方格)
                dfs(i, j - 1);
                dfs(i - 1, j);
                dfs(i, j + 1);
                dfs(i + 1, j);
            }
        }
    }
}
```

###### 广度优先搜索 BFS

```java
// 使用 广度优先搜索
class P200_Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        // numOfIslands 表示岛屿数量
        int numOfIslands = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 每进行一次广度优先搜索, 表示有一个岛屿
                if (grid[i][j] == '1') {
                    numOfIslands++;
                    // 每次遇到 '1' ,就将其改为 '2', 表示已经遍历了该陆地 '1'
                    grid[i][j] = '2';
                    // 创建一个队列用以保存该陆地及其相邻的陆地和相连的区域
                    Queue<Integer> neighbors = new LinkedList<>();
                    // 该陆地入队
                    neighbors.add(i * n + j);
                    int id, row, col;
                    // while 中出队一个已访问的陆地, 入队与其相邻的陆地, 直到队列为空
                    while (!neighbors.isEmpty()) {
                        id = neighbors.remove();
                        row = id / n;
                        col = id % n;
                        // 如果该陆地的周围(上下左右)有陆地, 将其添加进队列中, 标记为已访问 '2'
                        // 按照"左上右下"的顺序遍历该陆地的相邻区域(方格)
                        // 左
                        if (col - 1 >= 0 && grid[row][col - 1] == '1') {
                            // neighbors.add(row * n + col - 1);
                            // 与上等价
                            neighbors.add(id - 1);
                            grid[row][col - 1] = '2';
                        }
                        // 上
                        if (row - 1 >= 0 && grid[row - 1][col] == '1') {
                            // neighbors.add((row - 1) * n + col);
                            // 与上等价
                            neighbors.add(id - n);
                            grid[row - 1][col] = '2';
                        }
                        // 右
                        if (col + 1 < n && grid[row][col + 1] == '1') {
                            // neighbors.add(row * n + col + 1);
                            // 与上等价
                            neighbors.add(id + 1);
                            grid[row][col + 1] = '2';
                        }
                        // 下
                        if (row + 1 < m && grid[row + 1][col] == '1') {
                            // neighbors.add((row + 1) * n + col);
                            // 与上等价
                            neighbors.add(id + n);
                            grid[row + 1][col] = '2';
                        }
                    }
                }
            }
        }
        return numOfIslands;
    }
}
```

#### [223. 矩形面积](https://leetcode-cn.com/problems/rectangle-area/)

```java
class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        // 解决思路：用两块矩形的面积和减去两块矩形重叠部分的面积,不过为了在运算过程中防止溢出，需要先用其中一块矩形面积减去重叠面积，再加上另一块矩形面积
        
        // 重叠面积初始化为 0
        int coverArea = 0;
        // 如果两块矩形没有重合，则重叠面积 coverArea 为 0，后续 return 直接返回两矩形面积和
        if (bx1 >= ax2 || bx2 <= ax1 || by1 >= ay2 || by2 <= ay1) {
             coverArea = 0;
        } else {

            // 两块矩形重叠部分的面积 = 两矩形重叠部分长（x 轴差） * 两矩形重叠部分宽（y 轴差）
            // 两矩形重叠部分长 = x 轴上两矩形右边条边的较小值 min(ax2, bx2) - x 轴上两矩形左边条边的较大值 max(ax1, bx1)
            // 两矩形重叠部分宽 = y 轴上两矩形上边条边的较小值 min(ay2, by2) - y 轴上两矩形下边条边的较大值 max(ay1, by1)

            int x_right_min = Math.min(ax2, bx2);
            int x_left_max = Math.max(ax1, bx1);
            int y_up_min = Math.min(ay2, by2);
            int y_down_max = Math.max(ay1, by1);

            // 两块矩形重叠部分的面积
            coverArea = (x_right_min - x_left_max) * (y_up_min - y_down_max);
        }
        
        // 一块矩形面积 - 重叠面积 + 另一块矩形面积
        return (ax2 - ax1) * (ay2 - ay1) - coverArea + (bx2 - bx1) * (by2 - by1);
    }
}
```



#### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */

class P237_Solution {
    // 我做的, 将 node 结点的值置为后一个结点的值, 直到末尾, 然后再删除最后一个结点(此时值与倒数第二个结点重复了)
    public void deleteNode(ListNode node) {
        ListNode temp = node;
        while (node != null) {
            if (node.next != null) {
                node.val = node.next.val;
                temp = node;
                node = node.next;
            } else {
                temp.next = null;
                node = null;
            }
        }
    }

    // 优化, 只需要将 node 结点的值变为 node.next 的值, 然后删除 node.next 就行了
    public void deleteNode1(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```



#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

##### 2021.10.31

```java
class P344_Solution {
    public void reverseString(char[] s) {
        int len = s.length;
        char temp;
        for (int i = 0; i < len / 2; i++) {
            temp = s[i];
            s[i] = s[len - 1 - i];
            s[len - 1 - i] = temp;
        }
    }
}
```

#### [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

##### 迭代

> 依次遍历每块陆地，判断其上下左右的方格是否为水域，如果是，周长加1。

##### 深度优先搜索(递归实现)

```java
// 深度优先搜索(递归实现)
class P463_Solution {
    int[][] grid;

    public int islandPerimeter(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int Perimeter = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    Perimeter = dfs(i, j);
                    // 本题要求只有一个岛屿
                    break;
                }
            }
            if (Perimeter != 0) {
                // 本题要求只有一个岛屿
                break;
            }
        }
        return Perimeter;
    }

    public int dfs(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return 1;
        }
        // 如果该格子是水, return 1;
        if (grid[i][j] == 0) {
            return 1;
        } else if (grid[i][j] == 2) {
            // 如果该格子是已经访问过的陆地, return 0;
            return 0;
        }

        // 如果该格子是未访问过的陆地
        // 标记为已访问
        grid[i][j] = 2;
        // 返回该陆地相连的其它陆地的总周长
        return dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);
    }
}
```

##### 其它解法

> 一束光从 x 轴正负两个方向分别照到岛上时照到的边的数量是相等的，从 y 轴正负两个方向分别照到岛上时照到的边的数量也是相等的
> 所以每个坐标轴只需计算一个方向，最后把答案乘二即可
> 经评论提醒，之前没有表达清除，这束光可以想象成从斜上方照向岛屿，因为要保证某一方向上所有的边都被照到
> 每个格子如果左边是水说明照的到，否则照不到，上方同理
>
> ```c++
> //C++
> class Solution {
> public:
>     int islandPerimeter(vector<vector<int>>& grid) 
>     {
>         int m = grid.size();
>         int n = grid[0].size();
>         int ans = 0;
>         for (int i = 0; i < m; ++i)
>             for (int j = 0; j < n; ++j)
>             {
>                 if (grid[i][j] == 1)
>                 {
>                     if (i == 0)
>                         ++ans;
>                     else
>                         ans += grid[i - 1][j] == 0;
>                     if (j == 0)
>                         ++ans;
>                     else
>                         ans += grid[i][j - 1] == 0;
>                 }
>             }
>         return ans << 1;
>     }
> };
> ```

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```java
class P509_Solution {
    // 动态规划 时间复杂度O(n) 空间复杂度O(n)
    public int fib(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    // 动态规划 对上方法的代码优化
    // 滚动数组思想, 时间复杂度O(n) 空间复杂度O(1)
    public int fib1(int n) {
        if (n < 2) {
            return n;
        }
        int[] dp = new int[3];
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
    
    // 递归 消耗最大
    public int fib2(int n) {
        if (n < 2) {
            return n;
        }
        return fib2(n - 1) + fib2(n - 2);
    }
}
```

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> 求所有岛屿中的最大内接矩形面积 怎么做？

##### 深度优先搜索（递归实现）

> 应该被叫做递归实现？

```java
// 深度优先搜索
class P695_Solution {
    int[][] grid;

    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int maxArea = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    maxArea = Math.max(maxArea, dfs(i, j));
                }
            }
        }
        return maxArea;
    }

    public int dfs(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return 0;
        }
        // 如果该格子不是土地或者已经访问过, return 0;
        if (grid[i][j] != 1) {
            return 0;
        }
        // 标记为已访问
        grid[i][j] = 2;
        // 当前土地的面积为 1
        int area = 1;
        // 返回上下左右相邻的土地的面积
        area += dfs(i - 1, j);
        area += dfs(i + 1, j);
        area += dfs(i, j - 1);
        area += dfs(i, j + 1);
        return area;
    }
}
```

##### 深度优先搜索（栈实现）

> 参考官方

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索
class P695_Solution1 {
    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int maxArea = 0;
        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    Queue<Integer> queue = new LinkedList<>();
                    queue.add(i * n + j);
                    // 标记为已访问
                    grid[i][j] = 2;
                    // 当前面积为 1
                    area = 1;
                    int id, row, col;
                    while (!queue.isEmpty()) {
                        id = queue.poll();
                        row = id / n;
                        col = id % n;
                        // 上
                        if (row - 1 >= 0 && grid[row - 1][col] == 1) {
                            queue.add(id - n);
                            grid[row - 1][col] = 2;
                            area++;
                        }
                        // 下
                        if (row + 1 < m && grid[row + 1][col] == 1) {
                            queue.add(id + n);
                            grid[row + 1][col] = 2;
                            area++;
                        }
                        // 左
                        if (col - 1 >= 0 && grid[row][col - 1] == 1) {
                            queue.add(id - 1);
                            grid[row][col - 1] = 2;
                            area++;
                        }
                        // 右
                        if (col + 1 < n && grid[row][col + 1] == 1) {
                            queue.add(id + 1);
                            grid[row][col + 1] = 2;
                            area++;
                        }
                    }
                    // 当前遍历到的岛屿的最大面积
                    maxArea = Math.max(maxArea, area);
                }
            }
        }
        return maxArea;
    }
}
```



#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

##### 2021.10.24

```java
class P739_Solution {
    // (1)我的暴力解法 时间复杂度 O(n^2) 空间复杂度 O(1)
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        for (int i = 0; i < len - 1; i++) {
            for (int j = i; j < len; j++) {
                // 找到一个比 temperatures[i] 大的值, 令 temperatures[i] 为距离
                if (temperatures[i] < temperatures[j]) {
                    temperatures[i] = j - i;
                    break;
                }
                // 当比较到最后一个值都比 temperatures[i] 值小, 用 0 代替
                if (j == len - 1) {
                    temperatures[i] = 0;
                }
            }
        }
        // 最后一个值最后肯定为 0
        temperatures[len - 1] = 0;
        return temperatures;
    }

    // (2)官方答案的暴力解法 时间复杂度 O(n^m) 空间复杂度 O(1), m 是数组 next 的长度
    public int[] dailyTemperatures1(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        int[] next = new int[101];
        Arrays.fill(next, Integer.MAX_VALUE);
        // 从最后一个元素往前遍历
        for (int i = len - 1; i >= 0; i--) {
            int index = Integer.MAX_VALUE;
            // 每次遍历都要遍历完所有比该温度值更大的温度可能第一次出现的位置, 取其中的最小值为 index
            for (int j = temperatures[i] + 1; j < next.length; j++) {
                if (next[j] < index) {
                    index = next[j];
                }
            }
            // 当 index < Integer.MAX_VALUE 时, 说明有比 temperatures[i] 更大的温度值, 且此时距离 temperatures[i] 最近
            if (index < Integer.MAX_VALUE) {
                ans[i] = index - i;
            } else {
                ans[i] = 0;
            }
            // 更新 i 为此温度值为第一次出现的下标
            next[temperatures[i]] = i;
        }
        return ans;
    }

    // (3)官方答案的单调栈解法(最优解法) 时间复杂度 O(n) 空间复杂度 O(n)
    public int[] dailyTemperatures2(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        // stack 栈中保存的是当前尚未找到更大的温度值的该温度值的下标
        // stack 中栈底到栈顶的各个下标对应的温度是递减的
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            int temperature = temperatures[i];
            // 当当前温度大于了栈顶的温度, 就说明之前的小的温度找到了一个离它最近的比它大的温度
            while (!stack.isEmpty() && temperature > temperatures[stack.peek()]) {
                int prevIndex = stack.poll();
                ans[prevIndex] = i - prevIndex;
            }
            // 当前温度的下标进栈
            stack.push(i);
        }
        return ans;
    }
}
```

#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

##### 动态规划

```java
class P746_Solution {
    // 我的解法, 感觉还是我的好理解些
    public int minCostClimbingStairs(int[] cost) {
        // 初始化 dp[2] 为 0 或者 Math.min(cost[0], cost[1]) 均可,
        // 若初始化为 后者, 则 return 语句返回的是 Math.min(dp[0], dp[2]);
        int[] dp = new int[]{cost[0], cost[1], 0};
        // 达到第 i 个阶梯最低花费
        for (int i = 2; i < cost.length; i++) {
            // dp[2] 表示要达到第 i 个阶梯的最低花费(i 是下标), 它等于
            // 达到(第 i - 2 个阶梯的最低花费(dp[0]) 与 第 i - 1 个阶梯的最低花费(dp[1])中的较小值) + 达到第 i 个阶梯的花费(cost[i])
            dp[2] = Math.min(dp[0], dp[1]) + cost[i];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 最后结束时, dp[1] 与 dp[2] 为达到最后一个(n - 1)阶梯的最低花费,
        // dp[0] 为达到第 n - 2 个阶梯的最低花费
        // 故最后返回 dp[0] 与 dp[1] 的较小值
        return Math.min(dp[0], dp[1]);
    }

    // 思维方式有些变化, 等同于官方答案
    public int minCostClimbingStairs1(int[] cost) {
        // dp[] 不需要初始化
        int[] dp = new int[]{0, 0, 0};
        for (int i = 2; i <= cost.length; i++) {
            dp[2] = Math.min(dp[0] + cost[i - 2], dp[1] + cost[i - 1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
}
```

#### [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/)

##### 暴力解法

> 见官方，会超时

##### 深度优先搜索（递归实现）

###### 第一种实现

```java
// 深度优先搜索(递归实现)
class P827_Solution {
    int[][] grid;
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    // 保存 grid 中各岛屿的编号 id 及其对应面积 area
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 保存当前(i, j)坐标水域上下左右相邻的陆地的编号
    Set<Integer> hashSet = new HashSet<>();

    public int largestIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int m = grid.length;
        int n = grid[0].length;
        // 最终结果, 最大岛屿面积
        int maxArea = 0;
        // 一个岛屿的面积
        int area;
        // 所有水域的面积和, 不影响最终结果, 只为减少循环次数
        int waterArea = m * n;
        // 岛屿编号, 从 2 号开始
        int id = 2;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 得到编号为 id 的岛屿的面积
                    // dfs 过程中会将属于这个岛屿的陆地("1")全部变为岛屿的 id
                    area = dfs(i, j, id);
                    // 将 (id, area) 加入到 map 中
                    hashmap.put(id, area);
                    maxArea = Math.max(maxArea, area);
                    // System.out.println("area : " + area + ", id : " + id + ", maxArea : " + maxArea);
                    waterArea -= area;
                    id++;
                }
            }
        }
        if (maxArea == 0) {
            return 1;
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    // 将当前(i, j)坐标水域变为陆地
                    mergeIsland(i, j);
                    // 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
                    area = getMergedArea();
                    // 比较得到当前所有合并后的岛屿的最大面积
                    maxArea = Math.max(maxArea, area);
                    waterArea--;
                    if (waterArea == 0) {
                        break;
                    }
                }
            }
            if (waterArea == 0) {
                break;
            }
        }
        return maxArea;
    }

    /**
     * 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
     *
     * @return area
     */
    public int getMergedArea() {
        // 表示转变这个水域为陆地, 其面积为 1
        int area = 1;
        // 取出相邻的陆地编号, hashMap 中得到编号为 idNum 的岛屿的面积, 并累加
        for (Integer idNum : hashSet) {
            area += hashmap.get(idNum);
        }
        hashSet.clear();
        return area;
    }

    /**
     * 将当前(i, j)坐标水域上下左右相邻的陆地的编号(大于0)加入到 hashSet 中
     * 如果相邻为水域则不加入, 不做任何操作
     *
     * @param i 当前水域的横坐标
     * @param j 当前水域的纵坐标
     */
    public void mergeIsland(int i, int j) {
        int x, y;
        for (int k = 0; k < 4; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (inGrid(x, y) && grid[x][y] > 0) {
                hashSet.add(grid[x][y]);
            }
        }
    }

    /**
     * 得到得到编号为 id 的岛屿的面积, 并将相应值改为 id
     *
     * @param i  格子的横坐标
     * @param j  格子的纵坐标
     * @param id 岛屿的编号
     * @return area 该 id 岛屿的面积
     */
    public int dfs(int i, int j, int id) {
        if (inGrid(i, j) && grid[i][j] == 1) {
            grid[i][j] = id;
            int x, y;
            int area = 1;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                area += dfs(x, y, id);
            }
            return area;
        }
        return 0;
    }

    /**
     * 判断坐标 (x, y) 是否在网格中
     *
     * @param x 格子的横坐标
     * @param y 格子的纵坐标
     * @return true 在网格中; false 不在网格中, 超出边界
     */
    public boolean inGrid(int x, int y) {
        return inGridX(x) && inGridY(y);
    }

    public boolean inGridX(int x) {
        return x >= 0 && x < grid.length;
    }

    public boolean inGridY(int y) {
        return y >= 0 && y < grid[0].length;
    }
}
```

###### 第二种实现

> 本以为在第一种实现的基础上减少了循环次数，但是在LeetCode上执行的效率却没有第一种的高

```java
// 深度优先搜索(递归实现)
// 本想着优化上方式的循环次数, 但是在 LeetCode 上执行的效率却不及前者
class P827_Solution1 {
    int[][] grid;
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    // 保存 grid 中各岛屿的编号 id 及其对应面积 area
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 保存当前(i, j)坐标水域上下左右相邻的陆地的编号
    Set<Integer> hashSet = new HashSet<>();
    // 保存格子为水域的横纵坐标, 以 waterId(waterId = i * n + j) 的单个整数的方式保存为一个集合
    Set<Integer> waterSet = new HashSet<>();

    public int largestIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int m = grid.length;
        int n = grid[0].length;
        // 最终结果, 最大岛屿面积
        int maxArea = 0;
        // 一个岛屿的面积
        int area;
        // 岛屿编号, 从 2 号开始
        int id = 2;
        // 1.遍历 grid[][], 得到所有岛屿及其面积并编号
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 得到编号为 id 的岛屿的面积
                    // dfs 过程中会将属于这个岛屿的陆地("1")全部变为岛屿的 id
                    area = dfs(i, j, id);
                    // 将 (id, area) 加入到 map 中
                    hashmap.put(id, area);
                    // maxArea = Math.max(maxArea, area);
                    // System.out.println("area : " + area + ", id : " + id + ", maxArea : " + maxArea);
                    id++;
                } else if (grid[i][j] == 0) {
                    // 将水域加入 waterSet
                    waterSet.add(i * n + j);
                }
            }
        }

        // 可提前结束执行的一些特殊情况, 可删除, 删除后不影响最终结果
        // 全为陆地, 或者只有一块水域, return m * n
        int size = waterSet.size();
        if (size == 0 || size == 1) {
            return m * n;
        } else if (size == m * n) {
            // 全为水域, return 1
            return 1;
        }
        // 存在水域, 但只有一个岛屿, 返回 2 号岛屿的面积 + 1
        if (hashmap.size() == 1) {
            return hashmap.get(2) + 1;
        }

        // 2.遍历每个水域, 得到各个水域变为陆地后, 将多个岛屿连接后形成的整块大岛屿的面积
        for (Integer waterId : waterSet) {
            // 如果当前(i, j)坐标水域变为陆地
            mergeIsland(waterId / n, waterId % n);
            // 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
            area = getMergedArea();
            // 比较得到当前所有合并后的岛屿的最大面积
            maxArea = Math.max(maxArea, area);
        }
        return maxArea;
    }

    /**
     * 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
     *
     * @return area
     */
    public int getMergedArea() {
        // 表示转变这个水域为陆地, 其面积为 1
        int area = 1;
        // 取出相邻的陆地编号, hashMap 中得到编号为 idNum 的岛屿的面积, 并累加
        for (Integer idNum : hashSet) {
            area += hashmap.get(idNum);
        }
        hashSet.clear();
        return area;
    }

    /**
     * 将当前(i, j)坐标水域上下左右相邻的陆地的编号(大于0)加入到 hashSet 中
     * 如果相邻为水域则不加入, 不做任何操作
     *
     * @param i 当前水域的横坐标
     * @param j 当前水域的纵坐标
     */
    public void mergeIsland(int i, int j) {
        int x, y;
        for (int k = 0; k < 4; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (inGrid(x, y) && grid[x][y] > 0) {
                hashSet.add(grid[x][y]);
            }
        }
    }

    /**
     * 得到得到编号为 id 的岛屿的面积, 并将相应值改为 id
     *
     * @param i  格子的横坐标
     * @param j  格子的纵坐标
     * @param id 岛屿的编号
     * @return area 该 id 岛屿的面积
     */
    public int dfs(int i, int j, int id) {
        if (inGrid(i, j) && grid[i][j] == 1) {
            grid[i][j] = id;
            int x, y;
            int area = 1;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                area += dfs(x, y, id);
            }
            return area;
        }
        return 0;
    }

    /**
     * 判断坐标 (x, y) 是否在网格中
     *
     * @param x 格子的横坐标
     * @param y 格子的纵坐标
     * @return true 在网格中; false 不在网格中, 超出边界
     */
    public boolean inGrid(int x, int y) {
        return inGridX(x) && inGridY(y);
    }

    public boolean inGridX(int x) {
        return x >= 0 && x < grid.length;
    }

    public boolean inGridY(int y) {
        return y >= 0 && y < grid[0].length;
    }
}
```

##### 并查集

> 见评论区



#### [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

```java
class P980_Solution {
    private int[][] grid;

    public int uniquePathsIII(int[][] grid) {
        this.grid = grid;
        // 开始位置
        int startX = 0, startY = 0;
        // stepNum 表示 grid 中 0 的个数 + 找到 2 时这最后一步, 每经过一个 0 自减, 找到 2 时, stepNum 为 0
        int stepNum = 1;
        // 遍历 grid 得到起始位置 和 总步数
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 0) {
                    stepNum++;
                } else if (grid[i][j] == 1) {
                    startX = i;
                    startY = j;
                }
            }
        }
        return dfs(startX, startY, stepNum);
    }

    public int dfs(int x, int y, int step) {
        // 遍历到边界, 返回 0
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {
            return 0;
        }
        // grid[x][y] 是障碍(为 -1 时)或者已经访问过(为 3 时), 返回 0
        if (grid[x][y] == -1 || grid[x][y] == 3) {
            return 0;
        }
        // 找到结束方格, 但是如果此时(此路径)并没有访问完所有的 0 方格, 则还是认为没有找到满足题意的一条路径
        if (grid[x][y] == 2) {
            return step == 0 ? 1 : 0;
        }
        // 能执行到这里表示 grid[x][y] == 0, 将其置为 3, 表示正在访问或者已经访问过该方格, 在回溯时再将其置为 0
        grid[x][y] = 3;
        // path 表示之前已经访问过若干个 0 方格, 现从此方格开始能访问完所有剩余 0 方格, 并且最终能访问到结束方格的路径数
        // 任何一个从当前方格能够访问到结束方格的路径数等于该方格"上下左右"这四个方格访问到结束方格的路径数的总和
        int path = 0;
        // 按照左上右下的顺序遍历
        path += dfs(x, y - 1, step - 1);
        path += dfs(x - 1, y, step - 1);
        path += dfs(x, y + 1, step - 1);
        path += dfs(x + 1, y, step - 1);
        // 回溯时将其置为 0
        grid[x][y] = 0;
        return path;
    }
}
```

#### [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

##### 动态规划、递归

> 2021.11.03

```java
class P1137_Solution {
    // 动态规划
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        int[] dp = new int[]{0, 1, 1, 0};
        for (int i = 3; i < n + 1; i++) {
            dp[3] = dp[2] + dp[1] + dp[0];
            dp[0] = dp[1];
            dp[1] = dp[2];
            dp[2] = dp[3];
        }
        return dp[3];
    }

    // 递归
    public int tribonacci1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        return tribonacci1(n - 1) + tribonacci1(n - 2) + tribonacci1(n - 3);
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(1)

##### 矩阵快速幂

> 2021.11.03

```java
class P1137_Solution1 {
    // 快速矩阵幂
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n <= 2) {
            return 1;
        }
        int[][] q = {{1, 1, 1}, {1, 0, 0}, {0, 1, 0}};
        int[][] res = pow(q, n);
        // 此处为何返回 res[0][2], 而不是 res[2][0] + res[2][1] ?
        return res[0][2];
    }

    // n 个矩阵 a 相乘
    public int[][] pow(int[][] a, int n) {
        int[][] ret = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    // 矩阵 a 与矩阵 b 相乘
    public int[][] multiply(int[][] a, int[][] b) {
        int[][] c = new int[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
            }
        }
        return c;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(log n)
> - 空间复杂度：O(1)

> **为何返回的是 `return res[0][2]` ？**
>
> 按照方法二的公式
>
> ```reasonml
> 列矩阵【T(n+2),T(n+1),T(n)】 = n 个 M 矩阵相乘，再与列矩阵 【T(2),T(1),T(0)】(1,1,0) 相乘
> ```
>
> 最后得到的是三行一列的矩阵，T(n) 应该等于   `res[2][0]*T(2) + res[2][1]*T(1) +  res[2][2]*T(0) ` 
>
> 带入 T(2), T(1), T(0) 的值 (1,1,0)，最后  `T(n) = res[2][0] + res[2][1]`
>
> 而方法二答案最终返回的是 `res[0][2]`，是因为方法二的代码实现与文字解答不一致，`return res[0][2]` 是将公式看成了
>
> ```reasonml
> 列矩阵【T(n),T(n-1),T(n-2)】 = n 个 M 矩阵相乘，再与列矩阵 【T(0),T(-1),T(-2)】(0,0,1) 相乘
> ```
>
> 于是乎，T(n) 等于   `res[0][0]*T(0) + res[0][1]*T(-1) +  res[0][2]*T(-2) ` 
>
> 带入 T(0), T(-1), T(-2) 的值 (0,0,1)，最后   `T(n) = res[0][2]`
>
> 至于 T(-1), T(-2) 为何为 0 和 1，是因为
>
> `T(-1) = T(2) - T(1) - T(0) = 1 - 1 - 0 = 0` 
>
> `T(-2) = T(1) - T(0) - T(-1) = 1 - 0 - 0 = 1` 

#### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

##### 深度优先搜索（递归实现）

```java
// 深度优先遍历(递归实现)
class P1254_Solution {
    int m, n;

    public int closedIsland(int[][] grid) {
        if (grid == null) {
            return 0;
        }
        this.m = grid.length;
        this.n = grid[0].length;
        if (m == 2 || n == 2) {
            return 0;
        }
        
        int numOfClosedIsland = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    if (dfs(grid, i, j)) {
                        numOfClosedIsland++;
                    }
                }
            }
        }
        return numOfClosedIsland;
    }

    public boolean dfs(int[][] grid, int i, int j) {
        // 超出边界, 说明该岛屿不是封闭的, 返回 false
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return false;
        }
        // 该方格可能是水域(为 1 的情况), 或者是曾经访问过的陆地(为 2 的情况), 返回 true
        if (grid[i][j] != 0) {
            return true;
        }
        grid[i][j] = 2;
        // 上左下右遍历
        // 注意 bl 放在 && 后, 即要先 dfs 得到结果后再与 bl 进行 ‘与’ 操作
        // 当然更不能直接将这四个 dfs && 连接起来
        boolean bl = dfs(grid, i - 1, j);
        bl = dfs(grid, i, j - 1) && bl;
        bl = dfs(grid, i + 1, j) && bl;
        bl = dfs(grid, i, j + 1) && bl;
        return bl;
    }
}
```

##### 广度优先搜索（队列实现）

> 待后续补充

##### 并查集

#### [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

##### 广度优先搜索（队列实现） + 贪心算法

> [参考链接](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution/wang-ge-zhong-de-zui-duan-lu-jing-bfssuan-fa-shi-x/)
>
> 他人评论——
>
> 传统BFS：如果点A已经在visited里，那我们就不会第二次加入点A
>
> 本题：如果点A已经在visited里，但是这次我们到点A的路径上碰到的障碍物比上次少，那我们要把点A加入queue

```java
// 广度优先搜索(队列实现) + 贪心算法
class P1293_Solution {
    public int shortestPath(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        // 只有一个方格, 由于 k 是大于等于 1 的, 不管该方格是不是障碍物, 都能通过
        if (m == 1 && n == 1) {
            return 0;
        }
        // 最后一个(右下角)为障碍物, 先将其消除, k 要减 1
        if (grid[m - 1][n - 1] == 1) {
            grid[m - 1][n - 1] = 0;
            k--;
        }
        // 三维标记数组
        // visited[i][j][0] 该方格历史最优剩余能消除障碍物的次数 剩余次数越多, 越有价值(此处贪心, 记录局部最优)
        // visited[i][j][1] 该方格当前此次剩余能消除障碍物的次数
        int[][][] visited = new int[m][n][2];
        // visited[i][j][0] 初始状态为 -1, 不需要初始化 visited[i][j][1]
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited[i][j][0] = -1;
            }
        }

        // 初始化起始点(0, 0)处的 visited[0][0][0] 和 visited[0][0][1] 值为 k , 表示起始点处的
        // (历史最大消除次数 visited[0][0][0]) 和 (从当前该方格出发能够消除的次数 visited[0][0][1])
        visited[0][0][0] = k;
        visited[0][0][1] = k;
        // 构造队列
        Queue<Integer> queue = new LinkedList<>();
        // 初始化队列, 将起始点(0, 0)入队, 0 = 行号 * n + 列号
        queue.add(0);
        // 初始化最短路径步数为 0
        int minSteps = 0;
        // 四个方向
        final int[] dx = new int[]{-1, 1, 0, 0};
        final int[] dy = new int[]{0, 0, -1, 1};
        // BFS 的队列实现 + 贪心
        while (!queue.isEmpty()) {
            // 等于遍历的层数, 每进入一次 while, 表示走了一步
            minSteps++;
            // 提前获取该层需要出队多少个的个数
            // 遍历相同层级下所有节点
            int size = queue.size();
            // 当前方格的 id、横坐标、纵坐标、从该方格出发能够消除障碍的次数
            int id, curX, curY, obsNum;
            for (int i = 0; i < size; i++) {
                // 出队
                id = queue.remove();
                curX = id / n;
                curY = id % n;
                // 从该方格出发能够消除障碍的次数
                obsNum = visited[curX][curY][1];
                // 当前 id 方格相邻的四个方格的 横纵坐标
                int x, y;
                for (int j = 0; j < 4; j++) {
                    x = curX + dx[j];
                    y = curY + dy[j];
                    // 在 grid 内, 不要越界
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        // id 方格的下一步就是终点(右下角), 返回 minSteps, 此为最短路径(步数)
                        if (x == m - 1 && y == n - 1) {
                            return minSteps;
                        }
                        // 如果当该方格为障碍物, 并且到达 id 方格时还能穿越障碍物的次数已经为 0, 则不能再穿越此方格(障碍物)了
                        if (grid[x][y] == 1 && obsNum == 0) {
                            continue;
                        }
                        // 如果该方格是障碍物, 则将其变成可以通过的方格, 并更新其还能消除障碍物的次数
                        // visited[x][y][1] = grid[x][y] == 1 ? obsNum - 1 : obsNum; // 貌似不需要 newObsNum 也可以
                        int newObsNum = grid[x][y] == 1 ? obsNum - 1 : obsNum;
                        // 以下三段代码取其一, 都是正确的, 逻辑不同而已
/*                        // 1. 是第 2 段代码的简化
                        // 如果该方格已被访问过(可能该方格是障碍物, 但是可能曾经通过将其转变为可以通过的方格被访问过)
                        // 并且当前 visited 记录的历史访问该方格时剩余消除障碍物最大次数 > 当前搜索节点层级的剩余消除次数
                        // 如果将其加入队列, 也很有可能得不到更优解了
                        // 因此不更新该方格的 visited 历史值, 此方格也不加入队列, 直接进行下次循环
                        // 反之, 则更新 visited[x][y][0] 和 visited[x][y][1] 为 newObsNum, 并将该方格加入队列
                        // hi, 真是奇怪, 如果将 ">=" 改为 ">", 会出现问题
                        if (visited[x][y][0] != -1 && visited[x][y][0] >= newObsNum) {
                            continue;
                        } else {
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                        }
                        // 此处, 该方格可能曾经从未被访问过, 也可能被访问过
                        // 但是不管何种情况, visited[x][y][0] 和 visited[x][y][0] 均已在上一个 if 判断中更新
                        // 现在只需入队即可
                        //queue.add(x * n + y);*/

/*                        // 2. 比第 1 段好理解的, 但是也比第 1 段多了些重复代码
                        // 上一个 if - else 也可理解为 :
                        // 如果被访问过, 贪心一下, 看通过该方格是否有可能得到更优解, 判断方式是
                        if (visited[x][y][0] != -1) {
                            // 如果此次剩余消除次数没有以前保存的历史消除次数值大, 则认为以更小的消除次数从这个方格出发到达终点
                            // 得到的结果(最短路径步数)
                            // 也不会比以 [已经保存在 visited[x][y][0] 中的这个历史的更大消除次数值的] 这种状态的这个方格出发
                            // 到达终点得到的结果更优
                            // 于是, 不更新, 不入队, 直接下次循环
                            // 这个是大于等于还是等于差别这么大吗?
                            if (visited[x][y][0] >= newObsNum) {
                                continue;
                            } else {
                                // 反之, 如果此次的还能消除障碍的次数更大, 则可能通过该方格去尝试, 能够得到更优解
                                // 于是, 更新 visited 数组值, 并入队
                                visited[x][y][1] = newObsNum;
                                visited[x][y][0] = newObsNum;
                            }
                        } else {
                            // 如果没被访问过, 直接给 visited 数组赋值, 然后入队
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                        }
                        // 此处, 该方格可能曾经从未被访问过, 也可能被访问过
                        // 但是不管何种情况, visited[x][y][0] 和 visited[x][y][0] 均已在上一个 if 判断中更新
                        // 现在只需入队即可
                        //queue.add(x * n + y);*/

                        // 3. 这种也是对的
                        // 由于除了起始方格处的 visited[x][y][0] 值为 k, 其余各方格处的该值初始值都为 -1,
                        // 而 newObsNum 肯定是大于等于 0 的, 肯定比初始值 -1 大,
                        // 又由于需要贪心保证 visited[x][y][0] 能够成为更大值时, 才有可能得到更优解, 才更新其值以及入队
                        // 所以当遇到比 历史保存值(消除障碍数)更大的值时, 就更新该方格的 visited 值, 以及入队
                        // 如果没有, 就什么都不做
                        if (visited[x][y][0] < newObsNum) {
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                            queue.add(x * n + y);
                        }
                    }
                }
            }
        }
        // 未找到路径, 返回 -1
        return -1;
    }
}
```

##### 深度优先搜索 + 记忆化

> 原因在于第二列,在回溯后， 从(6,1)本该拆除(7,1)的障碍物, 但是实际执行时
> 由于 memo[9][1]\memo[8][1]\memo[7][1] 这三个位置在回溯(9,0)(8,0)(7,0)方格时记录值由3变为了4，
> 而当真正回溯到(6,1)时，它不会往下走(7,1)了，虽然此时的 k == 4
>
> 于是有了 if (k >= memo[i][j] || (j == n - 1 && d == 2 && memo[i - dx[d]][j - dy[d]] == memo[i][j])) {}
>
> 此行判断条件的多种情况
>

#### [1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/)

##### 动态规划

```java
// 动态规划
class P1444_Solution {
    public int ways(String[] pizza, int k) {
        final int mod = (int) Math.pow(10, 9) + 7;
        int rows = pizza.length;
        int cols = pizza[0].length();
        int[][][] dp = new int[rows][cols][k + 1];
        int[][] apple = new int[rows + 1][cols + 1];
        // 遍历矩阵, 获取指定右下角矩阵中的苹果数量
/*        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                apple[i][j] = (pizza[i].charAt(j) == 'A' ? 1 : 0)
                        + apple[i + 1][j] + apple[i][j + 1] - apple[i + 1][j + 1];
            }
        }*/
        // 遍历每个小矩阵, 可得到将每个小矩阵切成 1 到 k 块的方案数
        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                // 该矩阵中的苹果数量
                apple[i][j] = (pizza[i].charAt(j) == 'A' ? 1 : 0)
                        + apple[i + 1][j] + apple[i][j + 1] - apple[i + 1][j + 1];
                // 该矩阵中有苹果, 如果没有苹果, 怎么切都没用, 直接下次循环
                if (apple[i][j] > 0) {
                    // 如果只切成一块, 方案数为 1;
                    dp[i][j][1] = 1;
                    // 如果切成 2...k 块, 枚举每种情况横着切和竖着切的方案和 dp[i][j][block]
                    // 本应是 block <= k, 但是如果本身此矩阵内的苹果数就小于要切成的块数 block,
                    // 这种要切成的块数情况不能满足每个块内都有苹果, 于是将结束条件设为
                    // [block <= Math.min(k, apple[i][j])], 可提前结束循环
                    for (int block = 2; block <= k; block++) {
                        // 横着切
                        // horCutNum 横着切的次数
                        for (int horCutNum = (rows - 1) - i; horCutNum >= 1; horCutNum--) {
                            // 如果当前横着切一刀后, 切掉的 [上边] 矩阵内有苹果, dp[i][j][block] 的值
                            // 应加上被切掉后剩下的 [下边] 矩阵切成 block - 1 块的方案数值
                            // 如果没有苹果, 说明此条 [水平线] 不能切, 接着循环判断下一条
                            if (apple[i][j] - apple[i + horCutNum][j] > 0) {
                                dp[i][j][block] = (dp[i][j][block] + dp[i + horCutNum][j][block - 1]) % mod;
                            }
                        }
                        // 竖着切
                        // verWaysNum 竖着切的次数
                        for (int verWaysNum = (cols - 1) - j; verWaysNum >= 1; verWaysNum--) {
                            // 如果当前竖着切一刀后, 切掉的 [左边] 矩阵内有苹果, dp[i][j][block] 的值
                            // 应加上被切掉后剩下的 [右边] 矩阵切成 block - 1 块的方案数值
                            // 如果没有苹果, 说明此条 [垂直线] 不能切, 接着循环判断下一条
                            if (apple[i][j] - apple[i][j + verWaysNum] > 0) {
                                dp[i][j][block] = (dp[i][j][block] + dp[i][j + verWaysNum][block - 1]) % mod;
                            }
                        }
                    }
                }
            }
        }
        // 返回将整个大矩阵切成 k 块的方案数
        return dp[0][0][k];
    }
}
```

> 给我做了一天，最后还是看别人的做的



#### [1857. 有向图中最大颜色值](https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/)

```java
public class P1857_LargestPathValue {
    public static void main(String[] args) {
        // 测试案例 1
        String colors = "abaca";
        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}};
//        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}, {1, 2}, {3, 1}}; // 存在环
//        // 测试案例 2
//        String colors = "a";
//        int[][] edges = {{0, 0}};
//        // 测试案例 3
//        String colors = "g";
//        int[][] edges = {};

        Solution solution = new Solution();
        int largestPathValue = solution.largestPathValue(colors, edges);

        System.out.println(largestPathValue);
    }
}

class Solution {
    public int largestPathValue(String colors, int[][] edges) {

        // 节点个数
        int nodeNum = colors.length();
        // 每个节点的入度
        int[] inDegree = new int[nodeNum];
        // 保存到达每个节点时, 该条路径上的各种颜色出现的次数
        int[][] pathValue = new int[nodeNum][26];
        // 创建邻接表
        Node[] adjList = new Node[nodeNum];

        // 把从 from 节点到所有 to 节点的所有边的关系都保存为
        // 从 from 节点指向的所有的 to 节点形成的一个链表
        // 例如：从字符 ’a‘ 这个节点到 字符 ’b‘’c‘’d‘ 这三个节点的五条边关系保存为
        // {aNode} --> [bNode] --> cNode --> dNode
        // 如果 ’b‘ 到 ’e‘’f‘ ，则
        // {bNode} --> [eNode] --> fNode
        // 其中,[]括号里的[bNode][eNode]两节点才保存在邻接表adjList[from]中
        // from 为相对应的’a‘’b‘在原字符串中的下标
        for (int[] edge : edges) {
            int from = edge[0], to = edge[1];
            // to 节点的入度更新,一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法，与注释的三行等价
            adjList[from] = new Node(to, adjList[from]);
            /*
            Node toNode = new Node(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // 保存入度为 0 的各个节点，有可能是非连通图
        LinkedList<Integer> queue = new LinkedList<>();
        for (int i = 0; i < inDegree.length; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }
        // 如果 queue 中一个都没有, 表示存在环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return -1;
        }

        // 如果无环,当循环结束时, bfsCount 应该等于节点数 nodeNum
        int bfsCount = 0;
        Node next;
        while (!queue.isEmpty()) {
            // 初始时前 initQueueSize = queue.size() 个 cur 代表入度为 0 的从该点开始遍历的出发节点的下标
            // 可以看作有 initQueueSize 个子图
            int cur = queue.remove();
            // adjList[cur] 处存储的是 cur 的下一个节点
            next = adjList[cur];

            // bfsCount 入度为 0 的点的个数
            bfsCount++;
            // 将当前路径上的该点处的相应颜色的值加 1
            pathValue[cur][colors.charAt(cur) - 97]++;
            // 遍历当前节点能够到达的其它所有节点
            while (next != null) {
                // 入度减 1, 减小到 0 时, 将其入队
                inDegree[next.value]--;
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }

                // 更新 next 所有颜色次数
                // 由于当前的这个节点在曾经可能已经在其它路径中被访问过,所以此次访问需要比较上次
                // pathValue[0].length == 26 小写字母个数
                for (int i = 0; i < pathValue[0].length; i++) {
                    pathValue[next.value][i] = Math.max(pathValue[next.value][i], pathValue[cur][i]);
                }
                // next 指向 cur 这个入度为 0 的节点的下一个与它相连的能组成边的点
                next = next.next;
            }
        }

        // 如果无环,当循环结束时, bfsCount 应该等于节点数 nodeNum
        if (bfsCount != nodeNum) {
            return -1;
        }

        // 从 pathValue 二维数组中获取最大值 largestPathValue
        int res = 0;
        for (int[] ints : pathValue) {
            res = Math.max(res, Arrays.stream(ints).max().getAsInt());
        }
//        for (int[] ints : pathValue) {
//            for (int j = 0; j < pathValue[0].length; j++) {
//                res = Math.max(res, ints[j]);
//            }
//        }
        return res;
    }
}

class Node {

    // value 表示第几个字符
    public int value;
    Node next;

    public Node(int value) {
        this.value = value;
    }

    public Node(int value, Node next) {
        this.value = value;
        this.next = next;
    }
}
```

## 剑指 Offer II

### 待定



