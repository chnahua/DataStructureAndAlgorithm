# LeetCode 笔记

## 我的 LeetCode 记录

### 2021年

|  日期  |                              1                               |                              2                               |                      3                      |                4                |                              5                               |                     6                     |                     7                     |                      8                       |                    9                    |                      10                       |                              11                              |                      12                      |                              13                              |                              14                              |                              15                              |                     16                      |                       17                       |                              18                              |                              19                              |                          20                          |                              21                              |                          22                           |                              23                              |                24                |               25                |                    26                     |               27               |                 28                  |                   29                    |                              30                              |                  31                  |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :-----------------------------: | :----------------------------------------------------------: | :---------------------------------------: | :---------------------------------------: | :------------------------------------------: | :-------------------------------------: | :-------------------------------------------: | :----------------------------------------------------------: | :------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :--------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------------------------------------------------: | :----------------------------------------------------------: | :---------------------------------------------------: | :----------------------------------------------------------: | :------------------------------: | :-----------------------------: | :---------------------------------------: | :----------------------------: | :---------------------------------: | :-------------------------------------: | :----------------------------------------------------------: | :----------------------------------: |
|  四月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |                                         |                                               |                                                              |                                              |                                                              |                                                              |                                                              |                                             |                                                |                                                              |                                                              |                                                      |                                                              |                                                       |                                                              |                                  |                                 |      <a href="#112-路径总和">112</a>      |                                |                                     |                                         |                                                              |                  ——                  |
|  五月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |    <a href="#344-反转字符串">344</a>    |                                               |                                                              |                                              |                                                              |                                                              |                                                              |                                             |                                                |                                                              |                                                              |                                                      |                                                              |                                                       |                                                              |                                  |                                 |                                           |                                |                                     |                                         |                                                              |                                      |
|  九月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |                                         |                                               |                                                              |                                              |                                                              |                                                              |                                                              |                                             |                                                |                                                              |    <a href="#105-从前序与中序遍历序列构造二叉树">105</a>     |                                                      |                                                              | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |                                                              |                                  |                                 |                                           |                                |                                     |                                         |                                                              |                  ——                  |
|  十月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |                                         |                                               |                                                              |                                              |                                                              |                                                              | <a href="#146-LRU 缓存机制">146</a>、<a href="#1857-有向图中最大颜色值">1857</a> |   <a href="#146-LRU 缓存机制">146(2)</a>    |                                                |             <a href="#23-合并K个升序链表">23</a>             |           <a href="#3-无重复字符的最长子串">3</a>            |          <a href="#35-搜索插入位置">35</a>           |                <a href="#15-三数之和">15</a>                 |          <a href="#112-路径总和">112(2)</a>           |              <a href="#113-路径总和 II">113</a>              | <a href="#739-每日温度">739</a>  |                                 | <a href="#147-对链表进行插入排序">147</a> |                                |                                     | <a href="#104-二叉树的最大深度">104</a> | <a href="#62-不同路径">62</a>、<a href="#63-不同路径 II">63</a> | <a href="#344-反转字符串">344(2)</a> |
| 十一月 | <a href="#200-岛屿数量">200</a>、<a href="#980-不同路径 III">980</a> | <a href="#237-删除链表中的节点">237</a>、<a href="#509-斐波那契数">509</a> | <a href="#1137-第 N 个泰波那契数">1137</a>  |   <a href="#42-接雨水">42</a>   | <a href="#11-盛最多水的容器">11</a>、<a href="#70-爬楼梯">70</a> | <a href="#746-使用最小花费爬楼梯">746</a> |   <a href="#695-岛屿的最大面积">695</a>   |      <a href="#463-岛屿的周长">463</a>       | <a href="#1444-切披萨的方案数">1444</a> |   <a href="#1293-网格中的最短路径">1293</a>   |         <a href="#1293-网格中的最短路径">1293(2)</a>         |      <a href="#93-复原 IP 地址">93</a>       | <a href="#46-全排列">46</a>、<a href="#1254-统计封闭岛屿的数目">1254</a> |                <a href="#494-目标和">494</a>                 |            <a href="#300-最长递增子序列">300</a>             | <a href="#673-最长递增子序列的个数">673</a> | <a href="#673-最长递增子序列的个数">673(2)</a> |                                                              |               <a href="#391-完美矩形">391</a>                |         <a href="#563-二叉树的坡度">563</a>          | <a href="#198-打家劫舍">198</a>、<a href="#213-打家劫舍 II">213</a> |          <a href="#337-打家劫舍 III">337</a>          | <a href="#55-跳跃游戏">55</a>、<a href="#740-删除并获得点数">740</a> | <a href="#45-跳跃游戏 II">45</a> | <a href="#322-零钱兑换">322</a> |    <a href="#518-零钱兑换 II">518</a>     | <a href="#47-全排列 II">47</a> | <a href="#1020-飞地的数量">1020</a> |      <a href="#72-编辑距离">72</a>      | <a href="#145-二叉树的后序遍历">145</a>、<a href="#1143-最长公共子序列">1143</a> |                  ——                  |
| 十二月 |          <a href="#145-二叉树的后序遍历">145(2)</a>          |             <a href="#1905-统计子岛屿">1905</a>              | <a href="#124-二叉树中的最大路径和">124</a> | <a href="#5-最长回文子串">5</a> |        <a href="#1857-有向图中最大颜色值">1857(2)</a>        |       <a href="#207-课程表">207</a>       | <a href="#121-买卖股票的最佳时机">121</a> | <a href="#122-买卖股票的最佳时机 II">122</a> |    <a href="#210-课程表 II">210</a>     | <a href="#123-买卖股票的最佳时机 III">123</a> | <a href="#207-课程表">207(2)</a>、<a href="#210-课程表 II">210(2)</a> | <a href="#188-买卖股票的最佳时机 IV">188</a> |                                                              | <a href="#630-课程表 III">630</a>、<a href="#1462-课程表 IV">1462</a> |                                                              |    <a href="#1494-并行课程 II">1494</a>     |     <a href="#2050-并行课程 III">2050</a>      | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368(2)</a> | <a href="#1411-给 N x 3 网格图涂色的方案数">1411</a> |            <a href="#980-不同路径 III">980(2)</a>            |                                                       |                                                              |                                  |                                 |                                           |                                |                                     |                                         |                                                              |                                      |

### 日常做题感受与初次总结

|  完成时间  |                           题目编号                           | 感受                                                         |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------- |
| 2021.04.26 |           <a href="#112-路径总和">112-路径总和</a>           |                                                              |
| 2021.05.09 |         <a href="#344-反转字符串">344-反转字符串</a>         |                                                              |
| 2021.09.19 | <a href="#105-从前序与中序遍历序列构造二叉树">105-从前序与中序遍历序列构造二叉树</a> |                                                              |
| 2021.09.22 | <a href="#106-从中序与后序遍历序列构造二叉树">106-从中序与后序遍历序列构造二叉树</a> |                                                              |
| 2021.10.15 |       <a href="#146-LRU 缓存机制">146-LRU 缓存机制</a>       |                                                              |
| 2021.10.15 | <a href="#1857-有向图中最大颜色值">1857-有向图中最大颜色值</a> | 【2021.12.05-后期补充】之所以发现这道题，是因为在某次查看他人的笔试中说遇到了其它的某个题，然后评论里说那个题和这个题很像，就来搜搜看看了。这道题对于那时的我，哪怕是此时的我都挺难的，今天再次做这题，还是做不起，还是不足，了解得太少了。 |
| 2021.10.16 |     <a href="#146-LRU 缓存机制">146(2)-LRU 缓存机制</a>      |                                                              |
| 2021.10.18 |     <a href="#23-合并K个升序链表">23-合并K个升序链表</a>     | 思路一致，具体代码实现有差别                                 |
| 2021.10.19 | <a href="#3-无重复字符的最长子串">3-无重复字符的最长子串</a> | 很巧合，与答案思想差不多，实现不同                           |
| 2021.10.20 |        <a href="#35-搜索插入位置">35-搜索插入位置</a>        | 思考的不够简洁，但是挺有逻辑性，官方的或者他人的要简洁些，但是理解上需要总结一下规律 |
| 2021.10.21 |            <a href="#15-三数之和">15-三数之和</a>            | 一开始完全没有头绪，只能想到暴力破解，最后去重，于是直接查看答案，并按照答案写出来 |
| 2021.10.22 |         <a href="#112-路径总和">112(2)-路径总和</a>          | 哈哈，这次做的逻辑简化后和答案一模一样                       |
| 2021.10.23 |        <a href="#113-路径总和 II">113-路径总和 II</a>        | 可以尝试做，但是没有明确思路，就按照答案做了                 |
| 2021.10.24 |           <a href="#739-每日温度">739-每日温度</a>           | 用了比官方暴力解法更为暴力的方法哈哈哈                       |
| 2021.10.26 | <a href="#147-对链表进行插入排序">147-对链表进行插入排序</a> | 同样都是实现插入排序，整体思路一致，但也有些差别，代码实现自然也就不同了 |
| 2021.10.29 |   <a href="#104-二叉树的最大深度">104-二叉树的最大深度</a>   | 这道题很简单，之前做过比这道题更难的相似的题，所以完成不难   |
| 2021.10.30 |            <a href="#62-不同路径">62-不同路径</a>            | 一开始完全没想到是动态规划，以为是递归回溯，但是知道是动态规划后就一下子知道怎么做了 |
| 2021.10.30 |         <a href="#63-不同路径 II">63-不同路径 II</a>         | 和上一题类似，难了一些，多了些条件判断                       |
| 2021.10.31 |       <a href="#344-反转字符串">344(2)-反转字符串</a>        | 看答案前我想着超简单，就是简单的数组头尾数据交换，以后可以不再复习，然而这题官方答案居然使用了双指针，这种思想我没想到，看来还是得要注意下 |
| 2021.11.01 |       <a href="#980-不同路径 III">980-不同路径 III</a>       | 还是看别人的做法完成的，官方做法还有些看不懂                 |
| 2021.11.01 |           <a href="#200-岛屿数量">200-岛屿数量</a>           | 由于今天是先做了P980再做的此题，使用DFS，方便了许多，和官方答案的DFS思路与代码差不多，实现略微不同 |
| 2021.11.02 |   <a href="#237-删除链表中的节点">237-删除链表中的节点</a>   | 差点没读懂题目，虽然做出来了，但是还是不够答案聪明，做得复杂了一点点 |
| 2020.11.02 |         <a href="#509-斐波那契数">509-斐波那契数</a>         | 以前都没有想到过可以用动态规划做这个题，一直以为是递归就行了，但是现在才发现不仅如此，还可以有官方答案的使用矩阵或者特征方程等方式作答 |
| 2021.11.03 | <a href="#1137-第 N 个泰波那契数">1137-第 N 个泰波那契数</a> | 今天才静下心来看了下这个快速矩阵幂的解答方式，线性代数真是厉害 |
| 2021.11.04 |              <a href="#42-接雨水">42-接雨水</a>              | 虽然花的时间比较久，但是还是完成了，并且效率还比较高         |
| 2021.11.05 |      <a href="#11-盛最多水的容器">11-盛最多水的容器</a>      | 由于昨天做了第42题，类型差不多，也有双指针解法，并且比此题难，所以能做出来不意外，但是其实还是对双指针掌握得不够 |
| 2021.11.05 |              <a href="#70-爬楼梯">70-爬楼梯</a>              | 这是一道爬楼梯题，解题方式和前面的斐波那契数几乎一样         |
| 2021.11.06 | <a href="#746-使用最小花费爬楼梯">746-使用最小花费爬楼梯</a> | 这是一道计算爬楼梯最低花费的题，比上一题难了一些，不过由于之前我已经学过做过背包问题，这道题相比较它来说，就很简单了 |
| 2021.11.07 |     <a href="#695-岛屿的最大面积">695-岛屿的最大面积</a>     | 这道题和P200是DFS/BFS类型的题，代码实现上只有些微差别。今后这几天就专注于递归、回溯、DFS/BFS等之类的题了，它们之间的关系有点绕 |
| 2021.11.08 |         <a href="#463-岛屿的周长">463-岛屿的周长</a>         | 此题也是属于岛屿类型的题目，比P200和P695简单许多，并且还有几种不需要DFS的解答方式，有点类似于智力题 |
| 2021.11.08 |         <a href="#827-最大人工岛">827-最大人工岛</a>         | 这道题是以上几道岛屿类型的题目中的最难的一道，可以“填海造陆”了。虽然花的时间比较久，但是还是做出来了，不过有一点疑惑，我采用Set保存了水域，最后“填海造陆”时就不用遍历整个二维数组了，但是它的效率在LeetCode上貌似还不如前者。另外，我貌似没看懂官方答案，还有看到有些使用并查集也能做，这个算法或者技巧我还没学过。 |
| 2021.11.09 |    <a href="#1444-切披萨的方案数">1444-切披萨的方案数</a>    | 本以为这是一道DFS题，感觉也是能够做出来的，我知道重复计算了一些，也优化了一下，可惜最终LeetCode上的测试用例没有通过完。中途也有想过这是不是一道动态规划的题，但是没有想到怎么用动态规划来做。搞了几个小时后，就去看别人怎么做的了，也是看了好久才理解到，真是难想啊，天，这道题连官方解答都没有，题解数加评论数才刚满100，哎，深深叹息。 |
| 2021.11.10 |  <a href="#1293-网格中的最短路径">1293-网格中的最短路径</a>  | 这道题有点像岛屿问题，也想网格中的不同路径问题，还有点像是动态规划的题。于是做这道题时，就在思考是否是用DFS，因为是求一个点到另一个点的最短路径嘛，然后由于有可以移除障碍物的功能在，就想这难道是一道动态规划的题？因为可以递归的求假设只能移除一个，然后求移除两个？然后又觉得不对，因为这题从四个方向都可以走，这个方程的值可能一直在变动，得不到最优解。然后就用DFS+回溯的方式去，先假设后续DFS完成后再回溯更改就行了，最后测试了一些感觉还真是写对了，但是在LeetCode上碰到如果是一个很大的二维数组的测试用例时，会出现超时，这也难怪，因为是求最短路径，这路径数是真的多。最后，看到别人用的BFS来做，我就想着自己也去试，哎，自己对BFS不熟练，写不出来，只有照着做了。这道题也是真的难，现在只看了一个题解，居然还用到了贪心算法，之前只是在学习的时候学过，印象不深，当然也就不会。感觉这个贪心是在如果使用动态规划做不到全局最优解时，才使用贪心来做一个局部最优解？还是得不能太大胆去做困难题啊，真是做不来，不过做了看了，希望以后碰到简单题，来个降维打击哈哈。 |
| 2021.11.11 | <a href="#1293-网格中的最短路径">1293(2)-网格中的最短路径</a> | 今天又用了一天硬是要搞这道题的DFS解法，太累人了，虽然最终通过了，但是耗时还是太多了，并且不能保证所有的以后的案例也能够通过。不过这两三天的硬着头皮做这几道难题，对DFS倒是熟悉了不少，哈哈。 |
| 2021.11.12 |        <a href="#93-复原 IP 地址">93-复原 IP 地址</a>        | 这道回溯题我是没想出来，对我来说还是蛮难的，最后还是在官方代码基础上更改的，并没本质提升。 |
| 2021.11.13 | <a href="#1254-统计封闭岛屿的数目">1254-统计封闭岛屿的数目</a> | 这道题目属于岛屿问题，与P200很类似，之前做过比此更难的，因此相对来说已经不难了，但是还是有些细节上的问题没有一开始就想到。 |
| 2021.11.13 |              <a href="#46-全排列">46-全排列</a>              | 今天这题又是一道回溯题，代码并不多，但是自己写就完全没这个思路。 |
| 2021.11.14 |             <a href="#494-目标和">494-目标和</a>             | 昨晚无意间做到牛客网上的华为题库中一道机试题HJ93，这道题之前理解错题意，做错了，并且自己也做不来，后来发现这道题是一道回溯的题，然后又发现，该题可以等价于这道LeetCode上的这道题，于是再把这道题给解决了，这题居然还能用动态规划做，看来这几个算法和思想真是互通的。 |
| 2021.11.15 |     <a href="#300-最长递增子序列">300-最长递增子序列</a>     | 最长递增子序列，最初做这道类似题是在牛客网的面经中碰到的，然后去做，那道题[**最长上升子序列(三)**](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481)要求的是求出所有的最长递增序列，并且还要求出按照字典排序最小的那个序列，然后做了好久。我首先认为是可以用回溯来做，最后也应该没错，但是题目有要求时间复杂度，回溯就肯定不满足了。于是在LeetCode上搜相关的题，首先搜到的是P673，想了一下，还是做不来，在看到官方答案时，有提示P300这道题是P673的前置题，就是简单一点的题，然后才来做这道题。在知道了是用动态规划解答的情况下，也还是想不出来这个转移过程，而至于贪心+二分查找，刚开始看就很懵。真是挺佩服这个贪心思想，真是想不到，还有这个最后二分查找结束后的那个插入或者赋值的下标真得注意，太模糊了。一道题一天，真是服了，现在的我心理压力好大啊，哎，继续加油吧。明天再独自做做P673。刚才看到了P673这道题评论中推荐的一个[解答](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/yi-bu-yi-bu-tui-dao-chu-zui-you-jie-fa-2-zui-chang/)中提到了个新名词——树状数组？ |
| 2021.11.16 | <a href="#673-最长递增子序列的个数">673-最长递增子序列的个数</a> | 这个题我真得吐了，动态规划的还好，那个贪心+树状数组的解答方式真是太烦了，也许是我最近生活越来越不规律，以及太过焦虑的缘故，真的好累。这个解答方式那就明天再看吧。 |
| 2021.11.17 | <a href="#673-最长递增子序列的个数">673(2)-最长递增子序列的个数</a> | 终于是终于按照答案写好了，那两个二分查找怎么写的，没有仔细看，感觉也是很难写好的。可是还是没有解决求出最小的这个最长上升子序列，后面继续加油吧。这个Flink项目不知道啥时候能做完噢，好漫长，还有刷题，虽然每天都在学，但是进度是真慢啊，哎，越学越没有信心。不过轻松一点的话，就好多了，只是我现在轻松不起来啊。 |
| 2021.11.18 |                             未做                             | 把时间耗在做项目上去了，然后遇到错误，一直去解决错误去了，哎，还是不能先做项目，后做题。 |
| 2021.11.19 |           <a href="#391-完美矩形">391-完美矩形</a>           | 今天还是先去做了项目，哎，差点又是不想做题了，以后还是乖乖地先刷题，再做其它的吧。今天我和华为的HR聊了一下哈哈，我也不知道我是否该选择那里了。还有这个项目到底是还做不噢，我不大确定了，感觉有些超出我的理解范围了，编程太多了，我还不了解理论。其它的面试题还没有复习。 |
| 2021.11.20 |       <a href="#563-二叉树的坡度">563-二叉树的坡度</a>       | 这道题还算简单，不过可能好久没有做到关于树的题了，对于树的递归、DFS还是愣了很久。这半个月来做这个Flink项目，真是太难了，今天又遇到问题了，感觉这个问题是解决不了了，我是不是应该选择放弃，多学一些其它的理论知识更好一些呢？还有差点连曾经做的数仓项目都不能正常运行了，真是焦急死了。 |
| 2021.11.21 |           <a href="#198-打家劫舍">198-打家劫舍</a>           | 有些时间没有做动态规划的题了，有感觉生疏了不少，以前写的有些代码都看不懂，或者说一时间反应不过来，没有曾经做题时的状态了。这道题我的第一感觉以为不该这么做，结果却是这样的，还真是拐不过弯来。 |
| 2021.11.21 |        <a href="#213-打家劫舍 II">213-打家劫舍 II</a>        | 这道题是上面道题的进阶版，多了个限制条件，也是自己尝试了好久，始终没能全部通过，只有看答案咯，而这个答案却是很好理解，但是还是感觉有点玄学的成分，真的这纯粹的就像是数学题了。 |
| 2021.11.22 |       <a href="#337-打家劫舍 III">337-打家劫舍 III</a>       | 二叉树类型的动态规划，又是做不起的一天，这些天的效率是真的明显下降了。 |
| 2021.11.23 |     <a href="#740-删除并获得点数">740-删除并获得点数</a>     | 这道题以看，完全没思路，或者说这两天没有思考题目的状态了，哎。万万没想到这道题可以转换为P198-打家劫舍问题。 |
| 2021.11.23 |            <a href="#55-跳跃游戏">55-跳跃游戏</a>            | 其实自己根本就没什么思路，能想到具体的算法名解决问题，这道题就靠着自己的思路解出来了，结果和官方的第二种方法一样。怎么看都不觉得这是个贪心的思想，我就认为只是个解题方式而已，没必要硬要给它取个名吧。也有可能是我还不够理解这些算法吧。 |
| 2021.11.24 |         <a href="#45-跳跃游戏 II">45-跳跃游戏 II</a>         | 之前也接触过贪心思想，这道题理解起来也还好，但是没有自己尝试写这个代码，照着答案敲了一下。 |
| 2021.11.25 |           <a href="#322-零钱兑换">322-零钱兑换</a>           | 还是不在状态，能够有感觉要这么做，但是还是没有清晰的思路，也写不出来代码。 |
| 2021.11.26 |        <a href="#518-零钱兑换 II">518-零钱兑换 II</a>        | 刚开始用类似于上一题的思路去解决此问题，只需要修改部分即可（其实在做的时候，还是迷迷糊糊的，只是感觉是如此），但是得到结果后发现这样会造成计算重复，和官方答案一比较，发现就是内外层循环位置的问题。并且还考虑过是否是一个二维的DP，但是看到官方答案的答案后，发现是一个一维的，并且有些难理解，所以跟着官方思路，结合凭着感觉的认为是二维的那个思路一思考，发现这个二维的思路和曾经最初学动态规划的那个背包问题很像，于是解决并不难。而当解决了二维的DP后，由于每一次的状态转换只与上一次的有关，依次可以将其转换为一维，并且若将外层循环改为增强for循环，就变成了和官方答案一模一样的代码实现。现在看来，这个学着学着，倒把以前的还忘了。评论里一堆人在讨论，为什么把那个coins放在外层循环，其实如果按照我的学习历程来看，放在外层的才是最基本正常的思维方式，而P322这个题的内外层循环的思维方式才是进行了特别处理的。这道题居然还和爬楼梯的题有相似之处，爬楼梯是一次选择一步或者两步，登上阶梯n步；而这道题是一次选择coins中一个值，选择若干个硬币后，价值为amount。前者为排列数，后者为组合数。 |
| 2021.11.27 |           <a href="#47-全排列 II">47-全排列 II</a>           | 今天又看了一下昨天的P518的相关的动态规划的题解，又多了些理解。今天这道回溯题，是之前做的P46的一道进阶题，做这个回溯题是真不熟练，前面做过几次回溯题，都有些卡顿，基本做不起。这一次本打算放弃了，但是稍稍看了一下P46的代码，其实也不大熟悉了，但是还是做出来了，我的想法也没错，一次搞定。但是始终没有达到那种进入刷题的那种冥想状态，哎，这种感觉真是既熟悉又陌生。今天又发现了两道类似岛屿的题目，这是我半个月前印象最深刻的题目了，但是由于没有复习，还是生了一些，下面几天做吧，等把现在收集的大概七道题做完后，就不能再去做太多新题了，应该着手巩固复习之前做的了。 |
| 2021.11.28 |        <a href="#1020-飞地的数量">1020-飞地的数量</a>        | 哈哈，没有翻以前写的代码，也还是写出来了，并且还同时写出了DFS、BFS两种解法，但是如果说状态，还是没有以前刚学岛屿问题时那么有印象和感觉。这种题连官方解答都没有，哎。再加一句，评论区有人说P130和这题很像，果然很像。 |
| 2021.11.29 |            <a href="#72-编辑距离">72-编辑距离</a>            | 这道动态规划题，不看答案真是想不出来怎么做啊/(ㄒoㄒ)/~~！它的`dp[i][j]`处的状态就由`dp[i][j−1],dp[i−1][j],dp[i−1][j−1])`处的状态转换而来。 |
| 2021.11.30 |   <a href="#145-二叉树的后序遍历">145-二叉树的后序遍历</a>   | 这是道简单题，使用递归实现还是蛮简单的，不过题目中提到是否能使用迭代的方式来解答，我一直对迭代和递归的差别不大了解，今天也没心情做这道题，等到明天来学习这个迭代吧。 |
| 2021.11.30 |    <a href="#1143-最长公共子序列">1143-最长公共子序列</a>    | 不敢确定最终答案的我，居然做对了哈哈，那一刻还是很兴奋的，这些天好久没有作对一道逐步分析做对的题目了。这道题是与P72有些相似，准确来说是同一类型的，并且还要简单一些，如果是想要循序渐进学习的话，确实该先做这题。但是既然已经存在降维打击了，就接受吧哈哈，都是题的嘛，怎么做都是做的。 |
| 2021.12.01 | <a href="#145-二叉树的后序遍历">145(2)-二叉树的后序遍历</a>  | 今天学了这个题的迭代实现，官方的看着好绕，有点懵。这个和迭代有啥关系啊？不就是不用递归，而是手动用栈实现就行了吗？ |
| 2021.12.02 |        <a href="#1905-统计子岛屿">1905-统计子岛屿</a>        | 同样是一道岛屿问题，解题思路以及代码实现都差不多的，我都感觉我快要把这类问题做完了哈哈。 |
| 2021.12.03 | <a href="#124-二叉树中的最大路径和">124-二叉树中的最大路径和</a> | 保存此题大概有一个月了，看到标的是困难标签并且以前是确实没思路，于是一直不敢做，做不起。在前几天我做了一道后序遍历的题目，然后不知道是在哪看到的还是自己想到的这道题是一个后序遍历，然后今天才开始做，一步步分析，发现这道题也并不是特别难的。整个代码结构就是一个二叉树递归实现的正常结构，只是要清楚结束条件是什么，返回值是什么，在遍历过程中需要求什么才是所需答案。有些二叉树题遍历的答案就是递归函数结束的返回值，而有些则是在历次遍历过程中与返回值相关的另一个值，当然该值在遍历各个结点的过程中也会随着返回值变化，例如本题代码实现中的`maxSum`。 |
| 2021.12.04 |         <a href="#5-最长回文子串">5-最长回文子串</a>         | 最长回文子串，这道题在很多地方都听到过了，都一直没做。动态规划的解题方式真是没想出来，而那个中心扩展算法，官方解答确实是根据根据动态规划的解题思路一步步总结而来的，但是最终代码实现完全看不到动态规划的影子。而这个中心扩展算法的做法，之前我也思考过，不过我只能想到从中间往两边找，但是没有它想的这么充分，也没有实现出来。 |
| 2021.12.05 | <a href="#1857-有向图中最大颜色值">1857(2)-有向图中最大颜色值</a> | 虽然前面做过一次，但是今天再回顾，还是同样的做不起，这个拓扑排序+动态规划，真是靠自己想，真想不出来噢，哪怕是告诉了思路，也不能自己手动实现敲出代码来。不过慢慢来嘛，哈哈。难题虽然男，但是当完成时是真的满满的充实感，并且还觉得挺有趣的。 |
| 2021.12.06 |             <a href="#207-课程表">207-课程表</a>             | 昨天找到了这道拓扑排序的题，又无意间发现还有P210_课程表Ⅱ，后面再做这道题吧。又发现搜索“课程表”会出现好几道类似相关的题目，哈哈，我就喜欢这种一个系列的题。由于昨天做了一道拓扑排序+动态规划的困难题，今天再做这道题，简单不少，其实我发现除了通用的BFS模板，对于这种拓扑排序题，也是有属于它的通用的模板。 |
| 2021.12.07 | <a href="#121-买卖股票的最佳时机">121-买卖股票的最佳时机</a> | 这道题虽然是一道动态规划的题，但是如果是在没有学动态规划之前做的话，我想也应该能够做出动态规划这种代码实现，而又正是因为学过了动态规划这种算法或者思想，或者说我提前知道了这是一道动态规划的题，我反而在做时，就不会去它的暴力解法，以及普通地不带入算法思想的只为解题而解题的思考了。 |
| 2021.12.08 | <a href="#122-买卖股票的最佳时机 II">122-买卖股票的最佳时机 II</a> | 这道题比昨天的多了一点点步骤，很小的差别。我做的动态规划，一步步优化，最终倒成了官方答案中的贪心算法，我也是醉了。虽然有这种理解，但是我还是觉得这有些为了说明而说明，为了使用而使用的感觉。而官方的动态规划和我的动态规划也不一样，初看还以为根本不是一回事，它的动态规划思路是`第 i 天交易完后手里没有股票的最大利润`和`第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）`，而我的是`截至到每天，每天的最大利润`，这直接包含了官方的这两种情况，然后就是要去想如何实现得到每天的最大利润。当看到这个题目后，我能想到的就是找到一个最低价格点，然后在紧接着的连续的后面某天最高价格处卖出就能得到最大利润值。于是想到了记录最小价格的天数索引，然后每遇到一个高于昨天的价格就卖，此时就是截至到今天能获取的最大利润，而如果今天价格低于了昨天的价格，说明截至到今天最大获利就是在昨天卖出股票后的获利，于是第一种方式就因此而来。而第二种方式是，让代码实现上看起来更像动态规划。而最后滚动数组的实现方式则变成了官方的贪心算法。另外我在评论区看到了个比较有意思的评论，`不会真有人觉得做了这题就能去炒股吧？这题不论是动态规划还是贪心都是一个思路，“事后诸葛亮”，就是在知道了今天的股市情况后去决定昨天的操作，只要今天相对于昨天涨了，就回昨天买股票，并在今天卖掉。如果今天相对于昨天跌了，就回昨天告诉自己不要买。`补充一下，我还是认为，这个不是贪心，这是肯定能得到最终最优答案的做法，这就是全局最优。 |
| 2021.12.09 |          <a href="#210-课程表 II">210-课程表 II</a>          | 此题又是前几天做过的那道课程表的进阶题，多了一点点不同，这次尝试了使用类似官方的BFS写法“`使用 List<List<Integer>> 构建邻接表`”，但是这种BFS的效率不及“`创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表`”这种方式的高。而使用DFS实现的方法，我还没做，有些力不从心了，这两天去做项目去了，时间一天天拖，真是太折磨了。 |
| 2021.12.10 | <a href="#123-买卖股票的最佳时机 III">123-买卖股票的最佳时机 III</a> | 靠自己做，走了好多弯路，错了好多次，花了五个小时才做出来，效率还很低，啊，艰难啊。而答案的思路真是太巧妙了，这个设定动态规划的方式不同，真的好影响性能，还是得慢慢学啊。 |
| 2021.12.11 |           <a href="#207-课程表">207(2)-课程表</a>            | 同下。                                                       |
| 2021.12.11 |        <a href="#210-课程表 II">210(2)-课程表 II</a>         | 这两道题都很相似，代码实现差不多，今天做的主要就是补充这两道题的DFS题解，发现DFS和BFS差不多，甚至效率还要更高些。但是还是参考了官方代码写出来的，真不敢保证一段日子后，是否还能做出来。 |
| 2021.12.12 | <a href="#188-买卖股票的最佳时机 IV">188-买卖股票的最佳时机 IV</a> | 前面几道相似题都是用的自己的思路，对于这道题再用我以前的思路有点难实现了，于是用了前几题官方的思路，在它们的基础上改变一下就是这道题的解题思路了。不过我还没细看这道题的官方解法，看着还挺多的，貌似还有些优化，等到明天再看吧。（第二天）看了一下这个官方题解，有点懵，但是和我的没有本质区别。看到了一个神奇的[题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-chong-ji-yu-wqs-er-fen-de-you-xiu-zuo-x36r/)，太厉害，到目前为止，我看到过的最难的，难的我都不想看它。 |
| 2021.12.13 |                             未做                             | 只复习了一下上一题的官方题解。                               |
| 2021.12.14 |         <a href="#630-课程表 III">630-课程表 III</a>         | 我今天原本就想做的这道题恰巧又是今天的每日一题，真是巧合哈哈。一直都没有刻意学习过贪心算法，只是在遇到问题时，感性一点地理解了一下贪心算法，原来贪心还是需要证明的，在我印象里一直就是我这么做不能保证得到完全正确答案，但是可能得到答案。这道题是值得长期巩固学习的。噢，对了，这道题和之前的两道课程表题的解题思路已经没有多大的相关性了。 |
| 2021.12.14 |         <a href="#1462-课程表 IV">1462-课程表 IV</a>         | 这道题就是判断有向图中两个节点之间是否可达，使用DFS需要在遍历过程中记忆结果，减少耗时。由于此题的特殊性，还可以使用现有算法——Floyd算法来解决。 |
| 2021.12.15 |                             同下                             | 同下。                                                       |
| 2021.12.16 |       <a href="#1494-并行课程 II">1494-并行课程 II</a>       | 花了差不多三天，两个通宵在做这个题（现在已经17号的凌晨三点了）。这题真是太牛了，走了好多冤枉路，先是尝试拓扑排序（BFS），未完全通过；然后尝试BFS加回溯，未完全通过；然后尝试BFS加回溯加贪心，未完全通过；最后硬着头皮去看他人的状态压缩DP的解答，开始时真想放弃，看得人都懵了，涉及到位运算，注释也不多，看得头痛。不过最后还好，总算理解了，并且自己写了有史以来字数最多的一次注释。但是现在回想起来，我这几天都在做这道题，没有复习其它的，是不是没有弄清楚主次？我找不到工作啊，还都是在凌晨六七点才睡觉/(ㄒoㄒ)/~~。 |
| 2021.12.17 |      <a href="#2050-并行课程 III">2050-并行课程 III</a>      | 今天凌晨睡得还是要早一点，睡的时候都在想这个题怎么做。白天也没有想不出来，但是一看到别人的题解思路，就知道怎么做了，也没看别人的代码就写出来了，哈哈。起初，其实我还以为这道题也可以用状态压缩DP做，但是看到题目的数量级很大，就能肯定是不能使用这个的，但是好奇心还是让我去试了一下，稍稍修改了上一题的代码，发现还是能通过几个案例的哈哈。 |
| 2021.12.18 | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368-使网格图至少有一条有效路径的最小代价</a> | 以为自己能做成功，结果DFS运行超时（此题等价于求最短路径，DFS不适合），使用BFS时对题的理解有些到位，没能全部通过。然后，看了一下别人的，差别其实不大，就是我认为是从左上更新就行了，其实并不是的，还是不能贪心的认为（尝试）这个能得到答案。比较起来，我如果将比较的代码换一下位置，再补上四个方向就对了。这道题还让我接触到了新的BFS算法，什么0-1BFS算法，SPFA算法，这些都是前人论文里的吧，没系统学习过，了解得好不全面。此外此题的最优解法是 Dijkstra 算法，以前学过看过，现在都忘记差不多了，也只有明天再看了。 |
| 2021.12.19 | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368(2)-使网格图至少有一条有效路径的最小代价</a> | 看了一下 Dijkstra 算法和 0-1 BFS，对于这道题来说，这两差不多啊，后者是前者的优化。 |
| 2021.12.20 | <a href="#1411-给 N x 3 网格图涂色的方案数">1411-给 N x 3 网格图涂色的方案数</a> | 这道题昨晚看时第一感觉以及思考方向都对了，但是推的过程错了，今天重推后改正了过来，但是即便是对了也还是没有想到代码怎么写，看了别人的两行解释，自己就明白了，哈哈，真是没想到可以这样思考递推公式。最后，这道题就很轻松地用递推来做了，其实看起来还是挺像动态规划的，说是动态规划也是可以的。这道题是Nx3的网格涂色，我还看到还有一道MxN网格的涂色问题，看别人的题解名字，好像还是道状态压缩DP题。 |
| 2021.12.21 |     <a href="#980-不同路径 III">980(2)-不同路径 III</a>      | 回过头来看这个曾经看不懂的解法——状态压缩 DP，这次总算看懂了，由于之前有了P1494这道状态压缩 DP 解题的经验，这道题就相对而言，简单不是一点半点，但是真要自己独立做出来的话，也还是蛮难的。说一个忘记记录的题外话，昨天我下载了几个WAV格式的无损CD，那低沉的声音真是惊艳到我了，然后发现采样率是1411kbps，碰巧我昨天做的题的题号也是1411，哈哈，这就是巧合吧。 |

## 算法理论/问题/区别/总结

###### 1.递归、回溯和深度优先搜索(DFS)的区别？动态规划？记忆化搜索（递归？）？

从第<a href="#509-斐波那契数">509</a>题貌似可以看到动态规划其实在有些时候是递归的一种优化？减少递归过程中的计算次数？

2021.11.27

在做P518时，看到了一篇讲解P509和P518的[题解](https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/)，主要讲了一些关于动态规划的套路，也得到了一些思路。

递归是自顶向下，动态规划是自底向上。记忆化搜索（递归）或者带备忘录的搜索（递归）产生的这个数组，其实和动态规划数组最终结果是一样的。这样来看，虽然递归和动态规划有些类似，但是还是有区别，反而是迭代和动态规划的关系更加亲密一点。

###### 2.迭代？和深度优先搜索有关系吗？——2021.11.08

P463

2021.12.06

来源：P207的官方解答的复杂度分析

递归和深度优先搜索有关系（等价？），迭代和广度优先搜索有关系（等价？）

###### 3.是不是动态规划不适合的时候，就要考虑贪心？——2021.11.10

###### 4.回溯就是在DFS的基础上记忆曾经遍历的过程，在回退过程中会被修改？——2021.11.12

P93

###### 5.回溯 DFS的一些评论

> [评论区](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)
>
> 计算机领域的一些大神爱造词，明明是 DFS 非要叫回溯算法，「明明老一套的神经网络非要起个名称，叫深度学习，明明是加权和非要起个名字叫卷积，明明是对输入加权，非要起个名字叫注意力机制，还有什么 transform」
>
> 「明明是深度优先搜索，非要起个名字叫“回溯法”，就是根据约束剪枝，非要起个名字叫限界函数，明明就是广度优先搜索，非要起个名字叫分支限界。」
>
> 我觉得可以把回溯理解成dfs的一个特殊情况，特殊之处在于一般的dfs完之后不会去清理或者处理当前的结果，因为结果不会影响后续的遍历；但是回溯需要去处理当前的结果，即回到原始状态，这样不会干扰下一次循环。
>
> 回溯算法就是 DFS。把使用回溯算法的「树形结构」画出来，得到一个问题的所有的解的方式，就是在这个树形结构上执行一次深度优先遍历。
>
> 有「撤销操作」是因为深度优先遍历回到以前来过的地方的某个地方时候，相关的变量需要恢复成以前一样，这样去尝试新的方案的时候才是有效的。
>
> 要通过「遍历」所有可能的解的方式得到一个问题的所有的解的时候，就会有「撤销选择」这种操作。

2021.12.05

今天做P1857时，采用了拓扑排序，我想说它不就是个用BFS或者DFS实现的吗？我都怀疑这个是不是也是为了取名而取名。

###### 6.树状数组——2021.11.16

###### 7.拓扑排序不是一种排序算法吧？只是对有向图中节点的一种特定排序规则（现象）的一个命名吧？——2021.12.06

## 算法分类

### 排序算法

| 排序算法 | 字符串 | 数组 |               （单向）链表                |  栈  | 队列 | 树（二叉树） |  图  |
| :------: | :----: | :--: | :---------------------------------------: | :--: | :--: | :----------: | :--: |
| 冒泡排序 |        |      |                                           |      |      |              |      |
| 选择排序 |        |      |                                           |      |      |              |      |
| 插入排序 |        |      | <a href="#147-对链表进行插入排序">147</a> |      |      |              |      |
| 希尔排序 |        |      |                                           |      |      |              |      |
| 快速排序 |        |      |                                           |      |      |              |      |
| 归并排序 |        |      |                                           |      |      |              |      |
| 基数排序 |        |      |                                           |      |      |              |      |
|  堆排序  |        |      |                                           |      |      |              |      |

### 查找算法

| 查找算法 |               数组                |
| :------: | :-------------------------------: |
| 二分查找 | <a href="#35-搜索插入位置">35</a> |
| 插值查找 |                                   |

> 线性查找、斐波那契（黄金分割法）查找

### 基础算法

> 使用单一算法就能解决的问题

|            算法            |                            字符串                            |                           一维数组                           |                           二维数组                           |                单向链表                 |                              栈                              |                             队列                             |                            二叉树                            |          堆（优先队列）           |                            有向图                            |                            无向图                            |                        其它（数学题）                        |
| :------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|          基本操作          |                                                              |                 <a href="#42-接雨水">42</a>                  |                                                              | <a href="#237-删除链表中的节点">237</a> |                                                              |                                                              |                                                              |                                   |                                                              |                                                              |                                                              |
|           哈希表           |                                                              |                                                              |               <a href="#391-完美矩形">391</a>                |                                         |                                                              |                                                              |                                                              |                                   |                                                              |                                                              |                                                              |
|            递归            |                                                              |                                                              |                                                              |                                         |                                                              |                                                              | <a href="#124-二叉树中的最大路径和">124</a>、<a href="#145-二叉树的后序遍历">145</a> |                                   |                                                              |                                                              | <a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a> |
|            迭代            |                                                              |                                                              |              <a href="#463-岛屿的周长">463</a>               |                                         |                                                              |                                                              |           <a href="#145-二叉树的后序遍历">145</a>            |                                   |                                                              |                                                              |                                                              |
|            回溯            |              <a href="#93-复原 IP 地址">93</a>               | <a href="#46-全排列">46</a>、<a href="#47-全排列 II">47</a>、<a href="#494-目标和">494</a> |             <a href="#980-不同路径 III">980</a>              |                                         |                                                              |                                                              |                                                              |                                   |                                                              |                                                              |                                                              |
|          分治算法          |                                                              |                                                              |                                                              |  <a href="#23-合并K个升序链表">23</a>   |                                                              |                                                              |                                                              |                                   |                                                              |                                                              |                                                              |
|          贪心算法          |                                                              | <a href="#45-跳跃游戏 II">45</a>、<a href="#55-跳跃游戏">55</a> |                                                              |                                         |                                                              |                                                              |                                                              | <a href="#630-课程表 III">630</a> |                                                              |                                                              |                                                              |
|          动态规划          | <a href="#5-最长回文子串">5</a>、<a href="#72-编辑距离">72</a>、<a href="#1143-最长公共子序列">1143</a> | <a href="#42-接雨水">42</a>、<a href="#121-买卖股票的最佳时机">121</a>、<a href="#122-买卖股票的最佳时机 II">122</a>、<a href="#123-买卖股票的最佳时机 III">123</a>、<a href="#188-买卖股票的最佳时机 IV">188</a>、<a href="#198-打家劫舍">198</a>、<a href="#213-打家劫舍 II">213</a>、<a href="#300-最长递增子序列">300</a>、<a href="#322-零钱兑换">322</a>、<a href="#518-零钱兑换 II">518</a>、<a href="#673-最长递增子序列的个数">673</a>、<a href="#740-删除并获得点数">740</a>、<a href="#746-使用最小花费爬楼梯">746</a> | <a href="#62-不同路径">62</a>、<a href="#494-目标和">494</a>、<a href="#1444-切披萨的方案数">1444</a> |                                         |                                                              |                                                              |             <a href="#337-打家劫舍 III">337</a>              |                                   |                                                              |                                                              | <a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>、<a href="#1411-给 N x 3 网格图涂色的方案数">1411</a> |
|        状态压缩 DP         |                                                              |                                                              |                                                              |                                         |                                                              |                                                              |                                                              |                                   |             <a href="#1494-并行课程 II">1494</a>             |                                                              |                                                              |
|      深度优先搜索 DFS      |                                                              |                                                              | <a href="#200-岛屿数量">200</a>、<a href="#463-岛屿的周长">463</a>、<a href="#695-岛屿的最大面积">695</a>、<a href="#827-最大人工岛">827</a>、<a href="#1020-飞地的数量">1020</a>、<a href="#1254-统计封闭岛屿的数目">1254</a>、<a href="#1905-统计子岛屿">1905</a> |                                         | <a href="#200-岛屿数量">200</a>、<a href="#695-岛屿的最大面积">695</a> |                                                              |             <a href="#563-二叉树的坡度">563</a>              |                                   | <a href="#207-课程表">207</a>、<a href="#210-课程表 II">210</a>、<a href="#1462-课程表 IV">1462</a> |                                                              |                                                              |
|      广度优先搜索 BFS      |                                                              |                                                              |                                                              |                                         |                                                              | <a href="#200-岛屿数量">200</a>、<a href="#695-岛屿的最大面积">695</a>、<a href="#1020-飞地的数量">1020</a>、<a href="#1254-统计封闭岛屿的数目">1254</a>、<a href="#1905-统计子岛屿">1905</a> |                                                              |                                   | <a href="#207-课程表">207</a>、<a href="#210-课程表 II">210</a>、<a href="#1462-课程表 IV">1462</a> | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> |                                                              |
|         普里姆算法         |                                                              |                                                              |                                                              |                                         |                                                              |                                                              |                                                              |                                   |                                                              |                                                              |                                                              |
|       克鲁斯卡尔算法       |                                                              |                                                              |                                                              |                                         |                                                              |                                                              |                                                              |                                   |                                                              |                                                              |                                                              |
| 迪杰斯特拉（Dijkstra）算法 |                                                              |                                                              |                                                              |                                         |                                                              |                                                              |                                                              |                                   |                                                              | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> |                                                              |
|   弗洛伊德（Floyd）算法    |                                                              |                                                              |                                                              |                                         |                                                              |                                                              |                                                              |                                   |              <a href="#1462-课程表 IV">1462</a>              |                                                              |                                                              |

> 动态规划可以通过滚动数组思想减小空间复杂度，如题509，貌似42中也是（使用双指针解决时）

### 多种算法

> 同时使用到多种算法才能解决的问题，大部分这类题都属于困难题了

|            算法            | 字符串 |                  一维数组                   |              二维数组               | （单向）链表 |  栈  |                   队列                    | 树（二叉树） |                            有向图                            |
| :------------------------: | :----: | :-----------------------------------------: | :---------------------------------: | :----------: | :--: | :---------------------------------------: | :----------: | :----------------------------------------------------------: |
|      贪心 + 二分查找       |        |    <a href="#300-最长递增子序列">300</a>    |                                     |              |      |                                           |              |                                                              |
|  贪心 + 前缀和 + 二分查找  |        | <a href="#673-最长递增子序列的个数">673</a> |                                     |              |      |                                           |              |                                                              |
|         BFS + 贪心         |        |                                             |                                     |              |      | <a href="#1293-网格中的最短路径">1293</a> |              |                                                              |
|     DFS + 状态压缩 DP      |        |                                             | <a href="#980-不同路径 III">980</a> |              |      |                                           |              |                                                              |
| 拓扑排序（BFS） + 动态规划 |        |                                             |                                     |              |      |                                           |              | <a href="#1857-有向图中最大颜色值">1857</a>、<a href="#2050-并行课程 III">2050</a> |

### 其它技巧

|   其它技巧   |                 字符串                  |                           一维数组                           |                  二维数组                   |               栈                |                        其它（数学题）                        |
| :----------: | :-------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :-----------------------------: | :----------------------------------------------------------: |
|   数学公式   |                                         |                                                              |  <a href="#62-不同路径">62</a>（组合数学）  |                                 | 【矩阵快速幂、通项公式】(<a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>） |
|     递推     |                                         |                                                              |                                             |                                 |     <a href="#1411-给 N x 3 网格图涂色的方案数">1411</a>     |
|   滑动窗口   | <a href="#3-无重复字符的最长子串">3</a> |                                                              |                                             |                                 |                                                              |
|    单调栈    |                                         |                                                              |                                             |   <a href="#42-接雨水">42</a>   |                                                              |
|    双指针    |                                         | <a href="#11-盛最多水的容器">11</a>、<a href="#42-接雨水">42</a>（感觉像是对动态规划的优化） |                                             |                                 |                                                              |
|    并查集    |                                         |                                                              | <a href="#1254-统计封闭岛屿的数目">1254</a> |                                 |                                                              |
|    扫描线    |                                         |                                                              |                                             | <a href="#391-完美矩形">391</a> |                                                              |
| 中心扩展算法 |     <a href="#5-最长回文子串">5</a>     |                                                              |                                             |                                 |                                                              |

> 解释，不包含在表中了
>
> 数学公式：
>
> 有些题根据题意可以使用数学上的某些公式或现有定理直接计算得出答案

## 题目合集（待定）

> 对做过的题目中遇到的相似问题或者难度上渐进的系列问题进行汇总

### 网格中的岛屿问题

P200、P695、P980

### 网格中的不同路径问题、最短路径问题

P62、P63、980

最长子序列

P300、P673

### 图

#### 拓扑排序 （Topological sort）

P207、P210、P1857

拓扑排序并不是排序算法

#### 最小生成树算法

#### 最短路径算法

http://c.biancheng.net/algorithm/dijkstra.html

实际生产和生活中，经常需要查找最短路径，例如借助高德、腾讯地图等导航工具查找到目的地的最短可行路线，建立道路交通网、物流运输网络、计算机网络等，这时就可以使用最短路径算法。

|                         最短路径算法                         | 描 述                                                        |
| :----------------------------------------------------------: | :----------------------------------------------------------- |
| [迪杰斯特拉算法](http://c.biancheng.net/algorithm/dijkstra.html)（Dijkstra） | 寻找某个特定顶点到其它所有顶点的最短路径，该算法要求所有路径的权值为非负数。 |
| [弗洛伊德算法（](http://c.biancheng.net/algorithm/floyd-warshall.html)Floyd-Warshall） | 寻找各个顶点之间的最短路径，允许非环路的路径权值为负数，该算法不仅适用于稀疏图，在稠密图（路径数量多的图）中寻找最短路径的效率也很高。 |
|                贝尔曼福特算法（Bellman-Ford）                | 寻找某个特定顶点到其它所有顶点的最短路径，该算法允许路径的权值为负数。  推荐阅读：[图解贝尔曼福特算法](https://blog.csdn.net/a8082649/article/details/81812000)：详尽的讲解过程和丰富的实例演示，最终用 Java 语言实现该算法。 |
|                    约翰逊算法（Johnson）                     | 寻找各个顶点之间的最短路径，允许非环路的路径权值为负数，该算法更适用于稀疏图（路径数量少的图）。  推荐阅读：[Johnson 全源最短路径算法](https://blog.csdn.net/aijianxie8808/article/details/101647844)：详细讲解了 Johnson 算法的实现过程，最终实现的演示代码用 C# 实现。[Johnson 全源最短路径算法](https://www.cnblogs.com/mk-oi/p/13604088.html)：以作者自身的理解讲解了 Johnson 算法，最终实现的演示程序用 C++ 实现。 |

### 动态规划

待整理

P322、P518

<a href="#518-零钱兑换 II">518-零钱兑换 II</a>

状态压缩 DP

<a href="#1494-并行课程 II">1494-并行课程 II</a>

####  路径问题（目录）

[讲解](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485580&idx=1&sn=84c99a0a8ab7b543c3678db577309b97)

62.不同路径（中等）

63.不同路径 II（中等）

64.最小路径和（中等）

120.三角形最小路径和（中等）

931.下降路径最小和（中等）

1289.下降路径最小和 II（困难）

1575.统计所有可行路径（困难）

576.出界的路径数（中等）

1301.最大得分的路径数目（困难）

#### 背包问题（目录）

##### 01背包问题 [第一讲](https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg)

【练习】01背包 : 背包问题 第二讲（416. 分割等和子集）

【学习&练习】01背包 : 背包问题 第三讲（416. 分割等和子集）

##### 完全背包问题

【练习】完全背包 : 背包问题 第五讲（279. 完全平方数）

【练习】完全背包 : 背包问题 第六讲（322. 零钱兑换）

【练习】完全背包 : 背包问题 第七讲（518. 零钱兑换 II）

##### 多重背包问题 第八讲

多重背包（优化篇）

多重背包（优化篇）: 背包问题 第九讲

多重背包（优化篇）: 背包问题 第十讲

##### 混合背包问题 第十一讲

【练习】混合背包

##### 分组背包问题

【练习】分组背包

##### 多维背包问题

【练习】多维背包 : 背包问题 第 * 讲（474. 一和零）
【练习】多维背包 : 背包问题 第 * 讲（879. 盈利计划）

##### 树形背包问题

【练习】树形背包

##### 背包求方案数

【练习】背包求方案数 : 背包问题 第 * 讲（494. 目标和）
【练习】背包求方案数 : 背包问题 第 * 讲（879. 盈利计划）

##### 背包求具体方案

【练习】背包求具体方案 : 背包问题 第 * 讲（1049. 最后一块石头的重量 II）

##### 泛化背包

【练习】泛化背包

01背包问题的状态转移方程:
[![img](https://camo.githubusercontent.com/b5d46dbf2c02e9543c4a89844fb4a6372ef825e2d7b4f3047f702d6ff7580703/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762d63253542692535442535442b7725354269253544253239)](https://camo.githubusercontent.com/b5d46dbf2c02e9543c4a89844fb4a6372ef825e2d7b4f3047f702d6ff7580703/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762d63253542692535442535442b7725354269253544253239)
[![img](https://camo.githubusercontent.com/ae4cf23fb8d6b7160671af13f36383d48e34a43895ebd4b781d26542bd2cdabf/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f6470253542762535442532302533442532304d6174682e6d61782532386470253542762535442532436470253542762d63253542692535442535442b7725354269253544253239)](https://camo.githubusercontent.com/ae4cf23fb8d6b7160671af13f36383d48e34a43895ebd4b781d26542bd2cdabf/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f6470253542762535442532302533442532304d6174682e6d61782532386470253542762535442532436470253542762d63253542692535442535442b7725354269253544253239)

完全背包问题的状态转移方程:
[![img](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)
[![img](https://camo.githubusercontent.com/1668dfe466aeb13c4a0616889aad0163e097f1709620be16815ff6a351899a0b/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d3125354425354276253544253243647025354269253544253542762d63253542692535442535442b7725354269253544253239)](https://camo.githubusercontent.com/1668dfe466aeb13c4a0616889aad0163e097f1709620be16815ff6a351899a0b/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d3125354425354276253544253243647025354269253544253542762d63253542692535442535442b7725354269253544253239)

多重背包问题的状态转移方程:(和完全背包一致)
[![img](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)

#### 股票问题

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- 动态规划用于求解 **多阶段决策问题** ；
- 动态规划问题的问法：**只问最优解，不问具体的解**；
- 掌握 **无后效性** 解决动态规划问题：把约束条件设置成为状态。

##### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```
此题到底是不是贪心算法啊？搞不懂为什么大家都说这是个贪心算法，我认为这道题就不是个贪心算法啊。我认为的贪心算法是，当我们不能确定这种方式能得到最优解，但是能得到一个可能是最优解的解的时候才使用贪心的思想。而这道题的这个贪心算法得出来的解，就是最优解，这不是可能得到，而是一定的，因此我认为官方解就不能说是贪心算法。也许是我一步步从动态规划推导出来的，最后得到的结果和官方贪心算法的实现几乎一致，只是思考过程不同，让我觉得非要给解答方式命名，这有些为了刻意做题而刻意套用了这些算法及其思想来解释，虽然说得通，但是这总有些为了做题为了多解而出现的，这并不是正常思考解题步骤的方式。

而对于官方的动态规划题解，我也有不同的看法，我看很多题解也都是说的在某天买股票或者卖股票的利润，这也说的通，不过还是复杂了些。 我想的动态规划是， 截至到每天，每天的最大利润 ，这就直接包含了官方的两种情况。然后就是要去想如何实现得到每天的最大利润。

当看到这个题目后，我能想到的就是找到一个最低价格点，然后在紧接着的连续的后面某天最高价格处卖出就能得到最大利润值。于是想到了记录最小价格的天数索引，然后每遇到一个高于昨天的价格就卖，此时就是截至到今天能获取的最大利润，而如果今天价格低于了昨天的价格，说明截至到今天最大获利就是在昨天卖出股票后的获利，于是第一种方式就因此而来。而第二种方式是，让代码实现上看起来更像动态规划。而最后滚动数组的实现方式则变成了官方的贪心算法。

其实想想，官方分成多个区间求子区间可能最大利润，相加后等于最终答案，整个区间的最大利润，也行。

哎，我不纠结了，多种思考方式也好。以下是我得到与官方贪心算法的代码实现几乎一样的过程——将动态规划dp[]数组压缩成dp整型变量的过程。

其实我有想过，假如我们都不懂动态规划和贪心算法，就是假设我们没学过这两算法，我们能出这道题目的思路应该都是遍历数组，找到一个最小值，又找到后面几天中的最大值（遇到比前一天小的，说明就找到了），然后求其差保存，然后最大值的后面一天就认为是最小值，再去依次找比它大的值求差，最终得到答案。这种没有运用算法的原始的思路也应该不要忘，这个方式做出来的复杂度也是最优的。我的意思是不要为了用算法而用算法，不要为了给自己的解题方式取名而去寻求与现有哪个算法相似。最理想的状态是，做题没想什么算法，但是最火实现却和运用了算法思想解题的一致。我咋感觉是在说武功秘笈，化有招为无招，扯远了扯远了。
```

##### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

##### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

[待学习的题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-chong-ji-yu-wqs-er-fen-de-you-xiu-zuo-x36r/)

第十四讲 最佳买卖股票时机含冷冻期
第十五讲 买卖股票的最佳时机含手续费

## Problems

### 题目记录

| 题目编号                                                     |   数据结构    |                 算法                 | 难度 | 初次完成时间 | 最近完成时间 | 完成次数 | 第一次是否独立完成 | 最近一次完成是否是独立完成 | 是否有不同于官方答案的解题思路 | 是否需要重点复习(ABCD四个等级) |                       页内跳转                        |
| :----------------------------------------------------------- | :-----------: | :----------------------------------: | :--: | :----------: | :----------: | :------: | :----------------: | :------------------------: | :----------------------------: | :----------------------------: | :---------------------------------------------------: |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) |    字符串     |               滑动窗口               | 中等 |  2021.10.19  |  2021.10.19  |    1     | 是                 |             是             |               是               |               C                |        <a href="#3-无重复字符的最长子串">3</a>        |
| [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/) | 字符串 | 动态规划、中心扩展算法、Manacher 算法 | 中等 | 2021.12.04 | 2021.12.04 | 1 | 否 | 否 | 否 | B | <a href="#5-最长回文子串">5</a> |
| [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/) |     数组      |                双指针                | 中等 |  2021.11.05  |  2021.11.05  |    1     | 是                 |             是             |               否               |               C                |          <a href="#11-盛最多水的容器">11</a>          |
| [15. 三数之和](https://leetcode-cn.com/problems/3sum/)       |      数组      | 排序+双指针 | 中等 |  2021.10.21  |  2021.10.21  |    1     | 否                 |             否             |               否               |               C               |   <a href="#15-三数之和">15</a>   |
| [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) |     链表      |                 分治                 | 困难 |  2021.10.18  |  2021.10.18  |    1     | 是                 |             是             |               否               |               A                |         <a href="#23-合并K个升序链表">23</a>          |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) |     数组      |               二分查找               | 简单 |  2021.10.20  |  2021.10.20  |    1     | 是                 |             是             |               是               |               C                |           <a href="#35-搜索插入位置">35</a>           |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) |     数组      |       动态规划、单调栈、双指针       | 困难 |  2021.11.04  |  2021.11.04  |    1     | 是                 |             是             |               是               |               A                |              <a href="#42-接雨水">42</a>              |
| [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/) | 数组 | 贪心 | 中等 | 2021.11.24 | 2021.11.24 | 1 | 否 | 否 | 否 | B | <a href="#45-跳跃游戏 II">45</a> |
| [46. 全排列](https://leetcode-cn.com/problems/permutations/) | 数组 | 回溯 | 中等 | 2021.11.13 | 2021.11.13 | 1 | 否 | 否 | 否 | B | <a href="#46-全排列">46</a> |
| [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) | 数组 | 回溯 | 中等 | 2021.11.27 | 2021.11.27 | 1 | 是 | 是 | 否 | B | <a href="#47-全排列 II">47</a> |
| [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/) | 数组 | 贪心 | 中等 | 2021.11.23 | 2021.11.23 | 1 | 是 | 是 | 否 | C | <a href="#55-跳跃游戏">55</a> |
| [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/) |     数组      |          动态规划/组合数学           | 中等 |  2021.10.30  |  2021.10.30  |    1     | 是                 |             是             |               是               |               B                |             <a href="#62-不同路径">62</a>             |
| [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) |     数组      |               动态规划               | 中等 |  2021.10.30  |  2021.10.30  |    1     | 是                 |             是             |               是               |               B                |           <a href="#63-不同路径 II">63</a>            |
| [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) |    数学题     | 递归、动态规划、矩阵快速幂、通项公式 | 简单 |  2021.11.05  |  2021.11.05  |    1     | 是                 |             是             |               否               |               D                |              <a href="#70-爬楼梯">70</a>              |
| [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) | 字符串 | 动态规划 | 困难 | 2021.11.29 | 2021.11.29 | 1 | 否 | 否 | 否 | B | <a href="#72-编辑距离">72</a> |
| [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/) | 字符串 | 回溯 | 中等 | 2021.11.12 | 2021.11.12 | 1 | 否 | 否 | 否 | B | <a href="#93-复原 IP 地址">93</a> |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |    二叉树     |               DFS、BFS               | 简单 |  2021.10.29  |  2021.10.29  |    1     | 是                 |             是             |               否               |               C                |        <a href="#104-二叉树的最大深度">104</a>        |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |    二叉树     |                 递归                 | 中等 |  2021.09.19  |  2021.09.19  |    1     | 否                 |             否             |               否               |               A                | <a href="#105-从前序与中序遍历序列构造二叉树">105</a> |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) |    二叉树     |                 递归                 | 中等 |  2021.09.22  |  2021.09.22  |    1     | 否                 |             否             |               否               |               A                | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  |    二叉树     |              递归、DFS               | 简单 |  2021.04.26  |  2021.10.22  |    2     | 否                 |             是             |               否               |              A->C              |            <a href="#112-路径总和">112</a>            |
| [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) |    二叉树     |               DFS、BFS               | 中等 |  2021.10.23  |  2021.10.23  |    1     | 否                 |             否             |               否               |               B                |          <a href="#113-路径总和 II">113</a>           |
| [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) | 数组 | 动态规划 | 简单 | 2021.12.07 | 2021.12.07 | 1 | 是 | 是 | 否 | C | <a href="#121-买卖股票的最佳时机">121</a> |
| [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) | 数组 | 动态规划 | 中等 | 2021.12.08 | 2021.12.08 | 1 | 是 | 是 | 是 | C | <a href="#122-买卖股票的最佳时机 II">122</a> |
| [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/) | 数组 | 动态规划 | 困难 | 2021.12.10 | 2021.12.10 | 1 | 是 | 是 | 是 | B | <a href="#123-买卖股票的最佳时机 III">123</a> |
| [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) | 二叉树 | 递归（后序遍历） | 困难 | 2021.12.03 | 2021.12.03 | 1 | 是 | 是 | 是 | B | <a href="#124-二叉树中的最大路径和">124</a> |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 二叉树 | 递归、迭代 | 简单 | 2021.11.30 | 2021.12.01 | 2 | 是 | 否 | 否 | B | <a href="#145-二叉树的后序遍历">145</a> |
| [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/) | 哈希表+双链表 |                                      | 中等 |  2021.10.15  |  2021.10.16  |    2     | 否                 |             否             |               是               |               A                |          <a href="#146-LRU 缓存机制">146</a>          |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) |     链表      |               插入排序               | 中等 |  2021.10.26  |  2021.10.26  |    1     | 是                 |             是             |               是               |               B                |       <a href="#147-对链表进行插入排序">147</a>       |
| [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/) | 数组 | 动态规划 | 困难 | 2021.12.12 | 2021.12.12 | 1 | 是 | 是 | 否 | B | <a href="#188-买卖股票的最佳时机 IV">188</a> |
| [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) | 数组 | 动态规划 | 中等 | 2021.11.21 | 2021.11.21 | 1 | 否 | 否 | 否 | C | <a href="#198-打家劫舍">198</a> |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/) |     数组      |               DFS、BFS               | 中等 |  2021.11.01  |  2021.11.01  |    1     | 是                 |             是             |               否               |               A                |            <a href="#200-岛屿数量">200</a>            |
| [207. 课程表](https://leetcode-cn.com/problems/course-schedule/) | 图 | DFS、BFS | 中等 | 2021.12.06 | 2021.12.11 | 2 | 是 | 是 | 否 | B | <a href="#207-课程表">207</a> |
| [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/) | 图 | DFS、BFS | 中等 | 2021.12.09 | 2021.12.11 | 2 | 是 | 是 | 否 | B | <a href="#210-课程表 II">210</a> |
| [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/) | 数组 | 动态规划 | 中等 | 2021.11.21 | 2021.11.21 | 1 | 否 | 否 | 否 | C | <a href="#213-打家劫舍 II">213</a> |
| [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) |     链表      |             链表基础操作             | 简单 |  2021.11.02  |  2021.11.02  |    1     | 是                 |             是             |               否               |               D                |        <a href="#237-删除链表中的节点">237</a>        |
| [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) | 数组 | 动态规划、贪心+二分查找 | 中等 | 2021.11.15 | 2021.11.15 | 1 | 否 | 否 | 否 | B | <a href="#300-最长递增子序列">300</a> |
| [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) | 数组 | 记忆化搜索、动态规划 | 中等 | 2021.11.25 | 2021.11.25 | 1 | 否 | 否 | 否 | B | <a href="#322-零钱兑换">322</a> |
| [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/) | 二叉树 | 动态规划 | 中等 | 2021.11.22 | 2021.11.22 | 1 | 否 | 否 | 否 | B | <a href="#337-打家劫舍 III">337</a> |
| [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/) |     数组      |                双指针                | 简单 |  2021.05.09  |  2021.10.31  |    2     | 是                 |             是             |               是               |               D                |           <a href="#344-反转字符串">344</a>           |
| [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/) | 数组 | 哈希表 | 困难 | 2021.11.19 | 2021.11.19 | 1 | 否 | 否 | 否 | B | <a href="#391-完美矩形">391</a> |
| [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/) | 数组 | 迭代、DFS | 简单 | 2021.11.08 | 2021.11.08 | 1 | 是 | 是 | 否 | B | <a href="#463-岛屿的周长">463</a> |
| [494. 目标和](https://leetcode-cn.com/problems/target-sum/) | 数组 | 回溯、动态规划 | 中等 | 2021.11.14 | 2021.11.14 | 1 | 否 | 否 | 否 | B | <a href="#494-目标和">494</a> |
| [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/) |    数学题     | 递归、动态规划、矩阵快速幂、通项公式 | 简单 |  2021.11.02  |  2020.11.02  |    1     | 是                 |             是             |               否               |               D                |           <a href="#509-斐波那契数">509</a>           |
| [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/) | 数组 | 动态规划 | 中等 | 2021.11.26 | 2021.11.26 | 1 | 否 | 否 | 是 | A | <a href="#518-零钱兑换 II">518</a> |
| [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/) | 二叉树 | DFS | 简单 | 2021.11.20 | 2021.11.20 | 1 | 是 | 是 | 否 | D | <a href="#563-二叉树的坡度">563</a> |
| [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/) | 堆 | 贪心 | 困难 | 2021.12.14 | 2021.12.14 | 1 | 否 | 否 | 否 | A | <a href="#630-课程表 III">630</a> |
| [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) | 数组 | 动态规划、贪心 + 前缀和 + 二分查找 | 中等 | 2021.11.16 | 2021.11.17 | 2 | 否 | 否 | 否 | A | <a href="#673-最长递增子序列的个数">673</a> |
| [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/) | 数组 | DFS、BFS | 中等 | 2021.11.07 | 2021.11.07 | 1 | 是 | 是 | 否 | A | <a href="#695-岛屿的最大面积">695</a> |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) |     数组      |    单调栈    | 中等 |  2021.10.24  |  2021.10.24  |    1     | 是                 |             是             |               是               |               B               |            <a href="#739-每日温度">739</a>            |
| [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/) | 数组 | 动态规划 | 中等 | 2021.11.23 | 2021.11.23 | 1 | 否 | 否 | 否 | B | <a href="#740-删除并获得点数">740</a> |
| [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/) |     数组      |               动态规划               | 简单 |  2021.11.06  |  2021.11.06  |    1     | 是                 |             是             |               是               |               C                |       <a href="#746-使用最小花费爬楼梯">746</a>       |
| [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/) | 数组 | DFS | 困难 | 2021.11.08 | 2021.11.08 | 1 | 是 | 是 | 是 | A | <a href="#827-最大人工岛">827</a> |
| [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/) |     数组      |          回溯、DFS + 状态压缩 DP          | 困难 |  2021.11.01  |  2021.12.21  |    2    | 否                 |             否             |               否               |               A                |          <a href="#980-不同路径 III">980</a>          |
| [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/) | 数组 | DFS、BFS、并查集 | 中等 | 2021.11.28 | 2021.11.28 | 1 | 是 | 是 | 是 | B | <a href="#1020-飞地的数量">1020</a> |
| [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/) |    数学题     |      递归、动态规划、矩阵快速幂      | 简单 |  2021.11.03  |  2021.11.03  |    1     | 是                 |             是             |               否               |               D                |      <a href="#1137-第 N 个泰波那契数">1137</a>       |
| [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) | 字符串 | 动态规划 | 中等 | 2021.11.30 | 2021.11.30 | 1 | 是 | 是 | 否 | B | <a href="#1143-最长公共子序列">1143</a> |
| [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/) | 数组 | DFS、BFS、并查集 | 中等 | 2021.11.13 | 2021.11.13 | 1 | 是 | 是 | 否 | B | <a href="#1254-统计封闭岛屿的数目">1254</a> |
| [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/) | 队列 | BFS + 贪心 | 困难 | 2021.11.10 | 2021.11.11 | 2 | 否 | 否 | 是 | A+ | <a href="#1293-网格中的最短路径">1293</a> |
| [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/) | 数组 | BFS、Dijkstra 算法、0-1 BFS | 困难 | 2021.12.18 | 2021.12.19 | 2 | 否 | 否 | 否 | A | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> |
| [1411. 给 N x 3 网格图涂色的方案数](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/) | 数学题 | 递推、动态规划 |  | 2021.12.20 | 2021.12.20 | 1 | 是 | 是 | 否 | B | <a href="#1411-给 N x 3 网格图涂色的方案数">1411</a> |
| [1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/) | 数组 | 动态规划 | 困难 | 2021.11.09 | 2021.11.09 | 1 | 否 | 否 | 否 | A+ | <a href="#1444-切披萨的方案数">1444</a> |
| [1462. 课程表 IV](https://leetcode-cn.com/problems/course-schedule-iv/) | 图 | DFS、BFS、Floyd | 中等 | 2021.12.14 | 2021.12.14 | 1 | 是 | 是 | 是 | B | <a href="#1462-课程表 IV">1462</a> |
| [1494. 并行课程 II](https://leetcode-cn.com/problems/parallel-courses-ii/) | 图 | 状态压缩 DP | 困难 | 2021.12.16 | 2021.12.16 | 1 | 否 | 否 | 否 | A++ | <a href="#1494-并行课程 II">1494</a> |
| [1857. 有向图中最大颜色值](https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/) |      图       |             拓扑排序（BFS） + 动态规划             | 困难 |  2021.10.15  |  2021.12.05  |    2     | 否                 |             否             |               否               |               A+               |      <a href="#1857-有向图中最大颜色值">1857</a>      |
| [1905. 统计子岛屿](https://leetcode-cn.com/problems/count-sub-islands/) | 数组 | DFS、BFS | 中等 | 2021.12.02 | 2021.12.02 | 1 | 是 | 是 | 否 | B | <a href="#1905-统计子岛屿">1905</a> |
| [2050. 并行课程 III](https://leetcode-cn.com/problems/parallel-courses-iii/) | 图 | 拓扑排序（BFS） + 动态规划 | 困难 | 2021.12.17 | 2021.12.17 | 1 | 否 | 否 | 否 | A | <a href="#2050-并行课程 III">2050</a> |

> 页内跳转：#后 字符省略，空格变为 -
>
> <a href="#"></a>

> #### 数组——暂定可删
>

> | 题目编号                                                     | 数据结构——数组 |    算法     | 难度 | 初次完成时间 | 最近完成时间 | 完成次数 | 第一次是否独立完成 | 最近一次完成是否是独立完成 | 是否有不同于官方答案的解题思路 | 是否需要重点复习(ABCD四个等级) |                             备注                             |             页内跳转              |
> | :----------------------------------------------------------- | :------------: | :---------: | :--: | :----------: | :----------: | :------: | ------------------ | :------------------------: | :----------------------------: | :---------------------------: | :----------------------------------------------------------: | :-------------------------------: |
> | [15. 三数之和](https://leetcode-cn.com/problems/3sum/)       |      数组      | 排序+双指针 | 中等 |  2021.10.21  |  2021.10.21  |    1     | 否                 |             否             |               否               |               C               | 2021.10.21_一开始完全没有头绪，只能想到暴力破解，最后去重，于是直接查看答案，并按照答案写出来 |   <a href="#15-三数之和">15</a>   |
> | [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) |      数组      |  二分查找   | 简单 |  2021.10.20  |  2021.10.20  |    1     | 是                 |             是             |               是               |               C               | 2021.10.20_思考的不够简洁，但是挺有逻辑性，官方的或者他人的要简洁些，但是理解上需要总结一下规律 | <a href="#35-搜索插入位置">35</a> |
> | [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) |     数组      |    单调栈    | 中等 |  2021.10.24  |  2021.10.24  |    1     | 是                 |             是             |               是               |               B               | 2021.10.24_用了比官方暴力解法更为暴力的方法哈哈哈 |            <a href="#739-每日温度">739</a>            |
>

### 题目汇总

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
class P3_Solution {
    /**
     * @param s 要查找的字符串
     * @return maxLen 字符串 s 中不含有重复字符的 最长子串 的长度
     */
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        } else if (s.length() == 1) {
            return 1;
        }
        StringBuilder longestSubstring = new StringBuilder();
        // 初始化 将字符串 s 中的第一个字符加入子串中
        longestSubstring.append(s.charAt(0));
        // 初始化 最大长度 为 1 或者 0 均可
        int maxLen = 1;
        // 字符串中待比较的字符下标
        int indexStr = 1;
        // 字符串中待比较的字符在子串中的下标 如果有,返回下标;如果没有,返回 -1
        int indexSub = 0;
        while (indexStr < s.length()) {
            // indexSub = longestSubstring.indexOf(s.charAt(indexStr) + ""); // 效率不及下者
            // indexSub = longestSubstring.indexOf(String.valueOf(s.charAt(indexStr))); // 效率不及下者
            indexSub = longestSubstring.toString().indexOf(s.charAt(indexStr));
            // 如果子串中没有找到该字符,将该字符加入到子串中,并且 indexStr++,比较下一个字符
            if (indexSub == -1) {
                longestSubstring.append(s.charAt(indexStr));
                indexStr++;
            } else {
                // 如果子串中找到了该字符,说明此时子串为当前的最大子串,maxLen 为前一个 maxLen 和 当前子串长度 两者中的较大值
                maxLen = Math.max(maxLen, longestSubstring.length());
                // 在子串中删除找到的字符以前的所有字符(包括这个字符)
                // 例如 s = abcdbe 中,当比较到第二个 b 时,子串为 abcd, 重复的字符为 b, 删除 ab, 即(包含) indexSub 之前的所有字符
                // 删除后为 cd
                longestSubstring.delete(0, indexSub + 1);
                // 再在末尾加上这个重复的字符 即此时子串为 cdb
                longestSubstring.append(s.charAt(indexStr));
                // 继续比较下一个
                indexStr++;
            }
        }
        return Math.max(maxLen, longestSubstring.length());
    }
}
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```java
class P15_Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int len = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        if (len < 3) {
            return ans;
        }
        Arrays.sort(nums);
        if (nums[0] > 0) {
            return ans;
        }
        int first, second, third;
        // 枚举 a
        for (first = 0; first < len; first++) {
            // 和上一次枚举的数不相同
            if(first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            third = len - 1;
            // 枚举 b c
            for (second = first + 1; second < len; second++) {
                // 和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > -nums[first]) {
                    third--;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了,可以退出循环
                if (second == third) {
                    break;
                }
                // 找到
                if (nums[second] + nums[third] == -nums[first]) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}
```

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

##### 动态规划

```java
// 动态规划
// 此方法效率低, 在官方答案上更改而来
class P5_Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len == 0 || len == 1) {
            return s;
        }

        // 最长回文子串长度
        int maxLen = 1;
        // (第一条)最长回文子串的开始下标
        int begin = 0;

        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化
        for (int i = 0; i <= len - 2; i++) {
            // 所有长度为 1 的子串都是回文串
            dp[i][i] = true;
            // 所有长度为 2 的子串中两字符相同的子串为回文串
            // 不相同则不是回文子串, 为 false, (可省略) /* else { dp[i][j] = false; } */
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                maxLen = 2;
                begin = i;
            }
        }
        // 所有长度为 1 的子串都是回文串
        dp[len - 1][len - 1] = true;

        // 先枚举子串长度
        for (int subLen = 3; subLen <= len; subLen++) {
            // 枚举左边界，左边界的上限设置可以宽松一些, 但是这里设置得最小(临界值), 这样的话 右边界 j 就肯定不会越界
            for (int i = 0; i <= len - subLen; i++) {
                // 由 subLen 和 i 可以确定右边界，即 j - i + 1 = subLen 得
                int j = subLen + i - 1;

                // 如果这两字符相同, 则看内部子串是否为回文子串, 内部是则是, 内部不是则不是
                // 如果不相同, 则肯定不是回文子串, 为 false, (可省略) /* else { dp[i][j] = false; } */
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度 subLen 和起始位置 i
                if (dp[i][j] && subLen > maxLen) {
                    maxLen = subLen;
                    begin = i;
                }
            }
        }
        // 测试输出
//        for (int i = 0; i < len; i++) {
//            System.out.println(Arrays.toString(dp[i]));
//        }
        return s.substring(begin, begin + maxLen);
    }
}
```

##### 中心扩展算法

> 这也不算是一种通用的解题方法或者说算法，感觉只能适用于少量题目

```java
// 中心扩展算法
class P5_Solution {
    String s;
    int len;

    public String longestPalindrome(String s) {
        if (s == null) {
            return "";
        }
        this.s = s;
        this.len = s.length();
        if (len == 0 || len == 1) {
            return s;
        }

        // 最长回文子串的左右下标
        int start = 0, end = 0;
        // tempMaxLen 遍历过程中的最长回文子串长度
        int len1, len2, tempMaxLen;
        for (int i = 0; i < len; i++) {
            // 以 s.charAt(i) 为中心的奇数长度的回文子串的长度
            len1 = expandAroundCenter(i, i);
            // 以 s.charAt(i) 和 s.charAt(i + 1) 为中心的偶数长度的回文子串的长度
            len2 = expandAroundCenter(i, i + 1);
            // 此次循环中以上两种情况得到的最长回文子串的较大值
            tempMaxLen = Math.max(len1, len2);
            // 如果比历史的最长回文子串长, 更新
            if (tempMaxLen > end - start) {
                // 以上两种情况(回文子串长度为奇数或偶数)都能得到如下求左右下标的公式
                start = i - (tempMaxLen - 1) / 2;
                end = i + tempMaxLen / 2;
            }
        }

        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(int left, int right) {
        while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 返回此最长回文子串的长度
        return right - left - 1;
    }
}
```

##### Manacher 算法

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

##### 双指针

2021.11.05

> 与官方解题思路一致，实现代码上有些微区别

```java
/**
 * 双指针
 */
class P11_Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                area = Math.max(area, (right - left) * height[left]);
                left++;
            } else {
                area = Math.max(area, (right - left) * height[right]);
                right--;
            }
            // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
        }
        return area;
    }

    // 逻辑优化 —— 不计算中间过程中肯定小于等于已知最大 area 的面积
    // 但是会多了很多其它代码以及逻辑判断
    public int maxArea1(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        int temp;
        while (left < right) {
            while (height[left] < height[right]) {
                temp = left;
                area = Math.max(area, (right - left) * height[left]);
                left++;
                while (left < right && height[left] <= height[temp]) {
                    left++;
                }
                // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
            }
            while (height[left] >= height[right]) {
                temp = right;
                area = Math.max(area, (right - left) * height[right]);
                right--;
                while (left < right && height[right] <= height[temp]) {
                    right--;
                }
                // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
                if (right <= left) {
                    break;
                }
            }
        }
        return area;
    }
}
```



#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class P23_Solution {
    // 分治合并
    public ListNode mergeKLists(ListNode[] lists) {
        int k = lists.length;
        // 链表为空，直接返回
        if (k == 0) {
            return null;
        }

        while (true) {
            if (k == 1) {
                return lists[0];
            } else if (k == 2) {
                return mergeTwoLists(lists[0], lists[k - 1]);
            }
            // 有奇数个链表,先将最后一个链表合并到第一个链表中,就可以看作有偶数个链表
            if (k % 2 == 1) {
                lists[0] = mergeTwoLists(lists[0], lists[k - 1]);
            }
            k = k / 2;
            // 将偶数(2k)个链表分别两两合并(第 i 个和第 i + k 个)成为前(k)个链表, 类似于归并排序——分治
            for (int i = 0; i < k; i++) {
                lists[i] = mergeTwoLists(lists[i], lists[i + k]);
            }
        }
    }

    // 顺序合并
    public ListNode mergeKLists2(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            // 链表为空,直接返回
            return null;
        } else if (len == 1) {
            // 只有一个链表,直接返回该链表
            return lists[0];
        }

        // 将其它链表依次插入到第一个链表中，类似于插入排序,性能不如前一个
        for (int i = 1; i < len; i++) {
            lists[0] = mergeTwoLists(lists[0], lists[i]);
        }

        return lists[0];
    }

    // 我的 mergeTwoLists
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) {
            list1 = list2;
            return list1;
        } else if (list2 == null) {
            return list1;
        }

        ListNode fromList;
        ListNode toList;
        // 将两个链表中的第一个节点值较小的那个链表认为被插入链表 toList
        if (list1.val <= list2.val) {
            fromList = list2;
            toList = list1;
        } else {
            fromList = list1;
            toList = list2;
        }
        // cur 初始化为被插入链表 toList 的第一个节点
        ListNode cur = toList;
        ListNode pre = new ListNode();
        // pre 指向被插入链表 toList 的第一个节点
        pre.next = cur;
        ListNode temp;
        // 将 fromList 链表中的元素插入到 toList 链表中
        while (fromList != null && cur != null) {
            // toList 链表中的当前节点的值小于等于当前 fromList 链表中的第一个节点的值时
            // 改变 toList 链表中的 pre 和 cur 指针
            if (cur.val <= fromList.val) {
                pre = cur;
                cur = cur.next;
            } else {
                // 此时,fromList 链表中的第一个节点的值小于 cur 节点处的值,大于等于 pre 节点处的值
                // 将 fromList 链表中的第一个节点 插入到 pre 和 cur 之间
                temp = fromList.next;
                pre.next = fromList;
                fromList.next = cur;
                pre = fromList;
                fromList = temp;
            }
        }
        if (cur == null) {
            pre.next = fromList;
        }
        return toList;
    }

    // 官方的 mergeTwoLists, 实现更简洁
    public ListNode mergeTwoLists1(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null) {
            return list1 != null ? list1 : list2;
        }

        ListNode head = new ListNode();
        ListNode tail = head;
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }

        tail.next = list1 == null ? list2 : list1;
        return head.next;
    }
}
```

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```java
class P35_Solution {
    public int searchInsert1(int[] nums, int target) {
        if (nums.length == 1) {
            if (nums[0] >= target) {
                return 0;
            } else {
                return 1;
            }
        }
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        if (mid == 0) {
            if (nums[0] > target) {
                return 0;
            } else if (nums[1] > target) {
                return 1;
            }
        } else if (mid == nums.length - 1) {
            if (nums[mid] < target) {
                return mid + 1;
            } else if (nums[mid - 1] < target) {
                return mid;
            }
        } else {
            if (nums[mid - 1] > target) {
                return mid - 1;
            } else if (nums[mid] > target) {
                return mid;
            } else if (nums[mid + 1] > target) {
                return mid + 1;
            }
        }
        return 0;
    }

    public int searchInsert(int[] nums, int target) {
        if (nums.length == 1) {
            if (nums[0] >= target) {
                return 0;
            } else {
                return 1;
            }
        }
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        // left > right 的情形, 数组中无目标值
        // 表示最后一步从 right = middle - 1 分支跳出, 也即 nums[middle] > target, 重新插入位置即为 mid
        if (right < mid) {
            return mid;
        }
        // 表示 nums[mid] < target, 重新插入位置为 mid + 1, 此时的 mid + 1 也等于 left
        return mid + 1;
        // 也等价于 return right == mid - 1 ? mid : mid + 1;
        // 也等价于 return left == mid + 1 ? left : mid;
    }
}
```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

##### 我的解法

###### 2021.11.04

> 2021.11.04 解法，首次完成

```java
class P42_Solution {
    public int trap(int[] height) {
        int len = height.length;
        if (len <= 2) {
            return 0;
        }
        // 左边柱子 和 右边柱子
        int left = 0, right;
        // 遍历到 left 时, left [左边]所有柱子的高度和
        int leftSum;
        // 遍历到 right 时, right [左边]所有柱子的高度和
        // 初始时 rightSum 为第一个柱子的高度
        int rightSum = height[0];
        // 水滴, 也就是面积
        int water = 0;

        // 1.左边部分
        // 每次循环都是找到以 left 为左边, right 为右边围成的坑, 直到最高柱子结束循环
        // 此处 while(true) 也对
        while (left < len) {

            leftSum = rightSum;
            right = left + 1;
            // 从 left 柱子的下一个柱子开始遍历
            while (right < len) {
                rightSum += height[right];
                // 在 left 柱子的右侧找到第一个比 left 柱子更高或者相等高度的柱子 right
                if (height[right] >= height[left]) {
                    // 计算 left 与 right 之间能装多少水滴
                    water += (right - left - 1) * height[left] - (rightSum - leftSum - height[right]);
                    break;
                }

                // 没有找到就找下一个柱子是否比 left 柱子高
                right++;
            }
            // 退出内层 while 时, 如果 right < len, 说明在 left 到 height.length - 1 之间, 找到了 right 柱子,
            // right 柱子比 left 柱子高或者高度相等, 直接进行下次外层 while 循环
            if (right < len) {
                // 下一次外层 while 循环是从 right 处找到以 right 为左边条边的坑
                left = right;
            } else if (right == len) {
                // 退出内层 while 时, 如果 right == len, 那么此时 left 柱子的高度值 height[left] 最大,
                // 当然在 left 到 height.length - 1 之间也就找不到 right 柱子满足要求了,
                // 于是直接退出外层 while 循环, 从数组末尾开始往前找
                break;
            }
        }
//        // 测试, 输出结束时的柱子总高度
//        System.out.println("1 ---- < " + leftSum);
//        System.out.println("1 ---- > " + rightSum);

        // 2.右边部分
        // 记录最高柱子的下标
        int max = left;
        right = len - 1;
        // 重设为 0;
        // 此处
        // 遍历到 left 时, left [右边]所有柱子的高度和
        // 初始时 leftSum 为最后一个柱子的高度
        leftSum = height[len - 1];
        // 遍历到 right 时, right [右边]所有柱子的高度和
        rightSum = 0;
        while (right >= max) {

            rightSum = leftSum;
            left = right - 1;

            while (left >= max) {
                leftSum += height[left];
                if (height[left] >= height[right]) {
                    water += (right - left - 1) * height[right] - (leftSum - rightSum - height[left]);
                    break;
                }

                left--;
            }
            if (left >= max) {
                right = left;
            }
            // 右边条边为最高柱子时结束外层 while 循环, 此时 water 值即为答案
            if (right == max) {
                break;
            }
        }
//        // 测试, 输出结束时的柱子总高度
//        System.out.println("2 ---- < " + leftSum);
//        System.out.println("2 ---- > " + rightSum);
        return water;
    }
}
```

```java
/**
 * 相比较于上一个, 此处将上述的步骤进行了封装, 并且小小改变了一下计算 water 的方式,
 * 由于只需要知道 leftSum 和 rightSum 之间的差值即可,
 * 故将 water 公式中的 leftSum 与 rightSum 之差更改为 midSum
 */
class P42_Solution1 {
    // 水滴, 也就是面积
    private int water;

    public int trap(int[] height) {
        if (height.length <= 2) {
            return 0;
        }
        // 初始化水滴数为 0
        water = 0;
        // 得到最高柱子的下标, 同时也会计算最高柱子前的所有水滴数
        int max = leftWater(height);
        // 得到最终的 water 数
        rightWater(height, max);
        return water;
    }

    /**
     * 1.左边部分
     * 从左往右遍历, 计算最高柱子之前的坑中的水滴数, 返回最高柱子的下标
     *
     * @param height 数组
     * @return left 结束时 left 为最高柱子的下标
     */
    public int leftWater(int[] height) {
        // 左边柱子 和 右边柱子
        int left = 0, right;
        // left 与 right 之间(包含height[right])的所有方格数(柱子高度)总和
        int midSum;

        int len = height.length;
        // 每次循环都是找到以 left 为左边, right 为右边围成的坑, 直到最高柱子结束循环
        while (left < len) {
            // 从 left 柱子的下一个(右边)柱子开始往右遍历
            right = left + 1;
            // 新一轮循环, 置为 0
            midSum = 0;
            while (right < len) {
                midSum += height[right];
                // 在 left 柱子的右侧找到第一个比 left 柱子更高或者相等高度的柱子 right
                if (height[right] >= height[left]) {
                    // 计算 left 与 right 之间能装多少水滴
                    // water += (right - left - 1) * height[left] - (midSum - height[right]);
                    water += calWater(left, right, height[left], height[right], midSum);
                    break;
                }

                // 没有找到就找下一个柱子是否比 left 柱子高
                right++;
            }
            // 退出内层 while 时, 如果 right < len, 说明在 left 到 height.length - 1 之间, 找到了 right 柱子,
            // right 柱子比 left 柱子高或者高度相等, 直接进行下次外层 while 循环
            if (right < len) {
                // 下一次外层 while 循环是从 right 处找到以 right 为左边条边的坑
                left = right;
            } else if (right == len) {
                // 退出内层 while 时, 如果 right == len, 那么此时 left 柱子的高度值 height[left] 最大,
                // 当然在 left 到 height.length - 1 之间也就找不到 right 柱子满足要求了,
                // 于是直接退出外层 while 循环, 从数组末尾开始往前找
                break;
            }
        }
        // 最高柱子下标
        return left;
    }

    /**
     * 2.右边部分
     * 从右往左遍历, 计算从末尾到最高柱子之间的坑中的水滴数
     *
     * @param height 数组
     * @param max    最高柱子下标
     */
    public void rightWater(int[] height, int max) {
        // 左边柱子 和 右边柱子
        int left, right = height.length - 1;
        // left 与 right 之间(包含height[left])的所有方格数(柱子高度)总和
        int midSum;
        // 倒序遍历
        while (right >= max) {
            // 从 right 柱子的下一个(左边)柱子开始往左遍历
            left = right - 1;
            // 新一轮循环, 置为 0
            midSum = 0;
            while (left >= max) {
                midSum += height[left];
                if (height[left] >= height[right]) {
                    // 计算 left 与 right 之间能装多少水滴
                    // water += (right - left - 1) * height[right] - (midSum - height[left]);
                    water += calWater(left, right, height[left], height[right], midSum);
                    break;
                }

                left--;
            }
            if (left >= max) {
                right = left;
            }
            // 右边条边为最高柱子时结束外层 while 循环, 此时 water 值即为答案
            if (right == max) {
                break;
            }
        }
    }

    /**
     * 计算 left 与 right 之间的水滴数
     *
     * @param left        左边柱子的下标
     * @param right       右边柱子的下标
     * @param leftHeight  左边柱子的高度
     * @param rightHeight 右边柱子的高度
     * @param midSum      左右两边柱子之间的所有柱子的高度和(包含 leftHeight 与 rightHeight 中的较大值)
     * @return waterSum   left 与 right 之间的水滴数
     */
    public int calWater(int left, int right, int leftHeight, int rightHeight, int midSum) {
        int waterSum = 0;
        if (leftHeight > rightHeight) {
            waterSum = (right - left - 1) * rightHeight - (midSum - leftHeight);
        } else {
            waterSum = (right - left - 1) * leftHeight - (midSum - rightHeight);
        }
        return waterSum;
    }
}
```

> 2021.11.04 凌晨
>
> 我还没看官方答案，等白天再来看是否比官方答案差很多。
>
> 我的思路是：因为接水滴，肯定要有一个坑，就是有left边和right边，那么从左往右遍历，找到比left边高或者高度相等的right 边，找到了的话就可以计算这个坑的水滴了，然后下一次遍历将这个right边作为left边，去找它的right边，如果没有找到，说明现在这个left边的高度是最高的，那么就从末尾倒序开始用同样的思维找，直到这个最高边为止。
>
> 不同之处在于，从前往后遍历时，left是固定的，找的是 right边；而倒序查找时，固定的是 right 边，找的是 left边。
>
> 想想复杂度
>
> 时间复杂度：当找到最高柱子时，遍历了`j + n - j` 次，j 为最高柱子的下标，然后反向又要遍历 `n - j` 次，可能不是很精确，这公式只有常数次误差 ，那么总共就是 `2n - j`，如果最高柱子在末尾，就为 n , 在数组头， 就为 2n，时间复杂度为 `O(n)`
>
> 空间复杂度：我就只创建了几个整形int变量，所以为`O(1)`
>
> 2021.11.04 下午
>
> 在看了之前其他人的代码后，发现我这思路其它人也有写过，哈哈，巧了。
>
> 至于官方参考答案，
>
> 方法一的动态规划是在有水滴的地方，一列一列加的，总共遍历了 3n 次
>
> 方法二的单调栈是在有水滴的地方，一行一行加的，次数应该是为 2n 次，不知道具体是否准确
>
> 方法三的双指针是在方法一的动态规划上将遍历次数减少，将方法一循环中的 `ans += Math.min(leftMax[i], rightMax[i]) - height[i];` 变成了 方法三中的 `if ... else ...`， 在动态规划的同时，计算雨水 ans，而方法一，是将动态规划做完后，再从头遍历一遍得到的雨水量 ans。 还有一点区别是，方法一的动态规划是用了两个数组保存了所有位置处的左边最高柱子和右边最高柱子的下标，空间复杂度为O(n)，而方法三由于边遍历边计算，不需要保留每个位置处的左边最高柱子和右边最高柱子的下标，采用了两个整型变量`leftMax`和`rightMax `代替了这两个数组，于是降低了空间复杂度。
>
> 方法一三都是一列一列计算的，而我的思路是一个水坑一个水坑计算的。

##### 暴力解法

##### 动态规划

##### 单调栈

##### 双指针

> 双指针好难理解啊

###### 官方的第一个参考解法

```Java
class Solution {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int ans = 0;
        int left_max = 0, right_max = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= left_max) {
                    left_max = height[left];
                } else {
                    ans += (left_max - height[left]);
                }
                ++left;
            } else {
                if (height[right] >= right_max) {
                    right_max = height[right];
                } else {
                    ans += (right_max - height[right]);
                }
                --right;
            }
        }
        return ans;
    }
}
```

###### 官方的第二个参考解法

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}
```

###### 我修改后

> 根据 官方的第二个参考解法 修改

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = height[left], rightMax = height[right];
        while (left < right) {
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left; 
                leftMax = Math.max(leftMax, height[left]);
            } else {
                ans += rightMax - height[right];
                --right;
                rightMax = Math.max(rightMax, height[right]);
            }
        }
        return ans;
    }
}
```

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

##### 贪心

###### 第一种实现：反向查找出发位置

```java
// 贪心: 方法一: 反向查找出发位置
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class P45_Solution1 {
    public int jump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return 0;
        }
        // 要走到的位置
        int position = nums.length - 1;
        // 跳跃次数
        int steps = 0;
        while (position > 0) {
            for (int i = 0; i < position; i++) {
                if (i + nums[i] >= position) {
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n^2)，其中 n 是数组长度。有两层嵌套循环，在最坏的情况下，例如数组中的所有元素都是 1，position 需要遍历数组中的每个位置，对于 position 的每个值都有一次循环。
>
>
> - 空间复杂度：O(1)
>

###### 第二种实现：正向查找可到达的最大位置

```java
// 贪心: 方法二：正向查找可到达的最大位置
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class P45_Solution {
    public int jump(int[] nums) {
        if (nums == null) {
            return 0;
        }

        int n = nums.length;

        if (n <= 1) {
            return 0;
        }
        // 每一段遍历要走到的最后位置, 遍历过程中比较确定下一步能够走到的最远位置
        // 上次跳跃可达范围右边界（下次的最右起跳点）
        int end = 0;
        // 目前能跳到的最远位置
        int maxPosition = 0;
        // 跳跃次数
        int steps = 0;

        for (int i = 0; i < n - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]);
            if (i == end) {
                // 目前能跳到的最远位置变成了下次起跳位置的右边界
                end = maxPosition;
                steps++;
            }
        }

        return steps;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 是数组长度
> - 空间复杂度：O(1)

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

##### 回溯

```java
class P46_Solution {
    int[] nums;
    int len;
    // 使用一个动态数组保存所有可能的全排列
    List<List<Integer>> ans;
    Deque<Integer> path;
    boolean[] used;

    public List<List<Integer>> permute(int[] nums) {
        this.nums = nums;
        this.len = nums.length;
        this.used = new boolean[len];
        this.path = new ArrayDeque<>(len);
        this.ans = new ArrayList<>();
        // 长度为 0, 返回 [[]]
        if (len == 0) {
            return ans;
        }
        // 只有一个数, 返回 [[nums[0]]]
        if (len == 1) {
            path.add(nums[0]);
            ans.add(new ArrayList<>(path));
            return ans;
        }

        dfs(0);
        return ans;
    }

    public void dfs(int depth) {
        // 遍历到的层数 等于 数字的个数时
        if (depth == len) {
            // 将当前路径添加进 ans 中
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                dfs(depth + 1);

                path.removeLast();
                used[i] = false;
            }
        }
    }
}
```

BFS 待定

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```java
class P47_Solution {
    int[] nums;
    int n;
    List<List<Integer>> ans;
    Deque<Integer> path;
    boolean[] visited;

    public List<List<Integer>> permuteUnique(int[] nums) {
        this.nums = nums;
        this.n = nums.length;
        this.ans = new ArrayList<>();
        this.path = new ArrayDeque<>(n);
        this.visited = new boolean[n];

        // 特殊情况处理 长度为 1 的序列直接返回
        if (n == 1) {
            path.add(nums[0]);
            ans.add(new ArrayList<>(path));
            return ans;
        }

        // 从第一个位置开始遍历
        backtrack(0);

        return ans;
    }

    public void backtrack(int depth) {
        if (depth == n) {
            ans.add(new ArrayList<>(path));
            return;
        }
        // 将确定该层的元素的值保存在 hashSet 中, 下一次遍历如果遇到该值, 则跳过, 剪枝所用
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 0; i < n; i++) {
            // 没有遍历过当前位置并且当前位置值在曾经也没有被遍历过
            if (!visited[i] && !hashSet.contains(nums[i])) {

                path.add(nums[i]);
                visited[i] = true;

                hashSet.add(nums[i]);
                // 遍历下一个位置
                backtrack(depth + 1);

                // 回溯 更新
                path.removeLast();
                visited[i] = false;
            }
        }
    }
}
```



#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

##### 我的解法

```java
class P50_Solution {
    // 我的 同官方解法 二
    public boolean canJump1(int[] nums) {
        // 特殊情况判断
        if (nums == null || nums.length == 0) {
            return false;
        }
        int n = nums.length;
        if (n == 1) {
            return true;
        }
        if (n == 2) {
            return nums[0] >= 1;
        }

        // 能够到达终点(最后一个下标)的最小索引
        // 从后往前遍历, 在已知位于 i 到 n - 1 之间的 minIndexOfCanJump 能够到达 n - 1 位置的前提下
        // 如果 i 能够到达 minIndexOfCanJump, 说明 i 也能到达 n - 1, 那么此时更新 minIndexOfCanJump 值为 i
        int minIndexOfCanJump = n - 1;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] >= minIndexOfCanJump - i) {
                minIndexOfCanJump = i;
            }
        }

        // 如果最终 minIndexOfCanJump 等于了 0, 说明从 0 可以跳到 n - 1
        return minIndexOfCanJump == 0;
    }

    // 我的优化 —— 反而效率降低了
    public boolean canJump(int[] nums) {
        // 特殊情况判断
        if (nums == null || nums.length == 0) {
            return false;
        }
        int n = nums.length;
        if (n == 1) {
            return true;
        }
        if (n == 2) {
            return nums[0] >= 1;
        }

        // 能够到达终点(最后一个下标)的最小索引
        // 从后往前遍历, 在已知位于 i 到 n - 1 之间的 minIndexOfCanJump 能够到达 n - 1 位置的前提下
        // 如果 i 能够到达 minIndexOfCanJump, 说明 i 也能到达 n - 1, 那么此时更新 minIndexOfCanJump 值为 i
        int minIndexOfCanJump = n - 1;
        int maxJump = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] >= minIndexOfCanJump - i) {
                minIndexOfCanJump = i;
            }
            // 以下几行可删
            int j = n - 2 - i;
            if (j > maxJump) {
                return false;
            }
            maxJump = Math.max(maxJump, j + nums[j]);
            if (maxJump >= minIndexOfCanJump) {
                return true;
            }
        }

        // 如果最终 minIndexOfCanJump 等于了 0, 说明从 0 可以跳到 n - 1
        return minIndexOfCanJump == 0;
    }
}
```

##### 贪心

> 这个想法说成贪心，感觉过于为了取名而取名了，就是个思路而已



#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

```java
public class P62_UniquePaths {
    public static void main(String[] args) {
        int m = 3;
        int n = 3;
        P62_Solution solution = new P62_Solution();
        System.out.println(solution.uniquePaths(m, n));
        System.out.println(solution.uniquePaths1(m, n));
        System.out.println(solution.uniquePaths2(m, n));
    }
}

class P62_Solution {
    // 简单的动态规划
    // 时间复杂度：O(mn)
    // 空间复杂度：O(mn)
    public int uniquePaths(int m, int n) {
        int[][] arr = new int[m + 1][n + 1];
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (i == m - 1 && j == n - 1) {
                    arr[m - 1][n - 1] = 1;
                } else {
                    arr[i][j] = arr[i + 1][j] + arr[i][j + 1];
                }
            }
        }
        return arr[0][0];
    }

    // 动态规划, 上一个方法的等价, 不用每次循环内判断
    // 此方法和代码实现与官方答案一极为类似, 可以等价
    // 时间复杂度：O(mn)
    // 空间复杂度：O(mn)
    public int uniquePaths1(int m, int n) {
        // 只有一行, 返回 1
        if (m == 1) {
            return 1;
        }
        int[][] arr = new int[m][n];
        // 最后一行置为 1
        for (int j = 0; j < n; j++) {
            arr[m - 1][j] = 1;
        }
        // 最后一列置为 1
        for (int i = 0; i < m; i++) {
            arr[i][n - 1] = 1;
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                arr[i][j] = arr[i + 1][j] + arr[i][j + 1];
            }
        }
        return arr[0][0];
    }

    // 优化上一个方法的空间复杂度, 只用一个一维数组来记录路径长度,
    // 并且由于交换m,n的值对答案无影响, 因此该数组长度最好为 min(m,n)
    // 时间复杂度：O(mn)
    // 空间复杂度：O(min(m,n))
    public int uniquePaths2(int m, int n) {
        // 只有一行, 返回 1
        if (m == 1) {
            return 1;
        }
        // m 为较大值(代表行), n 为较小值(代表列)
        if (m < n) {
            int temp = m;
            m = n;
            n = temp;
        }
        int[] arr = new int[n];
        arr[n - 1] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                arr[j] += +arr[j + 1];
            }
        }
        return arr[0];
    }
}
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```java
class P63_Solution {
    // 时间复杂度: O(nm), 其中 m 为网格的行数, n 为网格的列数, 只需要遍历所有网格一次即可
    // 空间复杂度: O(m)O(m), 利用滚动数组优化, 可以只用 O(n) 大小的空间来记录当前行到右下角的 path 值
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 行
        int m = obstacleGrid.length;
        // 列
        int n = obstacleGrid[0].length;
        // 右下角为障碍物, 返回 0
        if (obstacleGrid[m - 1][n - 1] == 1) {
            return 0;
        }
        // 只有一行且无障碍物, 返回 1
        if (m == 1) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[0][j] == 1) {
                    return 0;
                }
            }
            return 1;
        }
        // 只有一列且无障碍物, 返回 1
        if (n == 1) {
            for (int i = 0; i < m; i++) {
                if (obstacleGrid[i][0] == 1) {
                    return 0;
                }
            }
            return 1;
        }

        // 「滚动数组思想」把空间复杂度优化成 O(n)
        int[] dp = new int[n];
        dp[n - 1] = 1;

        for (int i = m - 1; i >= 0; i--) {
            // 等价于 dp[n - 1] = (obstacleGrid[i][n - 1] != 1) ? dp[n - 1] : 0;
            if (obstacleGrid[i][n - 1] == 1) {
                dp[n - 1] = 0;
            }
            for (int j = n - 2; j >= 0; j--) {
                // 等价于 dp[j] = (obstacleGrid[i][j] != 1) ? dp[j] + dp[j + 1] : 0;
                // 如果该格子是障碍物, 则不能从该格子走到右下角, dp[j] 为 0
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else {
                    // 如果不是障碍物, 则从该格子走到右下角的路径数为
                    // 下边一个格子走到右下角的路径数 (dp[j]) 与右边一个格子走到右下角的路径数 (dp[j + 1]) 的和
                    dp[j] += dp[j + 1];
                }
            }
        }
        return dp[0];
//        // 也可以为
//        // 「滚动数组思想」把空间复杂度优化成 O(n)
//        int[] dp = new int[n + 1];
//        dp[n - 1] = 1;
//
//        for (int i = m - 1; i >= 0; i--) {
//            for (int j = n - 1; j >= 0; j--) {
//                // 等价于 dp[j] = (obstacleGrid[i][j] != 1) ? dp[j] + dp[j + 1] : 0;
//                if (obstacleGrid[i][j] == 1) {
//                    dp[j] = 0;
//                    continue;
//                }
//                dp[j] += dp[j + 1];
//            }
//        }
//        return dp[0];
    }
}
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

##### 递归

##### 记忆化递归

##### 动态规划

2021.11.05

> 之前做过斐波那契数列，这题和它一模一样

```java
// 最初我还以为这个状态转移方程不对
class P70_Solution {
    // 动态规划
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 2;
        }
        int[] dp = new int[]{1, 2, 0};
        for (int i = 3; i <= n; i++) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
}
```

##### 矩阵快速幂

##### 通项公式

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

##### 动态规划

```java
class P72_Solution {
    // 二维动态规划
    // 时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。
    // 空间复杂度 ：O(mn)，我们需要大小为 O(mn) 的 DP 数组来记录状态值。
    public int minDistance1(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length();
        int n = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        int[][] dp = new int[m + 1][n + 1];

        // 边界状态初始化
        // 空串转换为字符串的转换次数为字符串的长度
        // 初始化首列
        for (int i = 0; i < m + 1; i++) {
            dp[i][0] = i;
        }
        // 字符串转换为空串的转换次数为字符串的长度
        // 初始化首行
        for (int j = 0; j < n + 1; j++) {
            dp[0][j] = j;
        }
        // 计算所有 DP 值
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 三种情况的最小值
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1]);
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }

    // 一维动态规划(滚动数组思想)
    // 时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。
    // 空间复杂度 ：O(n)，我们需要大小为 O(n) 的 DP 数组来记录状态值。
    public int minDistance2(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length();
        int n = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        int[] dp = new int[n + 1];

        // 边界状态初始化, 初始化 dp 数组
        // 字符串转换为空串的转换次数为字符串的长度
        for (int j = 0; j < n + 1; j++) {
            dp[j] = j;
        }
        // 计算所有 DP 值
        for (int i = 1; i < m + 1; i++) {
            // 初始化保存 dp[0] 处的值为 pre
            int pre = i;
            for (int j = 1; j < n + 1; j++) {
                // pre 保存的是现在第 i 次循环中 dp[j - 1] 处的值
                // 而此时 dp[j - 1] 及其以后的值都是上次(第 i - 1 次)循环中的值
                int temp = pre;
                // 三种情况的最小值
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1]);
                } else {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1] + 1);
                }
                // 此时的 pre 保存的就是当前次循环中 dp[j] 处的值, 但是现在还不能给 dp[j] 赋值
                // 因为下一次 j + 1 的循环还需要用到上次(第 i - 1 次)循环中 dp[j] 处的值
                // 但是在此处就要更新 dp[j - 1] 处的值了, 因为后续的循环用不到上次(第 i - 1 次)循环中 dp[j - 1] 处的值了
                dp[j - 1] = temp;
            }
            // 循环结束后, dp 的最后一个位置处的次数还没更新, 在此处更新
            dp[n] = pre;
        }
        return dp[n];
    }

    // 一维动态规划(滚动数组思想)
    // 时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。
    // 空间复杂度 ：O(min(m,n))，我们需要大小为 O(min(m,n)) 的 DP 数组来记录状态值。
    public int minDistance(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length();
        int n = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        if (m >= n) {
            return getMinDistance(word1, word2);
        } else {
            return getMinDistance(word2, word1);
        }
    }

    public int getMinDistance(String longWord, String shortWord) {
        if (shortWord == null || longWord == null) {
            return 0;
        }
        int m = longWord.length();
        int n = shortWord.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        int[] dp = new int[n + 1];

        // 边界状态初始化, 初始化 dp 数组
        // 字符串转换为空串的转换次数为字符串的长度
        for (int j = 0; j < n + 1; j++) {
            dp[j] = j;
        }
        // 计算所有 DP 值
        for (int i = 1; i < m + 1; i++) {
            // 初始化保存 dp[0] 处的值为 pre
            int pre = i;
            for (int j = 1; j < n + 1; j++) {
                // pre 保存的是现在第 i 次循环中 dp[j - 1] 处的值
                // 而此时 dp[j - 1] 及其以后的值都是上次(第 i - 1 次)循环中的值
                int temp = pre;
                // 三种情况的最小值
                if (longWord.charAt(i - 1) == shortWord.charAt(j - 1)) {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1]);
                } else {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1] + 1);
                }
                // 此时的 pre 保存的就是当前次循环中 dp[j] 处的值, 但是现在还不能给 dp[j] 赋值
                // 因为下一次 j + 1 的循环还需要用到上次(第 i - 1 次)循环中 dp[j] 处的值
                // 但是在此处就要更新 dp[j - 1] 处的值了, 因为后续的循环用不到上次(第 i - 1 次)循环中 dp[j - 1] 处的值了
                dp[j - 1] = temp;
            }
            // 循环结束后, dp 的最后一个位置处的次数还没更新, 在此处更新
            dp[n] = pre;
        }
        return dp[n];
    }
}
```



#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

##### 回溯

> 在官方代码基础上更改的，并没本质提升，这题我自己挺难做的

```java
// 回溯
class P93_Solution {
    static final int SEG_COUNT = 4;
    int len;
    int[] segments = new int[SEG_COUNT];
    List<String> ans;
    // List<String> ans = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        ans = new ArrayList<>();
        if (s == null) {
            return ans;
        }
        this.len = s.length();
        if (len < 4 || len > 12) {
            return ans;
        }

        if (len == 4) {
            StringBuilder ipAddr = new StringBuilder();
            for (int i = 0; i < 4; i++) {
                ipAddr.append(s.charAt(i));
                if (i <= 2) {
                    ipAddr.append('.');
                }
            }
            ans.add(ipAddr.toString());
            return ans;
        }

        dfs(s, 0, 0);
        return ans;
    }

    public void dfs(String s, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) {
            if (segStart == len) {
                StringBuilder ipAddr = new StringBuilder();
                for (int i = 0; i < SEG_COUNT; i++) {
                    ipAddr.append(segments[i]);
                    if (i <= 2) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串, 那么提前回溯
        if (segStart == len) {
            return;
        }

        // 删除此 if 不影响结果
        if (len - segStart > (SEG_COUNT - segId) * 3) {
            return;
        } else if (len - segStart == (SEG_COUNT - segId) * 3) {
            for (int i = 0; i < SEG_COUNT - segId; i++) {
                int temp = s.charAt(segStart + i * 3) - '0';
                if (temp == 0 || temp > 2) {
                    return;
                }
                if (temp == 2) {
                    int temp1 = s.charAt(segStart + i * 3 + 1) - '0';
                    if (temp1 >= 6) {
                        return;
                    }
                    if (temp1 == 5 && (s.charAt(segStart + i * 3 + 2) - '0') >= 6) {
                        return;
                    }
                }
            }
            StringBuilder ipAddr = new StringBuilder();
            for (int i = 0; i < SEG_COUNT; i++) {
                if (i < segId) {
                    ipAddr.append(segments[i]);
                } else {
                    ipAddr.append(s.substring(segStart, segStart + 3));
                }
                if (i <= 2) {
                    ipAddr.append('.');
                }
            }
            ans.add(ipAddr.toString());
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int i = segStart; i < len; i++) {
            addr = addr * 10 + (s.charAt(i) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, i + 1);
            } else {
                break;
            }
        }
    }
}
```



#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

class P104_Solution {
    // DFS
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else if (root.left == null && root.right == null) {
            return 1;
        }
        int leftDepth = 0;
        int rightDepth = 0;
        // 左子树的深度
        if (root.left != null) {
            leftDepth = maxDepth(root.left);
        }
        // 右子树的深度
        if (root.right != null) {
            rightDepth = maxDepth(root.right);
        }
        return Math.max(leftDepth, rightDepth) + 1;
    }

    // DFS 对上方法的逻辑简化
    public int maxDepth1(TreeNode root) {
        if (root == null) {
            return 0;
        } else if (root.left == null && root.right == null) {
            return 1;
        }
        return Math.max(maxDepth1(root.left), maxDepth1(root.right)) + 1;
    }
}
```



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 必须放在这里，后续两方法中都要使用到这个属性
    // 使用k,v记录中序遍历数组中各节点值与其索引值,通过前序遍历中的第一个值就为头节点,然后在该map中找到对应中序遍历数组中的该值的下标
    private Map<Integer, Integer> indexMap = null;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;

        indexMap = new HashMap<Integer, Integer>();

        for(int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int pre_left, int pre_right, int in_left, int in_right) {
        // 一个左右子树对应的那部分数组长度大于等于1时才有节点,只有一个节点的情况是pre_left等于pre_right,那么没有节点的情况是pre_left>pre_right
        if (pre_left > pre_right) {
            return null;
        }
        // 前序遍历中第一个结点为根节点,保存其值
        int rootValPre = preorder[pre_left];
        // 中序遍历得到根节点所在位置索引值
        int rootIndexIn = indexMap.get(rootValPre);
        // 构造根节点
        TreeNode rootNode = new TreeNode(rootValPre);
        // 统计左子树中有多少个节点
        int left_size = rootIndexIn - in_left;
        // 递归遍历左子树,得到左节点
        rootNode.left = myBuildTree(preorder, inorder, pre_left + 1, pre_left + left_size, in_left, rootIndexIn - 1);
        // 递归遍历右子树,得到右节点
        rootNode.right = myBuildTree(preorder, inorder, pre_left + left_size + 1, pre_right, rootIndexIn + 1, in_right);
        return rootNode;
    }
}
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private Map<Integer, Integer> indexMap = null;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;

        indexMap = new HashMap<Integer,Integer>();

        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        return myBuildTree(inorder, postorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] inorder, int[] postorder, int in_left, int in_right, int post_left, int post_right) {

        if (post_left > post_right) {
            return null;
        }
        // 获取后序遍历中最后一位的值,即为根节点
        int rootVal = postorder[post_right];
        // 在中序遍历MAP中找到相应rootVal所在中序遍历数组中的索引位置
        int rootIndexIn = indexMap.get(rootVal);
        // 构造根节点
        TreeNode rootNode = new TreeNode(rootVal);
        // 计算左子树长度
        int left_size = rootIndexIn - in_left;
        // 递归遍历左子树,得到左节点
        rootNode.left = myBuildTree(inorder, postorder, in_left, rootIndexIn - 1, post_left, post_left + left_size - 1);
        // 递归遍历右子树,得到右节点
        rootNode.right = myBuildTree(inorder, postorder, rootIndexIn + 1, in_right, post_left + left_size, post_right - 1);
        return rootNode;
    }
}
```



#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

已定义节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
```

##### 2021.04.26

我的做法（第一种）

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return Order(root, targetSum);
    }
    
    public boolean Order(TreeNode node, int pathSum) {
        if (node == null) {
            return false;
        }
        
        pathSum = pathSum - node.val;
        boolean leftRet = false;
        boolean rightRet = false;
        
        if (node.left == null && node.right == null) {
            if(pathSum == 0) {
                return true;
            }
        }
        if (node.left != null) {
            leftRet = Order(node.left, pathSum);
        }
        if (node.right != null) {
            rightRet = Order(node.right, pathSum);
        }
        
        return leftRet || rightRet;
    }
}
```

我的方法（第二种）较第一种小改，无本质变化

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return Order(root, targetSum);
    }
    
    public boolean Order(TreeNode node, int pathSum) {
        if (node == null) {
            return false;
        }
        
        pathSum = pathSum - node.val;
        
        if (node.left == null && node.right == null) {
            if(pathSum == 0) {
                return true;
            }
        }
        
        return Order(node.left, pathSum) || Order(node.right, pathSum);
    }
}
```

##### 2021.10.22——第二次做——独立完成

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

class P112_Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }
        targetSum = targetSum - root.val;
        if (root.left != null) {
            if (hasPathSum(root.left, targetSum)) {
                return true;
            }
        }
        if (root.right != null) {
            return hasPathSum(root.right, targetSum);
        }
        return false;
    }

    // 对上一个方法的简化, 发现和官方解法一样了
    public boolean hasPathSum1(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```



官方做法（递归）

思路及算法

观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。
>
> 空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(log N)。

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

**给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。**

**叶子节点 是指没有子节点的节点。**

前言
注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。

方法一：深度优先搜索
思路及算法

我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

```Java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    Deque<Integer> path = new LinkedList<Integer>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }

    public void dfs(TreeNode root, int sum) {
        if (root == null) {
            return;
        }
        path.offerLast(root.val);
        sum -= root.val;
        if (root.left == null && root.right == null && sum == 0) {
            ret.add(new LinkedList<Integer>(path));
        }
        dfs(root.left, sum);
        dfs(root.right, sum);
        path.pollLast();
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为 O(N)，并且每一条路径的节点个数也为 O(N)，因此要将这些路径全部添加进答案中，时间复杂度为 O(N^2)。
>
> 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。

方法二：广度优先搜索
思路及算法

我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。

```java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    Map<TreeNode, TreeNode> map = new HashMap<TreeNode, TreeNode>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queueNode = new LinkedList<TreeNode>();
        Queue<Integer> queueSum = new LinkedList<Integer>();
        queueNode.offer(root);
        queueSum.offer(0);

        while (!queueNode.isEmpty()) {
            TreeNode node = queueNode.poll();
            int rec = queueSum.poll() + node.val;

            if (node.left == null && node.right == null) {
                if (rec == targetSum) {
                    getPath(node);
                }
            } else {
                if (node.left != null) {
                    map.put(node.left, node);
                    queueNode.offer(node.left);
                    queueSum.offer(rec);
                }
                if (node.right != null) {
                    map.put(node.right, node);
                    queueNode.offer(node.right);
                    queueSum.offer(rec);
                }
            }
        }

        return ret;
    }

    public void getPath(TreeNode node) {
        List<Integer> temp = new LinkedList<Integer>();
        while (node != null) {
            temp.add(node.val);
            node = map.get(node);
        }
        Collections.reverse(temp);
        ret.add(new LinkedList<Integer>(temp));
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，其中 N 是树的节点数。分析思路与方法一相同。
>
> 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数。

##### 2021.10.23

第一次做，没做出来，这是答案DFS的解法

```java
class P113_Solution {
    List<List<Integer>> ans = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return ans;
    }

    public void dfs(TreeNode root, int targetSum) {
        if (root == null) {
            return;
        }
        path.offerLast(root.val);
        targetSum = targetSum - root.val;
        if (root.left == null && root.right == null && targetSum == 0) {
            ans.add(new LinkedList<Integer>(path));
        }
        dfs(root.left, targetSum);
        dfs(root.right, targetSum);
        path.pollLast();
    }
}
```



#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

###### 方法一：**线性表**

因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。

因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        List<ListNode> list = new ArrayList<ListNode>();
        ListNode node = head;
        while (node != null) {
            list.add(node);
            node = node.next;
        }
        int i = 0, j = list.size() - 1;
        while (i < j) {
            list.get(i).next = list.get(j);
            i++;
            if (i == j) {
                break;
            }
            list.get(j).next = list.get(i);
            j--;
        }
        list.get(i).next = null;
    }
}
```

> **复杂度分析**
>
> 时间复杂度：O(N)*O*(*N*)，其中 N*N* 是链表中的节点数。
>
> 空间复杂度：O(N)*O*(*N*)，其中 N*N* 是链表中的节点数。主要为线性表的开销。

###### 方法二：寻找链表中点 + 链表逆序 + 合并链表

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1.找到原链表的中点（参考「876. 链表的中间结点」）。

​	我们可以使用快慢指针来 O(N) 地找到链表的中间节点。
2.将原链表的右半端反转（参考「206. 反转链表」）。

​	我们可以使用迭代法实现链表的反转。
3.将原链表的两端合并。

​	因为两链表长度相差不超过1，因此直接合并即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    public void mergeList(ListNode l1, ListNode l2) {
        ListNode l1_tmp;
        ListNode l2_tmp;
        while (l1 != null && l2 != null) {
            l1_tmp = l1.next;
            l2_tmp = l2.next;

            l1.next = l2;
            l1 = l1_tmp;

            l2.next = l1;
            l2 = l2_tmp;
        }
    }
}
```

> **复杂度分析**
>
> 时间复杂度：O(N)，其中 N是链表中的节点数。
>
> 空间复杂度：O(1)。

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

##### 暴力解法

> 见官网

##### 动态规划

```java
// 动态规划
class P121_Solution {
    // 动态规划
    // 时间复杂度 O(n)
    // 空间复杂度 O(n)
    // 无注释, 最初版本, dp 定义为 int[] dp = new int[n + 1];
    public int maxProfit0(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }

        int minPriceIndex = 0;
        int[] dp = new int[n + 1];

        for (int i = 1; i < n + 1; i++) {
            if (prices[i - 1] > prices[minPriceIndex]) {
                dp[i] = Math.max(prices[i - 1] - prices[minPriceIndex], dp[i - 1]);
            } else {
                dp[i] = dp[i - 1];
                minPriceIndex = i - 1;
            }
        }
        return dp[n];
    }

    // 动态规划
    // 时间复杂度 O(n)
    // 空间复杂度 O(n)
    // 有注释, 第二个版本, dp 定义为 int[] dp = new int[n];
    public int maxProfit1(int[] prices) {
        // 特殊情况处理
        if (prices == null) {
            return 0;
        }
        // 天数
        int n = prices.length;
        // 特殊情况处理
        if (n == 0 || n == 1) {
            return 0;
        }

        int[] dp = new int[n];

        // 价格最小的天数索引
        int minPriceIndex = 0;
        for (int i = 1; i < n; i++) {
            // 如果第 i 天比之前的所有天中的最低价格高
            // 那么dp[i]等于, 在今天选择卖出股票或者不卖出股票就可能取得到这前 i 天能卖出的最大值
            // 卖出股票——利润为 prices[i] - prices[minPriceIndex]
            // 不卖股票——利润为前一天的 dp 值 dp[i-1]
            if (prices[i] > prices[minPriceIndex]) {
                dp[i] = Math.max(prices[i] - prices[minPriceIndex], dp[i - 1]);
            } else {
                // 如果今天的股票价格是历史最低的话, 可以认为如果在今天买入, 在日后某天卖出的话, 也许会得到更高的利润
                // 而由于今天的股票价格是历史最低, 那么截至到今天, 今天能赚到的最大利润为前 i 天能卖出的最大值, 也就是 dp[i-1]
                dp[i] = dp[i - 1];
                // 更新最小价格的索引位置
                minPriceIndex = i;
            }
        }
        return dp[n - 1];
    }

    // 动态规划(滚动数组思想)
    // 时间复杂度 O(n)
    // 空间复杂度 O(1)
    // 优化版本, dp 定义为 int[] dp = new int[2];
    public int maxProfit(int[] prices) {
        // 特殊情况处理
        if (prices == null) {
            return 0;
        }
        // 天数
        int n = prices.length;
        // 特殊情况处理
        if (n == 0 || n == 1) {
            return 0;
        }

        // 最大利润
        int dp = 0;

        // 价格最小的天数索引, 可把这个最小价格索引改为直接保存最小价格值 minPrice
        int minPriceIndex = 0;
        for (int i = 1; i < n; i++) {
            // 如果第 i 天比之前的所有天中的最低价格高
            // 那么dp[i]等于, 在今天选择卖出股票或者不卖出股票就可能取得到这前 i 天能卖出的最大值
            // 卖出股票——利润为 prices[i] - prices[minPriceIndex]
            // 不卖股票——利润为前一天的 dp 值, 就为 dp 本身
            if (prices[i] > prices[minPriceIndex]) {
                dp = Math.max(prices[i] - prices[minPriceIndex], dp);
            } else {
                // 如果今天的股票价格是历史最低的话, 可以认为如果在今天买入, 在日后某天卖出的话, 也许会得到更高的利润
                // 而由于今天的股票价格是历史最低, 那么截至到今天, 今天能赚到的最大利润为前 i 天能卖出的最大值, 也就是 dp 值, 不需要更新了
                // 更新最小价格的索引位置
                minPriceIndex = i;
            }
        }
        return dp;
    }
}
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

##### 动态规划

```java
class P122_Solution {
    // 动态规划
    // 时间复杂度 O(n)
    // 空间复杂度 O(n)
    public int maxProfit1(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }
        int[] dp = new int[n];

        /* 第一种方式, 每天与前几天中的最低历史价格相关, 代码实现上已经有些不像动态规划了 */
//        int minPriceIndex = 0;
//        for (int i = 1; i < n; i++) {
//            if (prices[i] > prices[i - 1]) {
//                dp[i] = dp[minPriceIndex] + (prices[i] - prices[minPriceIndex]);
//            } else {
//                dp[i] = dp[i - 1];
//                minPriceIndex = i;
//            }
//        }
//        return dp[n - 1];

        /* 第二种方式, 每天与前一天的价格相关, 而不是与前几天中的最低历史价格相关 */
        for (int i = 1; i < n; i++) {
            // 如果今天比前一天的价格高, 在答案结果上就等于
            // 昨天以前(包括昨天)总共获得的利润 dp[i - 1] + 昨天买的、今天卖了的差价(prices[i] - prices[i - 1])
            if (prices[i] > prices[i - 1]) {
                dp[i] = dp[i - 1] + (prices[i] - prices[i - 1]);
            } else {
                // 如果今天比前一天低, 那么今天肯定是不卖的, 有可能买,
                // 但是具体买不买要根据后一天的价格是否比今天高来决定,
                // 如果明天的价格比今天的高, 那么当然是今天要买, 明天再卖就能获利了
                // 如果明天的价格比今天的低, 那么今天就不要买, 应该在明天再买
                // 因此, 今天不卖的话, 就意味着今天不获利, 到今天为止转的钱 dp[i] 之就等于昨天赚的钱 dp[i-1]
                dp[i] = dp[i - 1];
            }
        }
        return dp[n - 1];
    }

    // 动态规划(优化 滚动数组思想)
    // 时间复杂度 O(n)
    // 空间复杂度 O(1)
    public int maxProfit(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }

        // 由上一个动态规划实现, 我们知道由于截止到今天的获利 dp[i] 只和截止到前一天的获利 dp [i-1] 有关
        // 于是 dp 数组可以进行压缩滚动, 不必用一个 O(n) 长度的数组记录截至到每天的获利情况, 只需要一个变量即可
        // int[] dp = new int[n]; 改为
        int dp = 0;

        /* 第二种方式, 每天与前一天的价格相关, 而不是与前几天中的最低历史价格相关 */
        for (int i = 1; i < n; i++) {
            // 如果今天比前一天的价格高, 在答案结果上就等于
            // 昨天以前(包括昨天)总共获得的利润 dp[i - 1] + 昨天买的、今天卖了的差价(prices[i] - prices[i - 1])
            if (prices[i] > prices[i - 1]) {
                // dp[i] = dp[i - 1] + (prices[i] - prices[i - 1]); 改为
                dp += prices[i] - prices[i - 1];
            }/* else {
                // 如果今天比前一天低, 那么今天肯定是不卖的, 有可能买,
                // 但是具体买不买要根据后一天的价格是否比今天高来决定,
                // 如果明天的价格比今天的高, 那么当然是今天要买, 明天再卖就能获利了
                // 如果明天的价格比今天的低, 那么今天就不要买, 应该在明天再买
                // 因此, 今天不卖的话, 就意味着今天不获利, 到今天为止转的钱 dp[i] 之就等于昨天赚的钱 dp[i-1]
                // dp[i] = dp[i - 1];
            }*/
        }

        // return dp[n - 1]; 改为
        return dp;
    }
    // 做完看了答案后才知道, 原来官方将我的这种动态规划做法, 认为是贪心算法
    // 并且解释中: 贪心算法只能用于计算最大利润, 计算的过程并不是实际的交易过程。
    // 这个和我的想法一致
}
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

##### 动态规划

我的代码，效率很低，不过做出来就不错了哈哈，更多注释见源文件

```java
// 动态规划
class P123_Solution {
    public int maxProfit(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }

        // dp[i][0] 买卖一次的最大利润
        // dp[i][1] 买卖两次的最大利润
        int[][] dp = new int[n][2];
        int index = 0;
        int minPriceIndex = 0;
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 1; i < n; i++) {
            if (prices[i] > prices[i - 1]) {
                dp[i][0] = Math.max(prices[i] - prices[minPriceIndex], dp[i - 1][0]);

                dp[i][1] = Math.max(prices[i] - prices[index] + dp[index][0], dp[i - 1][1]);
                for (Integer ind : hashSet) {
                    dp[i][1] = Math.max(prices[i] - prices[ind] + dp[ind][0], dp[i][1]);
                }
            } else {
                // prices[i] <= prices[i - 1]
                dp[i][0] = dp[i - 1][0];
                dp[i][1] = dp[i - 1][1];

                // 此处 prices[minPriceIndex] <= prices[index] 是恒定的, minPriceIndex 与 index 也可能相等
                // 如果 prices[i] == prices[index], 只需执行 index = i;
                if (prices[i] > prices[index]) {
                    // 将 index 加入 hashSet
                    hashSet.add(index);
                } else if (prices[i] < prices[index]) {
                    if (prices[i] <= prices[minPriceIndex]) {
                        // prices[i] 为最低价格, 更新最低价格下标, set 清空, minPriceIndex 入 set
                        // 最低价格下标
                        minPriceIndex = i;
                        // 清空 hashSet
                        hashSet.clear();
                        // 将 minPriceIndex 加入 hashSet
                        hashSet.add(minPriceIndex);
                    } else {
                        // prices[index] > prices[i] > prices[minPriceIndex]
                        // 需要将 hashSet 中比 prices[i] 大的 prices[ind] 的 ind 移除

                        // 这种方式在 LeetCode 上会报如下错误
                        // java.util.ConcurrentModificationException
                        //  at line 1495, java.base/java.util.HashMap$HashIterator.nextNode
                        //  at line 1518, java.base/java.util.HashMap$KeyIterator.next
//                        for (Integer ind : hashSet) {
//                            if (prices[ind] >= prices[i]) {
//                                hashSet.remove(ind);
//                            }
//                        }
                        // 改为迭代器就可以了, 这是一个新知识点啊哈哈
                        Iterator<Integer> iterator = hashSet.iterator();
                        while (iterator.hasNext()) {
                            if (prices[iterator.next()] >= prices[i]) {
                                iterator.remove();
                            }
                        }
                    }
                }
                index = i;
            }
        }
        return dp[n - 1][1];
    }
}
```



#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class P124_Solution {
    // 此处初始化为小于 -1000 的值
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        /*
        // 题目保证至少一个结点, 即 root != null
        if (root == null) {
            return 0;
        }*/
        postorder(root);
        return maxSum;
    }

    // 后序遍历
    public int postorder1(TreeNode node) {
        int leftSum;
        int rightSum;
        int maxLeftAndRight;
        int nodePathSum;

        if (node.left == null && node.right == null) {
            nodePathSum = node.val;
            maxSum = Math.max(nodePathSum, maxSum);
        } else if (node.left != null && node.right != null) {
            leftSum = postorder(node.left);
            rightSum = postorder(node.right);
            maxLeftAndRight = Math.max(leftSum, rightSum);
            nodePathSum = Math.max(maxLeftAndRight + node.val, node.val);
            maxSum = Math.max(Math.max(nodePathSum, leftSum + node.val + rightSum), maxSum);
        } else if (node.left != null) {
            // 此处 node.left != null && node.right == null
            leftSum = postorder(node.left);
            nodePathSum = Math.max(leftSum + node.val, node.val);
            maxSum = Math.max(nodePathSum, maxSum);
        } else {
            // 此处 node.left == null && node.right != null
            rightSum = postorder(node.right);
            nodePathSum = Math.max(rightSum + node.val, node.val);
            maxSum = Math.max(nodePathSum, maxSum);
        }

        return nodePathSum;
    }

    // 后续遍历
    // 对上一个种代码实现的优化, 解题思想不变
    public int postorder(TreeNode node) {
        int leftSum = 0;
        int rightSum = 0;
        // 返回值, 通过该 node 结点到子结点的路径中的最大路径和
        int nodePathSum;

        if (node.left == null && node.right == null) {
            // node 为叶子结点, 无左右子结点
            nodePathSum = node.val;
            maxSum = Math.max(nodePathSum, maxSum);
        } else {
            if (node.left != null) {
                leftSum = postorder(node.left);
            }
            if (node.right != null) {
                rightSum = postorder(node.right);
            }
            // 此处 nodePathSum 为 以下三种情况中的较大值
            // leftSum + node.val、rightSum + node.val 和 node.val

            // 以下两种方式求 nodePathSum
            // 1.
            // 左、右较大值
            // int maxLeftAndRight = Math.max(leftSum, rightSum);
            // nodePathSum = maxLeftAndRight >= 0 ? maxLeftAndRight + node.val : node.val;
            // 2.
            nodePathSum = Math.max(Math.max(leftSum, rightSum) + node.val, node.val);

            // 此处 maxSum 为 以下三种情况中的较大值
            // nodePathSum、leftSum + node.val + rightSum 和 历史 maxSum 值
            // 总计下来其实 maxSum 为 历史 maxSum 值 与
            // [leftSum + node.val、 rightSum + node.val、 node.val、 leftSum + node.val + rightSum]
            // 这四个值中的最大值
            maxSum = Math.max(Math.max(nodePathSum, leftSum + node.val + rightSum), maxSum);
        }
        return nodePathSum;
    }
}
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

##### 递归

```java
// 递归实现
class P145_Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {
        // 特殊情况提前处理
        // 可删
        if (root == null) {
            return ans;
        }
        postorder(root);
        return ans;
    }

    public void postorder(TreeNode node) {
        if (node == null) {
            return;
        }
        // 遍历左结点
        postorder(node.left);
        // 遍历右节点
        postorder(node.right);
        // 添加该结点入链表
        ans.add(node.val);
    }
}
```

##### 迭代

```java
// 迭代
class P145_Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> ans = new LinkedList<>();
        // 特殊情况提前处理
        if (root == null) {
            return ans;
        }

        Deque<TreeNode> stack = new LinkedList<>();

        while (root != null || !stack.isEmpty()) {
            // 一直遍历右结点
            if (root != null) {
                // 每遇到一个结点, 就把它加入结果集, 并把该节点保存到中间结果中
                // 每次前序遍历时, 都将结点写入结果链表头, 而不是尾
                ans.addFirst(root.val);
                stack.push(root);
                // 每次先遍历右结点, 走到空, 再遍历左结点
                root = root.right;
            } else {
                // 右子树走到空, 就从获取已经遍历过右子树的中间结果, 将它出栈, 并遍历它的左子树
                root = stack.poll();
                root = root.left;
            }
        }
        return ans;
    }
}
```



#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

第一次

```java
// 使用 哈希表 + 双向链表
// 时间复杂度：对于 put 和 get 都是 O(1)O(1)。
// 空间复杂度：O(\text{capacity})O(capacity)，因为哈希表和双向链表最多存储 \text{capacity} + 1capacity+1 个元素。
class LRUCache {

    static class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;

        public DLinkedNode() {
        }

        public DLinkedNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final Map<Integer, DLinkedNode> cache = new HashMap<>();
    private int size;
    private final int capacity;
    private final DLinkedNode head;
    private final DLinkedNode tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 新节点添加到双向链表的头部
            addToHead(newNode);
            size++;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tailNode = tail.prev;
                removeNode(tailNode);
                // 删除哈希表中对应的项
                cache.remove(tailNode.key);
                size--;
            }
        } else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
}
```





#### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class P147_Solution {
    // 从前往后找插入点
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;
        head.next = null;
        // 表示最终找到插入位置时的后一个结点
        ListNode cur;
        ListNode temp;
        // 每次插入一个结点, 都从头遍历到合适位置
        while (node != null) {
            temp = node.next;
            // 表示最终找到插入位置时的前一个结点
            ListNode prev = new ListNode();
            prev.next = head;
            cur = head;
            while (cur != null && cur.val < node.val) {
                prev = cur;
                cur = cur.next;
            }
            // 退出 while 时要么是该 node.val 为已排链表的最大值(cur == null), 添加在末尾
            // 要么 不是最大值, 添加在中间某处(prev 与 cur 之间, cur 不为 null)
            if (cur == null) {
                prev.next = node;
                node.next = null;
            } else {
                node.next = cur;
                prev.next = node;
                // 如果 node.val 的值比头结点的值小, 需要将该 node 结点设为头结点
                if (cur == head) {
                    head = node;
                }
            }
            node = temp;
        }
        return head;
    }

    // 从前往后找插入点, 对上一个方法的代码逻辑简化
    public ListNode insertionSortList1(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;
        head.next = null;
        // 表示最终找到插入位置时的后一个结点
        ListNode cur;
        ListNode temp;
        // 每次插入一个结点, 都从头遍历到合适位置
        while (node != null) {
            temp = node.next;
            // 表示最终找到插入位置时的前一个结点
            ListNode prev = new ListNode();
            prev.next = head;
            cur = head;
            while (cur != null && cur.val < node.val) {
                prev = cur;
                cur = cur.next;
            }
            // 退出 while 时要么是该 node.val 为已排链表的最大值(cur == null), 添加在末尾
            // 要么 不是最大值, 添加在中间某处(prev 与 cur 之间, cur 不为 null)
            node.next = cur;
            prev.next = node;
            // 如果 node.val 的值比头结点的值小, 需要将该 node 结点设为头结点
            if (cur == head) {
                head = node;
            }
            node = temp;
        }
        return head;
    }
}
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

```java
// 模仿着 P123_买卖股票的最佳时机III 做, 一次通过哈哈哈
class P188_Solution {
    // dp 数组定义为 dp[k * 2] 大小
    public int maxProfit1(int k, int[] prices) {
        if (prices == null || k == 0) {
            return 0;
        }
        int n = prices.length;
        if (n <= 1) {
            return 0;
        }

        // 因为 n 天最多只能进行 n/2 笔交易, 因此我们可以将 k 对 n/2 取较小值之后再进行动态规划
        k = Math.min(k, n / 2);
        // count == k * 2;
        // k 为交易次数, count 为总买卖次数, 交易次数的两倍
        final int count = k * 2;
        // dp 数组
        int[] dp = new int[count];
        // 赋初值
        for (int i = 0; i < count; i += 2) {
            dp[i] = -prices[0];
            dp[i + 1] = 0;
        }
        // 动态规划
        // 第 i 天时, 第 j 次买和卖的最大利润
        for (int i = 1; i < n; i++) {
            // 第 i 天第 1 次买获得的最大利润
            dp[0] = Math.max(dp[0], -prices[i]);
            // 第 i 天第 1 次卖获得的最大利润
            dp[1] = Math.max(dp[1], dp[0] + prices[i]);
            for (int j = 2; j < count; j += 2) {
                // 第 i 天第 j 次买获得的最大利润 为
                // (第 i-1 天第 j 次买) 与 (第 j-1 次卖 - 第 i 天第 j 次买的这只股票的价格(prices[i])) 中的较大值
                dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);
                // 第 i 天第 j 次卖获得的最大利润 为
                // (第 i-1 天第 j 次卖) 与 (第 j 次买 + 第 i 天第 j 次卖的这只股票的价格(prices[i])) 中的较大值
                dp[j + 1] = Math.max(dp[j + 1], dp[j] + prices[i]);
            }
        }
        return dp[count - 1];
    }

    // 将 dp 数组定义为 dp[k * 2] 大小, 确实复杂了好多, 改为两个 k 大小的数组要好很多
    // 这效率居然还没有上一个高？就挺意外的。难道是两个数组在赋值寻找索引位置时的查找时间更长？
    // 诶, 貌似今天(第二天)再看, 其实也差不多诶
    public int maxProfit(int k, int[] prices) {
        if (prices == null || k == 0) {
            return 0;
        }
        int n = prices.length;
        if (n <= 1) {
            return 0;
        }

        // 因为 n 天最多只能进行 n/2 笔交易, 因此我们可以将 k 对 n/2 取较小值之后再进行动态规划
        k = Math.min(k, n / 2);
        // dp 数组
        int[] buy = new int[k];
        int[] sell = new int[k];
        // 赋初值
        for (int i = 0; i < k; i++) {
            buy[i] = -prices[0];
            sell[i] = 0;
        }
        // 动态规划
        // 第 i 天时, 第 j 次买和卖的最大利润
        for (int i = 1; i < n; i++) {
            // 第 i 天第 1 次买获得的最大利润
            buy[0] = Math.max(buy[0], -prices[i]);
            // 第 i 天第 1 次卖获得的最大利润
            sell[0] = Math.max(sell[0], buy[0] + prices[i]);
            for (int j = 1; j < k; j++) {
                // 第 i 天第 j 次买获得的最大利润 为
                // (第 i-1 天第 j 次买) 与 (第 j-1 次卖 - 第 i 天第 j 次买的这只股票的价格(prices[i])) 中的较大值
                buy[j] = Math.max(buy[j], sell[j - 1] - prices[i]);
                // 第 i 天第 j 次卖获得的最大利润 为
                // (第 i-1 天第 j 次卖) 与 (第 j 次买 + 第 i 天第 j 次卖的这只股票的价格(prices[i])) 中的较大值
                sell[j] = Math.max(sell[j], buy[j] + prices[i]);
            }
        }
        return sell[k - 1];
    }
}
```



#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

##### 动态规划

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。
>
>
> - 空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。
>

```java
// 动态规划
class P198_Solution {
    // 动态规划
    // 时间复杂度：O(n)
    // 空间复杂度：O(n)
    public int rob1(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        // 此 if 也可删除
        if (n == 1) {
            // 如果只有一间房屋, 则偷窃该房屋, 可以偷窃到最高总金额
            return nums[0];
        } else if (n == 2) {
            // 如果只有两间房屋, 则由于两间房屋相邻, 不能同时偷窃, 只能偷窃其中的一间房屋
            // 因此选择其中金额较高的房屋进行偷窃, 可以偷窃到最高总金额
            return Math.max(nums[0], nums[1]);
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            // 偷窃第 i 间房屋，那么就不能偷窃第 i − 1 间房屋，偷窃总金额为前 i − 2 间房屋的最高总金额与第 i 间房屋的金额之和。
            // 不偷窃第 i 间房屋，偷窃总金额为前 i − 1 间房屋的最高总金额。
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }

    // 动态规划(滚动数组思想), 减小空间复杂度
    // 考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关
    // 因此可以使用滚动数组, 在每个时刻只需要存储前两间房屋的最高总金额
    // 时间复杂度：O(n)
    // 空间复杂度：O(1)
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        // 此 if 也可删除
        if (n == 1) {
            // 如果只有一间房屋, 则偷窃该房屋, 可以偷窃到最高总金额
            return nums[0];
        } else if (n == 2) {
            // 如果只有两间房屋, 则由于两间房屋相邻, 不能同时偷窃, 只能偷窃其中的一间房屋
            // 因此选择其中金额较高的房屋进行偷窃, 可以偷窃到最高总金额
            return Math.max(nums[0], nums[1]);
        }

        int[] dp = new int[3];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            // 偷窃第 i 间房屋, 那么就不能偷窃第 i − 1 间房屋，偷窃总金额为前 i − 2 间房屋的最高总金额与第 i 间房屋的金额之和
            // 不偷窃第 i 间房屋, 偷窃总金额为前 i − 1 间房屋的最高总金额
            dp[2] = Math.max(dp[1], dp[0] + nums[i]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 最后返回 dp[2] dp[1] 均可, 它俩值相等
        return dp[2];
    }
}
```



#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

##### 2021.11.01

###### 深度优先搜索 DFS

```java
// 使用 深度优先搜索
class P200_Solution {
    char[][] grid;

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        // numOfIslands 表示岛屿数量
        int numOfIslands = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                // 每进行一次深度优先搜索, 表示有一个岛屿
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    numOfIslands++;
                }
            }
        }
        return numOfIslands;
    }

    public void dfs(int i, int j) {
        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length) {
            if (grid[i][j] == '1') {
                // 每次遇到 '1' ,就将其改为 '2', 表示已经遍历了该陆地 '1'
                grid[i][j] = '2';
                // 按照"左上右下"的顺序遍历该陆地的相邻区域(方格)
                dfs(i, j - 1);
                dfs(i - 1, j);
                dfs(i, j + 1);
                dfs(i + 1, j);
            }
        }
    }
}
```

###### 广度优先搜索 BFS

```java
// 使用 广度优先搜索
class P200_Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        // numOfIslands 表示岛屿数量
        int numOfIslands = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 每进行一次广度优先搜索, 表示有一个岛屿
                if (grid[i][j] == '1') {
                    numOfIslands++;
                    // 每次遇到 '1' ,就将其改为 '2', 表示已经遍历了该陆地 '1'
                    grid[i][j] = '2';
                    // 创建一个队列用以保存该陆地及其相邻的陆地和相连的区域
                    Queue<Integer> neighbors = new LinkedList<>();
                    // 该陆地入队
                    neighbors.add(i * n + j);
                    int id, row, col;
                    // while 中出队一个已访问的陆地, 入队与其相邻的陆地, 直到队列为空
                    while (!neighbors.isEmpty()) {
                        id = neighbors.remove();
                        row = id / n;
                        col = id % n;
                        // 如果该陆地的周围(上下左右)有陆地, 将其添加进队列中, 标记为已访问 '2'
                        // 按照"左上右下"的顺序遍历该陆地的相邻区域(方格)
                        // 左
                        if (col - 1 >= 0 && grid[row][col - 1] == '1') {
                            // neighbors.add(row * n + col - 1);
                            // 与上等价
                            neighbors.add(id - 1);
                            grid[row][col - 1] = '2';
                        }
                        // 上
                        if (row - 1 >= 0 && grid[row - 1][col] == '1') {
                            // neighbors.add((row - 1) * n + col);
                            // 与上等价
                            neighbors.add(id - n);
                            grid[row - 1][col] = '2';
                        }
                        // 右
                        if (col + 1 < n && grid[row][col + 1] == '1') {
                            // neighbors.add(row * n + col + 1);
                            // 与上等价
                            neighbors.add(id + 1);
                            grid[row][col + 1] = '2';
                        }
                        // 下
                        if (row + 1 < m && grid[row + 1][col] == '1') {
                            // neighbors.add((row + 1) * n + col);
                            // 与上等价
                            neighbors.add(id + n);
                            grid[row + 1][col] = '2';
                        }
                    }
                }
            }
        }
        return numOfIslands;
    }
}
```

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

##### 拓扑排序（深度优先搜索 递归实现）

###### 第一种实现

> DFS 第一种实现，官方实现，使用` List<List<Integer>>` 构建邻接表

```java
// 拓扑排序(Topological sort)(DFS 递归实现)
// DFS 第一种实现, 官方实现, 使用 List<List<Integer>> 构建邻接表
class P207_Solution2 {
    // 使用 List<List<Integer>> adjList = new ArrayList<>(); 构造邻接表
    List<List<Integer>> adjList;
    // 记录遍历情况
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        adjList = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        visited = new int[numCourses];
        // 构建邻接表
        for (int[] edge : prerequisites) {
            adjList.get(edge[1]).add(edge[0]);
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                break;
            }
        }
        return valid;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;
        for (int next : adjList.get(i)) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next] == 0) {
                dfs(next);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
        }
        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
    }
}
```

###### 第二种实现（最优）

> DFS 第二种实现，创建 `CourseNode `节点，使用 `CourseNode[]` 构建邻接表
>
> 效率最高, 耗时最少, 但是消耗的内存更多一点

```java
// 拓扑排序(Topological sort)(DFS 递归实现)
// DFS 第二种实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 效率最高, 耗时最少, 但是消耗的内存更多一点
class P207_Solution {
    // 使用 CourseNode[] 构建邻接表
    CourseNode[] adjList;
    // 记录每个节点的状态: 0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        adjList = new CourseNode[numCourses];
        visited = new int[numCourses];

        // 构建邻接表
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                break;
            }
        }
        return valid;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;

        CourseNode next = adjList[i];
        while (next != null) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next.value] == 0) {
                dfs(next.value);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next.value] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
            next = next.next;
        }

        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
    }
}

class CourseNode {
    // value 为课程编号
    int value;
    CourseNode next;

    public CourseNode(int value) {
        this.value = value;
    }

    public CourseNode(int value, CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

##### 拓扑排序（广度优先搜索 队列实现）

```java
// 拓扑排序(Topological sort)(BFS 队列实现)
// BFS 我的实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 官方实现未做
class P207_Solution1 {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 各个节点的入度
        int[] inDegree = new int[numCourses];
        // 图的邻接表表示
        CourseNode[] adjList = new CourseNode[numCourses];
        // 一条有向边的起始节点与结束节点
        int from, to;
        // 构造图
        for (int[] edge : prerequisites) {
            // from 表示要先学的课程, 学完课程 from, 才能学 to
            from = edge[1];
            // to 表示要先学完课程 from, 才能学 to
            to = edge[0];
            // 更新 to 节点的入度, 一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // BFS
        // 将入度为 0 的所有节点入队, 有可能是非连通图
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 如果 queue 中一个入度为 0 的节点都没有, 表示图存在环, 并且整个图是一个大环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return false;
        }

        // bfsCount 表示 BFS 的次数, 同时也表示经过历次循环后, 入度为 0 的节点的个数, 学习了的课程数
        // 如果无环, 当循环结束时, bfsCount 应该等于节点总数 numCourses
        int bfsCount = 0;
        int cur;
        CourseNode next;
        while (!queue.isEmpty()) {
            // 出队一个入度为 0 的节点(无先修课程或已学完先修课程)
            cur = queue.remove();
            // 次数加 +1
            bfsCount++;
            // adjList[cur] 处存储的是 cur 能够到达的下一个节点 next
            // 即以 cur 为先修课程的每个课程 next
            next = adjList[cur];
            // 遍历所有以 cur 为先修课程的每个课程 next
            while (next != null) {
                // next 的入度 -1, 即学完了一门先修课程
                inDegree[next.value]--;
                // 为 0 时, 表示学完了所有的先修课程
                if (inDegree[next.value] == 0) {
                    // 那么此时就可以将这门课程加入队列
                    queue.add(next.value);
                }
                // 下一门以 cur 为先修课程的课程
                next = next.next;
            }
        }
        // 循环结束时, 如果 bfsCount == numCourses, 说明所有的课程都能学完(先学其先修课程), 也即图中无环
        // 如果不相等, 说明有些课程无法学习, 原因在于这几门课程互相之间以另一门课程为先修课程
        // 以数据结构的角度来看, 说明图中存在环
        return bfsCount == numCourses;
    }
}

class CourseNode {
    // value 为课程编号
    int value;
    CourseNode next;

    public CourseNode(int value) {
        this.value = value;
    }

    public CourseNode(int value, CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```



#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

##### 拓扑排序（深度优先搜索 递归实现）

###### 第一种实现

> DFS 第一种实现，官方实现，使用` List<List<Integer>> `构建邻接表

```java
// 拓扑排序(DFS 递归实现)
// DFS 第一种实现, 官方实现, 使用 List<List<Integer>> 构建邻接表
class P210_Solution3 {
    // 使用 List<List<Integer>> adjList = new ArrayList<>(); 构造邻接表
    List<List<Integer>> adjList;
    // 记录每个节点的状态: 0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;
    // 用数组来模拟栈, 下标 n-1 为栈底, 0 为栈顶, 遍历结束后栈中元素即为拓扑排序
    int[] ans;
    // 栈下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        adjList = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        visited = new int[numCourses];
        ans = new int[numCourses];
        index = numCourses - 1;
        // 构建邻接表
        for (int[] edge : prerequisites) {
            adjList.get(edge[1]).add(edge[0]);
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                return new int[0];
            }
        }
        return ans;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;
        for (int next : adjList.get(i)) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next] == 0) {
                dfs(next);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
        }
        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
        // 将节点入栈
        ans[index] = i;
        // 下标索引减 1
        index--;
    }
}
```

###### 第二种实现（最优）

> DFS 第二种实现，创建 `CourseNode `节点，使用` CourseNode[] `构建邻接表
> 效率比前三种都高，耗时更少，但是消耗的内存更多

```java
// 拓扑排序(DFS 递归实现)
// DFS 第二种实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 效率比前三种都高, 耗时更少, 但是消耗的内存更多
class P210_Solution {
    // 使用 CourseNode[] 构建邻接表
    P210_CourseNode[] adjList;
    // 记录每个节点的状态: 0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;
    // 用数组来模拟栈, 下标 n-1 为栈底, 0 为栈顶, 遍历结束后栈中元素即为拓扑排序
    int[] ans;
    // 栈下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        adjList = new P210_CourseNode[numCourses];
        visited = new int[numCourses];
        ans = new int[numCourses];
        index = numCourses - 1;

        // 构建邻接表
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new P210_CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                return new int[0];
            }
        }
        return ans;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;

        P210_CourseNode next = adjList[i];
        while (next != null) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next.value] == 0) {
                dfs(next.value);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next.value] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
            next = next.next;
        }

        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
        // 将节点入栈
        ans[index] = i;
        // 下标索引减 1
        index--;
    }
}

// CourseNode
class P210_CourseNode {
    // value 为课程编号
    int value;
    P210_CourseNode next;

    public P210_CourseNode(int value) {
        this.value = value;
    }

    public P210_CourseNode(int value, P210_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

##### 拓扑排序（广度优先搜索 队列实现）

###### 第一种实现

```java
// 拓扑排序(BFS 队列实现)
// BFS 第一种实现, 官方实现, 使用 List<List<Integer>> 构建邻接表
// 效率低, 时间不及 DFS
class P210_Solution1 {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        List<List<Integer>> adjList = new ArrayList<>(numCourses);
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        // 存储每个节点的入度
        int[] inDegree = new int[numCourses];
        // 构建邻接表, 并得到每个节点的入度
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 终止节点的入度加 1
            inDegree[to]++;
            // 将该边添加进邻接表 adjList
            adjList.get(from).add(to);
        }

        // BFS
        // 入度为 0 的节点入队
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 一个入度为 0 的节点都没有, 说明有一个整个图是一个大环, 可直接返回
        // 此判断可删除
        if (queue.isEmpty()) {
            return new int[0];
        }

        // 答案, 每出队一个入度为 0 的节点, 等于确定一门先修课程
        int[] ans = new int[numCourses];
        // 添加的位置, 同时也代表得到答案中的节点个数 index + 1
        int index = 0;
        int cur;
        while (!queue.isEmpty()) {
            // 从队首取出一个入度为 0 的节点
            cur = queue.remove();
            // 将 cur 添加进答案中
            ans[index] = cur;
            // 下一个添加位置
            index++;
            for (Integer next : adjList.get(cur)) {
                // 以 cur 为起始点的有向边的终点的入度减 1
                inDegree[next]--;
                // 入度减小到为 0 时, 说明 next 的所有前修课程均已经学习完毕, 将其加入队列, 后续就可以学习这门课程了
                if (inDegree[next] == 0) {
                    queue.add(next);
                }
            }
        }
        // 循环结束时, 如果 index 等于 numCourses, 说明这个学习顺序能够完成所有课程的学习
        return index == numCourses ? ans : new int[0];
    }
}
```

###### 第二种实现

```java
// 拓扑排序(BFS 队列实现)
// BFS 第二种实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 效率比第一种高, 耗时更少, 空间也比第一种更少
class P210_Solution2 {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        P210_CourseNode[] adjList = new P210_CourseNode[numCourses];
        // 存储每个节点的入度
        int[] inDegree = new int[numCourses];
        // 构建邻接表, 并得到每个节点的入度
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 终止节点的入度加 1
            inDegree[to]++;
            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new P210_CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // BFS
        // 入度为 0 的节点入队
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 一个入度为 0 的节点都没有, 说明有一个整个图是一个大环, 可直接返回
        // 此判断可删除
        if (queue.isEmpty()) {
            return new int[0];
        }

        // 答案, 每出队一个入度为 0 的节点, 等于确定一门先修课程
        int[] ans = new int[numCourses];
        // 添加的位置, 同时也代表得到答案中的节点个数 index + 1
        int index = 0;
        int cur;
        P210_CourseNode next;
        while (!queue.isEmpty()) {
            // 从队首取出一个入度为 0 的节点
            cur = queue.remove();
            // 将 cur 添加进答案中
            ans[index] = cur;
            // 下一个添加位置
            index++;
            next = adjList[cur];
            while (next != null) {
                // 以 cur 为起始点的有向边的终点的入度减 1
                inDegree[next.value]--;
                // 入度减小到为 0 时, 说明 next 的所有前修课程均已经学习完毕, 将其加入队列, 后续就可以学习这门课程了
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }
                next = next.next;
            }
        }
        // 循环结束时, 如果 index 等于 numCourses, 说明这个学习顺序能够完成所有课程的学习
        return index == numCourses ? ans : new int[0];
    }
}

// CourseNode
class P210_CourseNode {
    // value 为课程编号
    int value;
    P210_CourseNode next;

    public P210_CourseNode(int value) {
        this.value = value;
    }

    public P210_CourseNode(int value, P210_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```



#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

##### 动态规划

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。
> - 空间复杂度：O(1)。

```java
class P213_Solution {
    // 动态规划(滚动数组思想)
    // 时间复杂度：O(n)
    // 空间复杂度：O(1)
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        } else if (n == 2) {
            return Math.max(nums[0], nums[1]);
        } else if (n == 3) {
            return Math.max(Math.max(nums[0], nums[1]), nums[2]);
        }

        // 如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？
        // 如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；
        // 如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。
        return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }

    public int robRange(int[] nums, int start, int end) {

        int[] dp = new int[3];
        dp[0] = nums[start];
        dp[1] = Math.max(nums[start], nums[start + 1]);
        // dp[2] = dp[1];

        for (int i = start + 2; i <= end; i++) {
            dp[2] = Math.max(dp[0] + nums[i], dp[1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        System.out.println(Arrays.toString(dp));
        // 此处若返回 dp[2], 必须保证原 nums 数组长度大于 3
        // 由于之前咋 rob 中对 n == 3, 进行了特殊处理, 所以此处可以返回 dp[2]
        // 如果不对 n == 3 做特殊处理, 也可以给 dp[2] 赋初值 dp[2] = dp[1];
        // 当然, 如果是返回 dp[1] 就肯定没错
        return dp[2];
    }
}
```
#### [223. 矩形面积](https://leetcode-cn.com/problems/rectangle-area/)

```java
class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        // 解决思路：用两块矩形的面积和减去两块矩形重叠部分的面积,不过为了在运算过程中防止溢出，需要先用其中一块矩形面积减去重叠面积，再加上另一块矩形面积
        
        // 重叠面积初始化为 0
        int coverArea = 0;
        // 如果两块矩形没有重合，则重叠面积 coverArea 为 0，后续 return 直接返回两矩形面积和
        if (bx1 >= ax2 || bx2 <= ax1 || by1 >= ay2 || by2 <= ay1) {
             coverArea = 0;
        } else {

            // 两块矩形重叠部分的面积 = 两矩形重叠部分长（x 轴差） * 两矩形重叠部分宽（y 轴差）
            // 两矩形重叠部分长 = x 轴上两矩形右边条边的较小值 min(ax2, bx2) - x 轴上两矩形左边条边的较大值 max(ax1, bx1)
            // 两矩形重叠部分宽 = y 轴上两矩形上边条边的较小值 min(ay2, by2) - y 轴上两矩形下边条边的较大值 max(ay1, by1)

            int x_right_min = Math.min(ax2, bx2);
            int x_left_max = Math.max(ax1, bx1);
            int y_up_min = Math.min(ay2, by2);
            int y_down_max = Math.max(ay1, by1);

            // 两块矩形重叠部分的面积
            coverArea = (x_right_min - x_left_max) * (y_up_min - y_down_max);
        }
        
        // 一块矩形面积 - 重叠面积 + 另一块矩形面积
        return (ax2 - ax1) * (ay2 - ay1) - coverArea + (bx2 - bx1) * (by2 - by1);
    }
}
```


#### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */

class P237_Solution {
    // 我做的, 将 node 结点的值置为后一个结点的值, 直到末尾, 然后再删除最后一个结点(此时值与倒数第二个结点重复了)
    public void deleteNode(ListNode node) {
        ListNode temp = node;
        while (node != null) {
            if (node.next != null) {
                node.val = node.next.val;
                temp = node;
                node = node.next;
            } else {
                temp.next = null;
                node = null;
            }
        }
    }

    // 优化, 只需要将 node 结点的值变为 node.next 的值, 然后删除 node.next 就行了
    public void deleteNode1(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

##### 动态规划

> 时间复杂度：O(n^2)
>
> 空间复杂度：O(n)

```java
class P300_Solution {
    // 动态规划
    // 时间复杂度：O(n^2) 空间复杂度：O(n)
    // 内层 for 循环我犯过一次错误, 以为在 nums[i] 前找到第一个比 nums[i] 小的值的 dp 就行了
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 最长递增子序列的长度, 初值为 0 为 1 均可
        int maxLen = 1;
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的长度
        int[] dp = new int[n];
        // 赋初值: 以 nums[0] 结尾的最长子序列的长度为 1
        dp[0] = 1;
        // 从 i == 1 开始
        for (int i = 1; i < n; i++) {
            // 在 [0,i) 之间找到比当前 nums[i] 小的那个数, 假设有 x 个这样的数
            // 那么 dp[i] 也就等于以这 x 个这样的数结尾的最长子序列长度的最大值 + 1
            // 也就是找到一条 i 之前的最长子序列, 并且该最长子序列的结尾值要 nums[j] < nums[i]
            // 那么现在加上 nums[i] 这个数, 就有了一条以 nums[i] 结尾的最长子序列
            // 同时也知道了其长度值, 更新 dp[i]
            // 那么当循环结束时, 就知道了以这 n 个数结尾的最长子序列的长度, 最长长度就很轻松就能得到

            // 以上讨论的是找得到的情况, 如果找不到呢?
            // 找不到不就说明当前 nums[i] 是 [0,i] 之间这 i + 1 个数中的最大值吗?
            // 那么 nums[i] 就成为了一条新的子序列的开头(也即末尾), 当前序列长度就为 1 了
            // 故在查找前, 先令其为 1, 后续如果找到, 肯定值比 1 大
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    // 如果是非严格单调递增, 改为 <= 即可
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            // 每次得到以 nums[i] 结尾的最长子序列长度, 就与之前的 maxLen 比较
            // 得到 [0,i] 之间以这 i + 1 个数结尾的最长子序列长度中的最大值
            maxLen = Math.max(maxLen, dp[i]);
        }
        // System.out.println(Arrays.toString(dp));
        return maxLen;
    }
}
```

##### 贪心 + 二分查找

> 时间复杂度：O(nlogn)
>
> 空间复杂度：O(n)

```java
class P300_Solution {
    // 贪心 + 二分查找
    // 时间复杂度：O(nlogn) 空间复杂度：O(n)
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 贪心
        // 维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，
        // 用 len 记录目前最长上升子序列的长度，
        // 起始时 len 为 1，d[1] = nums[0]
        // d[0] 位置不管
        int[] d = new int[n + 1];
        // 赋初值
        int len = 1;
        d[len] = nums[0];
        for (int i = 1; i < n; i++) {
            // nums[i] 比当前最长子序列的最后一个元素都大, 将其添加在末尾 d[len + 1]
            if (nums[i] > d[len]) {
                d[len + 1] = nums[i];
                len++;
                continue;
            }
            // 二分查找
            int left = 1;
            int right = len;
            int mid = 0;
            while (left <= right) {
                mid = (left + right) / 2;
                if (nums[i] > d[mid]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            // 两种赋值方式选其一
/*
            // 1.
            // 此时, left == mid
            if (right < mid) {
                d[mid] = nums[i];
            } else {
                // 此时, left == mid + 1
                d[mid + 1] = nums[i];
            }
*/
            // 2. 算是第一种的归纳总结
            // 故最终
            // 这个结束赋值极其重要, 到现在其实都不太明白, while 结束后应该在哪一个位置赋值
            // 这个类似插入位置之前在 P35 遇到过
            d[left] = nums[i];
        }
        return len;
    }
}
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```java
// 动态规划
class P322_Solution {
    public int coinChange1(int[] coins, int amount) {
        // 特殊情况处理
        if (amount == 0) {
            return 0;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return -1;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return amount / coins[0];
            } else {
                return -1;
            }
        }

        // 先对 coins 排序, 减少循环次数
        Arrays.sort(coins);

        // 特殊情况处理: 如果金额比最小的一枚硬币还小, 则找不到(前提是 amount > 0)
        if (amount < coins[0]) {
            return -1;
        }

        int[] dp = new int[amount + 1];
        // 由于在循环中比较求得的是最小值, 所以在赋初值时需要将其将 dp 置为尽量大的不可能是结果的数
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        // 依次判断确认, 找出凑成金额为 i 的最少硬币个数
        for (int i = 1; i < amount + 1; i++) {
            for (int j = 0; j < n; j++) {
                // 只有当前硬币小于金额 i 时, 才可能将该硬币添加进组合中
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                } else {
                    break;
                }
            }
        }
        // 如果最终结果中 dp[amount] 还是最初的初值, 说明根本找不到这种硬币组合, 返回 -1
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }

    // 些微优化
    public int coinChange(int[] coins, int amount) {
        // 特殊情况处理
        if (amount == 0) {
            return 0;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return -1;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return amount / coins[0];
            } else {
                return -1;
            }
        }

        // 先对 coins 排序, 减少循环次数
        Arrays.sort(coins);

        // 特殊情况处理: 如果金额比最小的一枚硬币还小, 则找不到(前提是 amount > 0)
        if (amount < coins[0]) {
            return -1;
        }

        int[] dp = new int[amount + 1];
        dp[0] = 0;

        int min;

        // 依次判断确认, 找出凑成金额为 i 的最少硬币个数
        for (int i = 1; i < amount + 1; i++) {
            // 由于在循环中比较求得的是最小值, 所以在赋初值时需要将其将 min 置为尽量大的不可能是结果的数
            min = amount + 1;
            for (int coin : coins) {
                // 只有当前硬币小于金额 i 时, 才可能将该硬币添加进组合中
                if (coin <= i) {
                    min = Math.min(min, dp[i - coin]);
                } else {
                    break;
                }
            }
            dp[i] = min + 1;
        }
        // 如果最终结果中 dp[amount] 还是最初的初值, 说明根本找不到这种硬币组合, 返回 -1
        return dp[amount] >= amount + 1 ? -1 : dp[amount];
    }
}
```



#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

##### 动态规划

> [一个不错的题解](https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/)

```java
class P337_Solution1 {
    // 表示选择 node 节点的情况下, node 节点的子树上被选择的节点的最大权值和
    Map<TreeNode, Integer> selectThisNode = new HashMap<>();
    // 表示不选择 node 节点的情况下, node 节点的子树上被选择的节点的最大权值和
    Map<TreeNode, Integer> notSelectThisNode = new HashMap<>();

    public int rob(TreeNode root) {
        dfs(root);
        return Math.max(selectThisNode.getOrDefault(root, 0), notSelectThisNode.getOrDefault(root, 0));
    }

    // 后序遍历
    public void dfs(TreeNode node) {
        if (node == null) {
            return;
        }
        // 遍历左子树, 得到 node 节点的左子树上 (被选择和不被选择) 的节点的最大权值和
        // 退出 dfs 时, (node.left, 被选择和不被选择的 权值和) 已经添加进了 selectThisNode 和 notSelectThisNode 中
        dfs(node.left);
        // 遍历右子树, 得到 node 节点的右子树上 (被选择和不被选择) 的节点的最大权值和
        dfs(node.right);

        // 当 node 被选中时, node 的左右孩子都不能被选中, 故 node 被选中情况下子树上被选中点的最大权值和为
        // node.left 和 node.right 不被选中的最大权值和相加,
        // 即 sel(node) = node.val + not(node.left) + not(node.right)
        selectThisNode.put(node, node.val
                + notSelectThisNode.getOrDefault(node.left, 0)
                + notSelectThisNode.getOrDefault(node.right, 0)
        );
        // 当 node 不被选中时, node 的左右孩子可以被选中, 也可以不被选中
        // 对于 node 的某个具体的孩子 children, 它对 node 的贡献是 children 被选中和不被选中情况下权值和的较大值
        // 故 not(node) = max{sel(node.left) , not(node.left)} + max{sel(node.right) , not(node.right)}
        notSelectThisNode.put(node,
                Math.max(selectThisNode.getOrDefault(node.left, 0), notSelectThisNode.getOrDefault(node.left, 0))
                        + Math.max(selectThisNode.getOrDefault(node.right, 0), notSelectThisNode.getOrDefault(node.right, 0))
        );
    }
}
```

> 以上的算法对二叉树做了一次后序遍历，时间复杂度是 O(n)；由于递归会使用到栈空间，空间代价是 O(n)，哈希表的空间代价也是 O(n)，故空间复杂度也是 O(n)。
>

简单优化，省去使用哈希表的空间, 但是整体空间复杂度并未改变, 均是O(N)

```java
// 优化, 省去使用哈希表的空间, 但是整体空间复杂度并未改变, 均是O(N)
class P337_Solution {

    public int rob(TreeNode root) {
        int[] rootStatus = dfs(root);
        return Math.max(rootStatus[0], rootStatus[1]);
    }

    // 后序遍历
    public int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        // 遍历左子树, 得到 node 节点的左子树上 (被选择和不被选择) 的节点的最大权值和
        // 退出 dfs 时, 返回 node.left 的 被选择和不被选择的权值和数组 leftNodeStatus
        // leftNodeStatus[0] 表示 选择 node.left 的权值和
        // rightNodeStatus[0] 表示 不选择 node.left 的权值和
        int[] leftNodeStatus = dfs(node.left);
        // 遍历右子树, 得到 node 节点的右子树上 (被选择和不被选择) 的节点的最大权值和
        int[] rightNodeStatus = dfs(node.right);

        // 当 node 被选中时, node 的左右孩子都不能被选中, 故 node 被选中情况下子树上被选中点的最大权值和为
        // node.left 和 node.right 不被选中的最大权值和相加,
        // 即 sel(node) = node.val + not(node.left) + not(node.right)
        int valOfSelectThisNode = node.val + leftNodeStatus[1] + rightNodeStatus[1];

        // 当 node 不被选中时, node 的左右孩子可以被选中, 也可以不被选中
        // 对于 node 的某个具体的孩子 children, 它对 node 的贡献是 children 被选中和不被选中情况下权值和的较大值
        // 故 not(node) = max{sel(node.left) , not(node.left)} + max{sel(node.right) , not(node.right)}
        int valOfNotSelectThisNode = Math.max(leftNodeStatus[0], leftNodeStatus[1]) + Math.max(rightNodeStatus[0], rightNodeStatus[1]);

        return new int[]{valOfSelectThisNode, valOfNotSelectThisNode};
    }

    // 后序遍历, 些微改变
    public int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        // 遍历左子树, 得到 node 节点的左子树上 (被选择和不被选择) 的节点的最大权值和
        // 退出 dfs 时, 返回 node.left 的 被选择和不被选择的权值和数组 leftNodeStatus
        // leftNodeStatus[0] 表示 选择 node.left 的权值和
        // rightNodeStatus[0] 表示 不选择 node.left 的权值和
        int[] leftNodeStatus = dfs(node.left);
        // 遍历右子树, 得到 node 节点的右子树上 (被选择和不被选择) 的节点的最大权值和
        int[] rightNodeStatus = dfs(node.right);

        int[] nodeStatus = new int[2];

        // 当 node 被选中时, node 的左右孩子都不能被选中, 故 node 被选中情况下子树上被选中点的最大权值和为
        // node.left 和 node.right 不被选中的最大权值和相加,
        // 即 sel(node) = node.val + not(node.left) + not(node.right)
        nodeStatus[0] = node.val + leftNodeStatus[1] + rightNodeStatus[1];

        // 当 node 不被选中时, node 的左右孩子可以被选中, 也可以不被选中
        // 对于 node 的某个具体的孩子 children, 它对 node 的贡献是 children 被选中和不被选中情况下权值和的较大值
        // 故 not(node) = max{sel(node.left) , not(node.left)} + max{sel(node.right) , not(node.right)}
        nodeStatus[1] = Math.max(leftNodeStatus[0], leftNodeStatus[1]) + Math.max(rightNodeStatus[0], rightNodeStatus[1]);

        return nodeStatus;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)。上文中已分析。
>
>
> - 空间复杂度：O(n)。虽然优化过的版本省去了哈希表的空间，但是栈空间的使用代价依旧是 O(n)，故空间复杂度不变。
>

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

##### 2021.10.31

```java
class P344_Solution {
    public void reverseString(char[] s) {
        int len = s.length;
        char temp;
        for (int i = 0; i < len / 2; i++) {
            temp = s[i];
            s[i] = s[len - 1 - i];
            s[len - 1 - i] = temp;
        }
    }
}
```

#### [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)

##### 哈希表

```java
class P391_Solution {
    public boolean isRectangleCover(int[][] rectangles) {
        int n = rectangles.length;
        if (n == 1) {
            return true;
        }
        // 定义矩形的面积
        long area = 0;

        int minX = rectangles[0][0];
        int minY = rectangles[0][1];
        int maxX = rectangles[0][2];
        int maxY = rectangles[0][3];
        // 保存各个顶点出现的次数
        Map<Point, Integer> cnt = new HashMap<>();
        for (int[] rect : rectangles) {
            // 两个顶点的横纵坐标
            int a = rect[0];
            int b = rect[1];
            int c = rect[2];
            int d = rect[3];

            // 累加各个矩形的面积, 得到总和, 最后与 (maxX - minX) * (maxY - minY) 比较
            area += (long) (c - a) * (d - b);

            minX = Math.min(minX, a);
            minY = Math.min(minY, b);
            maxX = Math.max(maxX, c);
            maxY = Math.max(maxY, d);

            // 将该矩形的四个顶点加入 map 中, 并更新出现次数
            Point point1 = new Point(a, b);
            Point point2 = new Point(a, d);
            Point point3 = new Point(c, b);
            Point point4 = new Point(c, d);

            cnt.put(point1, cnt.getOrDefault(point1, 0) + 1);
            cnt.put(point2, cnt.getOrDefault(point2, 0) + 1);
            cnt.put(point3, cnt.getOrDefault(point3, 0) + 1);
            cnt.put(point4, cnt.getOrDefault(point4, 0) + 1);
        }

        // System.out.println("maxX = " + maxX + ", minX = " + minX + ", maxY = " + maxY + ", minY = " + minY);
        // System.out.println((maxX - minX) * (maxY - minY));
        // 得到最终完美矩形的四个顶点
        Point pointMinMin = new Point(minX, minY);
        Point pointMinMax = new Point(minX, maxY);
        Point pointMaxMin = new Point(maxX, minY);
        Point pointMaxMax = new Point(maxX, maxY);

        // 面积不相等或者四个顶点中并不是每个顶点都只出现一次
        if (area != (long) (maxX - minX) * (maxY - minY) ||
                cnt.getOrDefault(pointMinMin, 0) != 1 ||
                cnt.getOrDefault(pointMinMax, 0) != 1 ||
                cnt.getOrDefault(pointMaxMin, 0) != 1 ||
                cnt.getOrDefault(pointMaxMax, 0) != 1) {
            return false;
        }

        // 移除四个角顶点
        cnt.remove(pointMinMin);
        cnt.remove(pointMinMax);
        cnt.remove(pointMaxMin);
        cnt.remove(pointMaxMax);

        // 判断非矩形区域四角的顶点 出现的次数
        // 如果是完美矩形, 出现次数只能是 2 或者 4 次
        for (Map.Entry<Point, Integer> entry : cnt.entrySet()) {
            int value = entry.getValue();
            if (value != 2 && value != 4) {
                return false;
            }
        }
        return true;
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public int hashCode() {
        // return x + y;
        // 这个太神奇了, 改哈希函数, 太影响性能了
        return x * 512 - y;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Point) {
            Point point2 = (Point) obj;
            return this.x == point2.x && this.y == point2.y;
        }
        return false;
    }
}
```

##### 扫描线

待补充学习

#### [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

##### 迭代

> 依次遍历每块陆地，判断其上下左右的方格是否为水域，如果是，周长加1。

##### 深度优先搜索(递归实现)

```java
// 深度优先搜索(递归实现)
class P463_Solution {
    int[][] grid;

    public int islandPerimeter(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int Perimeter = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    Perimeter = dfs(i, j);
                    // 本题要求只有一个岛屿
                    break;
                }
            }
            if (Perimeter != 0) {
                // 本题要求只有一个岛屿
                break;
            }
        }
        return Perimeter;
    }

    public int dfs(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return 1;
        }
        // 如果该格子是水, return 1;
        if (grid[i][j] == 0) {
            return 1;
        } else if (grid[i][j] == 2) {
            // 如果该格子是已经访问过的陆地, return 0;
            return 0;
        }

        // 如果该格子是未访问过的陆地
        // 标记为已访问
        grid[i][j] = 2;
        // 返回该陆地相连的其它陆地的总周长
        return dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);
    }
}
```

##### 其它解法

> 一束光从 x 轴正负两个方向分别照到岛上时照到的边的数量是相等的，从 y 轴正负两个方向分别照到岛上时照到的边的数量也是相等的
> 所以每个坐标轴只需计算一个方向，最后把答案乘二即可
> 经评论提醒，之前没有表达清除，这束光可以想象成从斜上方照向岛屿，因为要保证某一方向上所有的边都被照到
> 每个格子如果左边是水说明照的到，否则照不到，上方同理
>
> ```c++
> //C++
> class Solution {
> public:
>     int islandPerimeter(vector<vector<int>>& grid) 
>     {
>         int m = grid.size();
>         int n = grid[0].size();
>         int ans = 0;
>         for (int i = 0; i < m; ++i)
>             for (int j = 0; j < n; ++j)
>             {
>                 if (grid[i][j] == 1)
>                 {
>                     if (i == 0)
>                         ++ans;
>                     else
>                         ans += grid[i - 1][j] == 0;
>                     if (j == 0)
>                         ++ans;
>                     else
>                         ans += grid[i][j - 1] == 0;
>                 }
>             }
>         return ans << 1;
>     }
> };
> ```

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

##### 回溯

```java
// 回溯
class P494_Solution1 {
    int[] nums;
    int len;
    int count = 0;

    public int findTargetSumWays(int[] nums, int target) {
        // 可删除
        if (nums == null) {
            return 0;
        }
        this.nums = nums;
        this.len = nums.length;
        // 可删除, 特殊情况, nums 长度为 0,
        // target 也为 0, 返回 1; 不为 0, 返回 0
        if (len == 0) {
            if (target == 0) {
                return 1;
            }
            return 0;
        }
        // 特殊情况, nums 长度为 1
        if (len == 1) {
            if (nums[0] == target || nums[0] == -target) {
                return 1;
            }
            return 0;
        }

        dfs(0, 0, target);
        return count;
    }

    public void dfs(int index, int sum, int target) {
        // 结束
        if (index == len) {
            // 相等, 找到一个表达式
            if (sum == target) {
                count++;
            }
            return;
        }

        // 两个分支
        // 前 index 个数组成的表达式子的和 sum
        // 在此处可能加上或者减去 nums[index]
        dfs(index + 1, sum + nums[index], target);
        dfs(index + 1, sum - nums[index], target);
    }
}
```

##### 动态规划

> 此处对dp数组进行了降维(滚动数组思想)

```java
// 动态规划 一维 dp 数组(滚动数组思想)
class P494_Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 可删除
        if (nums == null) {
            return 0;
        }
        int len = nums.length;
        // 可删除, 特殊情况, nums 长度为 0,
        // target 也为 0, 返回 1; 不为 0, 返回 0
        if (len == 0) {
            if (target == 0) {
                return 1;
            }
            return 0;
        }
        // 特殊情况, nums 长度为 1
        if (len == 1) {
            if (nums[0] == target || nums[0] == -target) {
                return 1;
            }
            return 0;
        }

        // 数组和
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }

        // 将问题转换为在 nums 数组中找到几个数的和为 neg 的方案数
        int neg = diff / 2;

        // 动态规划数组
        // 列 j 表示在这 i 个数中找到若干个数的和为 j 的方案数
        int[] dp = new int[neg + 1];

        // 0 <= nums[i] <= 1000
        // 赋初值
        dp[0] = 1;

        // 需要仔细思考, 相比较于正向遍历, 反向遍历的循环次数更少
        // 并且正向遍历会出错, 因为 j 更大时会用到之前一次 i 循环中 j 更小时的一些数据
        // 如果循环是正向从前往后遍历的, 那么在遍历到更大的 j 时, dp[j - nums[i - 1]] 可能已经在此次 i 循环中已经被更改了,
        // 而不是上一次 i - 1 循环结束时保存的值
        for (int num : nums) {
            for (int j = neg; j >= num; j--) {
                // 此次进入循环时 dp[j] 为在前 i - 1 个数中选择若干个数的和为 j 的方案数(dp[j]), 即不选择这第 i 个数 nums[i - 1]
                // 并且此时肯定 j >= nums[i - 1], 说明可以选择这个数了, 就再加上这种情况的方案数 dp[j - nums[i - 1]]
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```



#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```java
class P509_Solution {
    // 动态规划 时间复杂度O(n) 空间复杂度O(n)
    public int fib(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    // 动态规划 对上方法的代码优化
    // 滚动数组思想, 时间复杂度O(n) 空间复杂度O(1)
    public int fib1(int n) {
        if (n < 2) {
            return n;
        }
        int[] dp = new int[3];
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
    
    // 递归 消耗最大
    public int fib2(int n) {
        if (n < 2) {
            return n;
        }
        return fib2(n - 1) + fib2(n - 2);
    }
}
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

```java
// 二维动态规划
class P518_Solution1 {
    // 二维动态规划
    public int change1(int amount, int[] coins) {
        // 特殊情况处理
        if (amount == 0) {
            return 1;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return 1;
            } else {
                return 0;
            }
        }
//        // 可有可无
//        // 先对 coins 排序, 减少循环次数
//        Arrays.sort(coins);
//
//        // 特殊情况处理: 如果金额比最小的一枚硬币还小, 则找不到(前提是 amount > 0)
//        if (amount < coins[0]) {
//            return 0;
//        }
        // 二维动态规划
        // 行表示有 0 种, 1 种, 2 种, ..., n 种硬币, 每种硬币的价值保存在 coins[] 数组中, 共 n + 1 行
        // 列表示要凑成的金额为 0, 1, 2, ..., amount, 共 amount + 1 列
        // dp[i][j] 表示当有 i 种硬币时, 需要把这 i 种硬币凑出金额为 j 的组合数
        int[][] dp = new int[n + 1][amount + 1];
        // 对特殊情况下的 dp数组 进行初始化赋值, 一般是 i 或 j 为 0 的初始情况
        // 首先, 考虑 dp[0][0], 0 种硬币凑成金额为 0 的组合数? 是多少呢? 为 1 对吧?
        // 然后, 判断第一行, 第一行表示 0 种硬币凑成金额为 j(j 在 0 到 amount 之间) 的组合数?
        // 好像除了能凑出金额 0 之外, 凑不出其它金额了吧? 故第一行除了 dp[0][0] 为 1, 其余均为 0
        // 最后, 判断第一列, 第一列表示可能有若干种硬币要凑成金额为 0 的组合数? 每种情况都可以吧, 组合数为 1
        // 于是, 第一列全为 1
        // 当然这个赋初值, 可以放到真正循环确定二维dp数组值时赋值也是可以的, 还减少了在此处赋值的循环次数
        for (int i = 0; i < n + 1; i++) {
            dp[i][0] = 1;
        }

        // 依次遍历得到有 i 种硬币时, 凑成金额为 j 的组合数 dp[i][j], 那么这个 dp[i][j] 是多少呢? 分两种情况:
        // 1.在上一次循环中, 当没有第 i 种硬币时, 即当只有前 i - 1 种硬币时, 它凑成金额为 j 的组合数为 dp[i - 1][j], dp[i][j] 肯定是要包含它的对吧?
        // 2.当肯定有第 i 种硬币(至少一枚, 金额为 coins[i - 1])时, 这种情况的组合数值就等价于
        // 要从这 i 种硬币中 凑成金额为 j - coins[i - 1] 的组合数, 其值为 dp[i][j - coins[i - 1]]
        // 但是在此处, 应该要特别注意当前要凑成的金额数 j 与 第 i 种硬币的价值大小(coins[i - 1])
        // 如果 j < coins[i - 1], 那么这种情况根本不能存在啊
        // 就比如: 第 i 种硬币的价值是 5, 现在拿它和前面的 i - 1 种硬币去凑出金额为 4 或者比 4 小的一定要包含 5 这种硬币的组合, 这显然不可能嘛
        // 于是乎, 在这种情况下的 dp[i][j] 值就为 dp[i - 1][j], 第二种情况的值为 0
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < amount + 1; j++) {
                if (j >= coins[i - 1]) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        // 最终 dp[n][amount] 就为 n 种硬币凑成金额为 amount 的组合数
        return dp[n][amount];
    }

    // 二维动态规划 代码简化
    public int change(int amount, int[] coins) {
        // 特殊情况处理
        if (amount == 0) {
            return 1;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return 1;
            } else {
                return 0;
            }
        }
        // 二维动态规划
        // 行表示有 0 种, 1 种, 2 种, ..., n 种硬币, 每种硬币的价值保存在 coins[] 数组中, 共 n + 1 行
        // 列表示要凑成的金额为 0, 1, 2, ..., amount, 共 amount + 1 列
        // dp[i][j] 表示当有 i 种硬币时, 需要把这 i 种硬币凑出金额为 j 的组合数
        int[][] dp = new int[n + 1][amount + 1];
        // 对特殊情况下的 dp数组 进行初始化赋值, 一般是 i 或 j 为 0 的初始情况
        // 首先, 考虑 dp[0][0], 0 种硬币凑成金额为 0 的组合数? 是多少呢? 为 1 对吧?
        // 然后, 判断第一行, 第一行表示 0 种硬币凑成金额为 j(j 在 0 到 amount 之间) 的组合数?
        // 好像除了能凑出金额 0 之外, 凑不出其它金额了吧? 故第一行除了 dp[0][0] 为 1, 其余均为 0
        // 最后, 判断第一列, 第一列表示可能有若干种硬币要凑成金额为 0 的组合数? 每种情况都可以吧, 组合数为 1
        // 于是, 第一列全为 1
        // 当然这个赋初值, 可以放到真正循环确定二维dp数组值时赋值也是可以的, 还减少了在此处赋值的循环次数
//        for (int i = 0; i < n + 1; i++) {
//            dp[i][0] = 1;
//        }

        // 依次遍历得到有 i 种硬币时, 凑成金额为 j 的组合数 dp[i][j], 那么这个 dp[i][j] 是多少呢? 分两种情况:
        // 1.在上一次循环中, 当没有第 i 种硬币时, 即当只有前 i - 1 种硬币时, 它凑成金额为 j 的组合数为 dp[i - 1][j], dp[i][j] 肯定是要包含它的对吧?
        // 2.当肯定有第 i 种硬币(至少一枚, 金额为 coins[i - 1])时, 这种情况的组合数值就等价于
        // 要从这 i 种硬币中 凑成金额为 j - coins[i - 1] 的组合数, 其值为 dp[i][j - coins[i - 1]]
        // 但是在此处, 应该要特别注意当前要凑成的金额数 j 与 第 i 种硬币的价值大小(coins[i - 1])
        // 如果 j < coins[i - 1], 那么这种情况根本不能存在啊
        // 就比如: 第 i 种硬币的价值是 5, 现在拿它和前面的 i - 1 种硬币去凑出金额为 4 或者比 4 小的一定要包含 5 这种硬币的组合, 这显然不可能嘛
        // 于是乎, 在这种情况下的 dp[i][j] 值就为 dp[i - 1][j], 第二种情况的值为 0
        for (int i = 1; i < n + 1; i++) {
            dp[i][0] = 1;
            for (int j = 1; j < amount + 1; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= coins[i - 1]) {
                    dp[i][j] += dp[i][j - coins[i - 1]];
                }
            }
        }
        // 最终 dp[n][amount] 就为 n 种硬币凑成金额为 amount 的组合数
        return dp[n][amount];
    }
}

// 一维动态规划(滚动数组思想)
class P518_Solution {
    public int change(int amount, int[] coins) {
        // 特殊情况处理
        if (amount == 0) {
            return 1;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return 1;
            } else {
                return 0;
            }
        }

        // 一维动态规划
        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int i = 1; i < n + 1; i++) {
            for (int j = coins[i - 1]; j < amount + 1; j++) {
                dp[j] += dp[j - coins[i - 1]];
            }
        }

        // 最终 dp[amount] 就为 n 种硬币凑成金额为 amount 的组合数
        return dp[amount];
    }
}
```



#### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

##### 深度优先搜索（递归实现）

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 为二叉树中结点总数。我们需要遍历每一个结点。
>
>
> - 空间复杂度：O(n)。在最坏情况下， 当树为线性二叉树（即所有结点都只有左子结点或没有结点）时，树的高度为 n - 1，在递归时我们需要存储 n 个结点。
>

```java
class P563_Solution {

    int tilt = 0;

    public int findTilt(TreeNode root) {
        if (root == null) {
            return 0;
        }

        getTreeSum(root);

        return tilt;
    }

    public int getTreeSum1(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int leftTreeSum = 0;
        int rightTreeSum = 0;

        if (node.left != null) {
            // 左子树的和
            leftTreeSum = getTreeSum(node.left);

        }
        if (node.right != null) {
            // 右子树的和
            rightTreeSum = getTreeSum(node.right);

        }
        // tilt 加上 node 结点的坡度, 遍历完所有结点, tilt 就是整棵树的坡度
        tilt += Math.abs(leftTreeSum - rightTreeSum);

        // 返回值是 node 这棵树的所有结点值的和
        return leftTreeSum + rightTreeSum + node.val;
    }

    // 代码简化
    public int getTreeSum(TreeNode node) {
        if (node == null) {
            return 0;
        }
        // 左子树的和
        int leftTreeSum = getTreeSum(node.left);

        // 右子树的和
        int rightTreeSum = getTreeSum(node.right);

        // tilt 加上 node 结点的坡度, 遍历完所有结点, tilt 就是整棵树的坡度
        tilt += Math.abs(leftTreeSum - rightTreeSum);

        // 返回值是 node 这棵树的所有结点值的和
        return leftTreeSum + rightTreeSum + node.val;
    }
}
```

#### [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)

##### 贪心算法

```java
// 堆(优先队列) + 贪心算法
class P630_Solution {
    public int scheduleCourse(int[][] courses) {
        // 以截止时间 lastDay 排序
        // Arrays.sort(courses, (a, b) -> a[1] - b[1]);
        Arrays.sort(courses, Comparator.comparingInt(a -> a[1]));

        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a);
        // 优先队列中所有课程的总时间
        int total = 0;
        // duration, lastDay;
        int ti, di;
        for (int[] course : courses) {
            ti = course[0];
            di = course[1];
            // 假设此时队列中已有 k 门课程, 这 k 门课程总学习时间为 total
            if (total + ti <= di) {
                // 如果要将课程 i 添加进队列, 那么这 k+1 门课程的总学习时间(total + ti)则不能超过课程 i 的截止时间
                // 如果满足此条件, 说明可以将课程 i 添加进队列
                // 更新这总学习时间 total = total + ti;
                total += ti;
                queue.offer(ti);
            } else if (!queue.isEmpty() && queue.peek() > ti) {
                // 如果要将课程 i 添加进队列, 而总学习时间(total + ti)超过了课程 i 的截止时间
                // 说明课程 i 不能这样直接添加进队列, 使得队列中有 k+1 门课程
                // 此时需要判断如果队列中(k 门课程中)需要耗时学习时间最多的课程(设为 x)的学习时间比课程 i 学习时间多
                // 那么我们可以贪心地将这两门课程交换, 也就是将这课程 x 从队列中取出, 将课程 i 添加队列, 形成新的 k 门课程组合
                // 此时这新的 k 门课程组合的总的学习时间(total - tx + ti) 肯定小于 d(i-1) , 也小于等于 di
                // 即此时的新的 k 门课程组合比之上一次的 k 门课程组合, 不仅总学习时间减少, 连截至时间也延长了, 也就更有可能学习更多的课程
                total -= queue.poll() - ti;
                queue.offer(ti);
            }
        }
        // 最后队列的大小, 即为最多可以修读的课程数目
        return queue.size();
    }
}
```



#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

##### 动态规划

> **复杂度分析**
>
> - 时间复杂度：O(n^2)，其中 *n* 是数组 *nums* 的长度。
> - 空间复杂度：O(n)。

```java
// 动态规划
class P673_Solution1 {
    // 动态规划
    public int findNumberOfLIS0(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 最长递增子序列的长度
        int maxLen = 1;
        // 最长递增子序列的个数
        int maxNum = 1;
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的长度
        int[] dp = new int[n];
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的个数
        int[] cnt = new int[n];
        // 赋初值: 以 nums[0] 结尾的最长子序列的长度为 1
        dp[0] = 1;
        // 赋初值: 以 nums[0] 结尾的最长子序列的个数为 1
        cnt[0] = 1;
        // 从 i == 1 开始
        for (int i = 1; i < n; i++) {
            // 在 [0,i) 之间找到比当前 nums[i] 小的那个数, 假设有 x 个这样的数
            // 那么 dp[i] 也就等于以这 x 个这样的数结尾的最长子序列长度的最大值 + 1
            // 也就是找到一条 i 之前的最长子序列, 并且该最长子序列的结尾值要 nums[j] < nums[i]
            // 那么现在加上 nums[i] 这个数, 就有了一条以 nums[i] 结尾的最长子序列
            // 同时也知道了其长度值, 更新 dp[i]
            // 那么当循环结束时, 就知道了以这 n 个数结尾的最长子序列的长度, 最长长度就很轻松就能得到

            // 而这最长长度的子序列有多少个呢?
            // 不就是遍历 dp数组, 找到 dp[i] 等于 maxLen 的个数吗?
            // 以上这两行的想法是错误的

            // 以上讨论的是找得到的情况, 如果找不到呢?
            // 找不到不就说明当前 nums[i] 是 [0,i] 之间这 i + 1 个数中的最大值吗?
            // 那么 nums[i] 就成为了一条新的子序列的开头(也即末尾), 当前序列长度就为 1 了
            // 故在查找前, 先令其为 1, 后续如果找到, 肯定值比 1 大

            // 以 nums[i] 结尾的最长子序列的长度为 1
            dp[i] = 1;
            // 以 nums[i] 结尾的最长子序列的个数为 1
            cnt[i] = 1;
            for (int j = 0; j < i; j++) {
                // 如果是非严格单调递增, 改为 <= 即可
                if (nums[j] < nums[i]) {
                    // dp[i] = Math.max(dp[i], dp[j] + 1);
                    // 如果 dp[j] + 1 > dp[i], 说明以 nums[j] 结尾的这条序列的长度更长
                    // 更新此可最大长度 dp[i] 为 dp[j] + 1;
                    // 以 nums[i] 结尾的最长子序列的个数 cnt[i] 也就是 以 nums[j] 结尾的最长子序列的个数 cnt[j];
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        cnt[i] = cnt[j];
                    } else if (dp[j] + 1 == dp[i]) {
                        // 如果又遇到 cnt[j] 条长度为 dp[j](dp[j] == dp[i] - 1) 的最长子序列
                        // 那么说明现在又多了 cnt[j] 条以 nums[j] 结尾的不同序列 加上 nums[i] 能得到
                        // 长度为 dp[i] == dp[j] + 1 的以 nums[i] 结尾的子序列
                        // 更新 cnt[i] 值
                        cnt[i] += cnt[j];
                    }
                }
            }

            // 每次得到以 nums[i] 结尾的最长子序列长度及其序列条数, 就与之前的 maxLen 比较
            // 得到 [0,i] 之间以这 i + 1 个数结尾的最长子序列长度中的最大值以及有当前最长长度 maxLen 的子序列的条数
            // 以 nums[i] 结尾的子序列的长度比曾经的 maxLen 大, 更新 maxLen 为 dp[i]
            // 更新 maxNum 为 cnt[i], 表示当前有最长长度 maxLen 的子序列的条数
            // maxLen = Math.max(maxLen, dp[i]);
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                maxNum = cnt[i];
            } else if (dp[i] == maxLen) {
                // 如果刚好相等, 说明又多了 cnt[j] 种不同方式(不同条序列), 也能得到长度为 maxLen 的子序列
                maxNum += cnt[i];
            }
        }

        // System.out.println(Arrays.toString(dp));
        return maxNum;
    }

    // 动态规划
    // 循环遍历从 0 开始, 有些初值就不需要特殊赋值了
    // 也是 官方写法
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 最长递增子序列的长度
        int maxLen = 0;
        // 最长递增子序列的个数
        int maxNum = 0;
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的长度
        int[] dp = new int[n];
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的个数
        int[] cnt = new int[n];
        // 从 i == 0 开始
        for (int i = 0; i < n; i++) {
            // 在 [0,i) 之间找到比当前 nums[i] 小的那个数, 假设有 x 个这样的数
            // 那么 dp[i] 也就等于以这 x 个这样的数结尾的最长子序列长度的最大值 + 1
            // 也就是找到一条 i 之前的最长子序列, 并且该最长子序列的结尾值要 nums[j] < nums[i]
            // 那么现在加上 nums[i] 这个数, 就有了一条以 nums[i] 结尾的最长子序列
            // 同时也知道了其长度值, 更新 dp[i]
            // 那么当循环结束时, 就知道了以这 n 个数结尾的最长子序列的长度, 最长长度就很轻松就能得到

            // 而这最长长度的子序列有多少个呢?
            // 不就是遍历 dp数组, 找到 dp[i] 等于 maxLen 的个数吗?
            // 以上这两行的想法是错误的

            // 以上讨论的是找得到的情况, 如果找不到呢?
            // 找不到不就说明当前 nums[i] 是 [0,i] 之间这 i + 1 个数中的最大值吗?
            // 那么 nums[i] 就成为了一条新的子序列的开头(也即末尾), 当前序列长度就为 1 了
            // 故在查找前, 先令其为 1, 后续如果找到, 肯定值比 1 大

            // 以 nums[i] 结尾的最长子序列的长度为 1
            dp[i] = 1;
            // 以 nums[i] 结尾的最长子序列的个数为 1
            cnt[i] = 1;
            for (int j = 0; j < i; j++) {
                // 如果是非严格单调递增, 改为 <= 即可
                if (nums[j] < nums[i]) {
                    // dp[i] = Math.max(dp[i], dp[j] + 1);
                    // 如果 dp[j] + 1 > dp[i], 说明以 nums[j] 结尾的这条序列的长度更长
                    // 更新此可最大长度 dp[i] 为 dp[j] + 1;
                    // 以 nums[i] 结尾的最长子序列的个数 cnt[i] 也就是 以 nums[j] 结尾的最长子序列的个数 cnt[j];
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        cnt[i] = cnt[j];
                    } else if (dp[j] + 1 == dp[i]) {
                        // 如果又遇到 cnt[j] 条长度为 dp[j](dp[j] == dp[i] - 1) 的最长子序列
                        // 那么说明现在又多了 cnt[j] 条以 nums[j] 结尾的不同序列 加上 nums[i] 能得到
                        // 长度为 dp[i] == dp[j] + 1 的以 nums[i] 结尾的子序列
                        // 更新 cnt[i] 值
                        cnt[i] += cnt[j];
                    }
                }
            }

            // 每次得到以 nums[i] 结尾的最长子序列长度及其序列条数, 就与之前的 maxLen 比较
            // 得到 [0,i] 之间以这 i + 1 个数结尾的最长子序列长度中的最大值以及有当前最长长度 maxLen 的子序列的条数
            // 以 nums[i] 结尾的子序列的长度比曾经的 maxLen 大, 更新 maxLen 为 dp[i]
            // 更新 maxNum 为 cnt[i], 表示当前有最长长度 maxLen 的子序列的条数
            // maxLen = Math.max(maxLen, dp[i]);
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                maxNum = cnt[i];
            } else if (dp[i] == maxLen) {
                // 如果刚好相等, 说明又多了 cnt[j] 种不同方式(不同条序列), 也能得到长度为 maxLen 的子序列
                maxNum += cnt[i];
            }
        }

        // System.out.println(Arrays.toString(dp));
        return maxNum;
    }
}
```

##### 贪心 + 前缀和 + 二分查找

> 待后续

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> 求所有岛屿中的最大内接矩形面积 怎么做？

##### 深度优先搜索（递归实现）

> 应该被叫做递归实现？

```java
// 深度优先搜索
class P695_Solution {
    int[][] grid;

    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int maxArea = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    maxArea = Math.max(maxArea, dfs(i, j));
                }
            }
        }
        return maxArea;
    }

    public int dfs(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return 0;
        }
        // 如果该格子不是土地或者已经访问过, return 0;
        if (grid[i][j] != 1) {
            return 0;
        }
        // 标记为已访问
        grid[i][j] = 2;
        // 当前土地的面积为 1
        int area = 1;
        // 返回上下左右相邻的土地的面积
        area += dfs(i - 1, j);
        area += dfs(i + 1, j);
        area += dfs(i, j - 1);
        area += dfs(i, j + 1);
        return area;
    }
}
```

##### 深度优先搜索（栈实现）

> 参考官方

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索
class P695_Solution1 {
    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int maxArea = 0;
        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    Queue<Integer> queue = new LinkedList<>();
                    queue.add(i * n + j);
                    // 标记为已访问
                    grid[i][j] = 2;
                    // 当前面积为 1
                    area = 1;
                    int id, row, col;
                    while (!queue.isEmpty()) {
                        id = queue.poll();
                        row = id / n;
                        col = id % n;
                        // 上
                        if (row - 1 >= 0 && grid[row - 1][col] == 1) {
                            queue.add(id - n);
                            grid[row - 1][col] = 2;
                            area++;
                        }
                        // 下
                        if (row + 1 < m && grid[row + 1][col] == 1) {
                            queue.add(id + n);
                            grid[row + 1][col] = 2;
                            area++;
                        }
                        // 左
                        if (col - 1 >= 0 && grid[row][col - 1] == 1) {
                            queue.add(id - 1);
                            grid[row][col - 1] = 2;
                            area++;
                        }
                        // 右
                        if (col + 1 < n && grid[row][col + 1] == 1) {
                            queue.add(id + 1);
                            grid[row][col + 1] = 2;
                            area++;
                        }
                    }
                    // 当前遍历到的岛屿的最大面积
                    maxArea = Math.max(maxArea, area);
                }
            }
        }
        return maxArea;
    }
}
```



#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

##### 2021.10.24

```java
class P739_Solution {
    // (1)我的暴力解法 时间复杂度 O(n^2) 空间复杂度 O(1)
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        for (int i = 0; i < len - 1; i++) {
            for (int j = i; j < len; j++) {
                // 找到一个比 temperatures[i] 大的值, 令 temperatures[i] 为距离
                if (temperatures[i] < temperatures[j]) {
                    temperatures[i] = j - i;
                    break;
                }
                // 当比较到最后一个值都比 temperatures[i] 值小, 用 0 代替
                if (j == len - 1) {
                    temperatures[i] = 0;
                }
            }
        }
        // 最后一个值最后肯定为 0
        temperatures[len - 1] = 0;
        return temperatures;
    }

    // (2)官方答案的暴力解法 时间复杂度 O(n^m) 空间复杂度 O(1), m 是数组 next 的长度
    public int[] dailyTemperatures1(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        int[] next = new int[101];
        Arrays.fill(next, Integer.MAX_VALUE);
        // 从最后一个元素往前遍历
        for (int i = len - 1; i >= 0; i--) {
            int index = Integer.MAX_VALUE;
            // 每次遍历都要遍历完所有比该温度值更大的温度可能第一次出现的位置, 取其中的最小值为 index
            for (int j = temperatures[i] + 1; j < next.length; j++) {
                if (next[j] < index) {
                    index = next[j];
                }
            }
            // 当 index < Integer.MAX_VALUE 时, 说明有比 temperatures[i] 更大的温度值, 且此时距离 temperatures[i] 最近
            if (index < Integer.MAX_VALUE) {
                ans[i] = index - i;
            } else {
                ans[i] = 0;
            }
            // 更新 i 为此温度值为第一次出现的下标
            next[temperatures[i]] = i;
        }
        return ans;
    }

    // (3)官方答案的单调栈解法(最优解法) 时间复杂度 O(n) 空间复杂度 O(n)
    public int[] dailyTemperatures2(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        // stack 栈中保存的是当前尚未找到更大的温度值的该温度值的下标
        // stack 中栈底到栈顶的各个下标对应的温度是递减的
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            int temperature = temperatures[i];
            // 当当前温度大于了栈顶的温度, 就说明之前的小的温度找到了一个离它最近的比它大的温度
            while (!stack.isEmpty() && temperature > temperatures[stack.peek()]) {
                int prevIndex = stack.poll();
                ans[prevIndex] = i - prevIndex;
            }
            // 当前温度的下标进栈
            stack.push(i);
        }
        return ans;
    }
}
```

#### [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

##### 动态规划

```java
// 动态规划
// 时间复杂度：O(N+M), 其中 N 是数组 nums 的长度, M 是 nums 中元素的最大值
// 空间复杂度：O(M)
class P740_Solution1 {
    public int deleteAndEarn(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        } else if (nums.length == 1) {
            return nums[0];
        }
        // 得到整个 nums 数组中的最大值
        int maxVal = 0;
        for (int num : nums) {
            maxVal = Math.max(maxVal, num);
        }
        // 创建 maxVal + 1 大小的数组, 保存 nums 中值等于 num 的所有数据的总和到 sum[num] 中
        int[] sum = new int[maxVal + 1];
        for (int num : nums) {
            sum[num] += num;
        }

        // 原问题就等价于 P198 打家劫舍 问题
        return rob(sum);
    }

    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[3];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[2] = Math.max(dp[0] + nums[i], dp[1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 若 return dp[2];
        // [1,1,1]、[1,1,1,1] 此测试用例不能通过
        // 即要保证 nums 的长度大于 3 或者给 dp[2] 赋初值等于 dp[1] 时, 才能 return dp[2];
        return dp[1];
    }
}

// 排序 + 动态规划 (先不做)
```



#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

##### 动态规划

```java
class P746_Solution {
    // 我的解法, 感觉还是我的好理解些
    public int minCostClimbingStairs(int[] cost) {
        // 初始化 dp[2] 为 0 或者 Math.min(cost[0], cost[1]) 均可,
        // 若初始化为 后者, 则 return 语句返回的是 Math.min(dp[0], dp[2]);
        int[] dp = new int[]{cost[0], cost[1], 0};
        // 达到第 i 个阶梯最低花费
        for (int i = 2; i < cost.length; i++) {
            // dp[2] 表示要达到第 i 个阶梯的最低花费(i 是下标), 它等于
            // 达到(第 i - 2 个阶梯的最低花费(dp[0]) 与 第 i - 1 个阶梯的最低花费(dp[1])中的较小值) + 达到第 i 个阶梯的花费(cost[i])
            dp[2] = Math.min(dp[0], dp[1]) + cost[i];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 最后结束时, dp[1] 与 dp[2] 为达到最后一个(n - 1)阶梯的最低花费,
        // dp[0] 为达到第 n - 2 个阶梯的最低花费
        // 故最后返回 dp[0] 与 dp[1] 的较小值
        return Math.min(dp[0], dp[1]);
    }

    // 思维方式有些变化, 等同于官方答案
    public int minCostClimbingStairs1(int[] cost) {
        // dp[] 不需要初始化
        int[] dp = new int[]{0, 0, 0};
        for (int i = 2; i <= cost.length; i++) {
            dp[2] = Math.min(dp[0] + cost[i - 2], dp[1] + cost[i - 1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
}
```

#### [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/)

##### 暴力解法

> 见官方，会超时

##### 深度优先搜索（递归实现）

###### 第一种实现

```java
// 深度优先搜索(递归实现)
class P827_Solution {
    int[][] grid;
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    // 保存 grid 中各岛屿的编号 id 及其对应面积 area
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 保存当前(i, j)坐标水域上下左右相邻的陆地的编号
    Set<Integer> hashSet = new HashSet<>();

    public int largestIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int m = grid.length;
        int n = grid[0].length;
        // 最终结果, 最大岛屿面积
        int maxArea = 0;
        // 一个岛屿的面积
        int area;
        // 所有水域的面积和, 不影响最终结果, 只为减少循环次数
        int waterArea = m * n;
        // 岛屿编号, 从 2 号开始
        int id = 2;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 得到编号为 id 的岛屿的面积
                    // dfs 过程中会将属于这个岛屿的陆地("1")全部变为岛屿的 id
                    area = dfs(i, j, id);
                    // 将 (id, area) 加入到 map 中
                    hashmap.put(id, area);
                    maxArea = Math.max(maxArea, area);
                    // System.out.println("area : " + area + ", id : " + id + ", maxArea : " + maxArea);
                    waterArea -= area;
                    id++;
                }
            }
        }
        if (maxArea == 0) {
            return 1;
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    // 将当前(i, j)坐标水域变为陆地
                    mergeIsland(i, j);
                    // 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
                    area = getMergedArea();
                    // 比较得到当前所有合并后的岛屿的最大面积
                    maxArea = Math.max(maxArea, area);
                    waterArea--;
                    if (waterArea == 0) {
                        break;
                    }
                }
            }
            if (waterArea == 0) {
                break;
            }
        }
        return maxArea;
    }

    /**
     * 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
     *
     * @return area
     */
    public int getMergedArea() {
        // 表示转变这个水域为陆地, 其面积为 1
        int area = 1;
        // 取出相邻的陆地编号, hashMap 中得到编号为 idNum 的岛屿的面积, 并累加
        for (Integer idNum : hashSet) {
            area += hashmap.get(idNum);
        }
        hashSet.clear();
        return area;
    }

    /**
     * 将当前(i, j)坐标水域上下左右相邻的陆地的编号(大于0)加入到 hashSet 中
     * 如果相邻为水域则不加入, 不做任何操作
     *
     * @param i 当前水域的横坐标
     * @param j 当前水域的纵坐标
     */
    public void mergeIsland(int i, int j) {
        int x, y;
        for (int k = 0; k < 4; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (inGrid(x, y) && grid[x][y] > 0) {
                hashSet.add(grid[x][y]);
            }
        }
    }

    /**
     * 得到得到编号为 id 的岛屿的面积, 并将相应值改为 id
     *
     * @param i  格子的横坐标
     * @param j  格子的纵坐标
     * @param id 岛屿的编号
     * @return area 该 id 岛屿的面积
     */
    public int dfs(int i, int j, int id) {
        if (inGrid(i, j) && grid[i][j] == 1) {
            grid[i][j] = id;
            int x, y;
            int area = 1;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                area += dfs(x, y, id);
            }
            return area;
        }
        return 0;
    }

    /**
     * 判断坐标 (x, y) 是否在网格中
     *
     * @param x 格子的横坐标
     * @param y 格子的纵坐标
     * @return true 在网格中; false 不在网格中, 超出边界
     */
    public boolean inGrid(int x, int y) {
        return inGridX(x) && inGridY(y);
    }

    public boolean inGridX(int x) {
        return x >= 0 && x < grid.length;
    }

    public boolean inGridY(int y) {
        return y >= 0 && y < grid[0].length;
    }
}
```

###### 第二种实现

> 本以为在第一种实现的基础上减少了循环次数，但是在LeetCode上执行的效率却没有第一种的高

```java
// 深度优先搜索(递归实现)
// 本想着优化上方式的循环次数, 但是在 LeetCode 上执行的效率却不及前者
class P827_Solution1 {
    int[][] grid;
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    // 保存 grid 中各岛屿的编号 id 及其对应面积 area
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 保存当前(i, j)坐标水域上下左右相邻的陆地的编号
    Set<Integer> hashSet = new HashSet<>();
    // 保存格子为水域的横纵坐标, 以 waterId(waterId = i * n + j) 的单个整数的方式保存为一个集合
    Set<Integer> waterSet = new HashSet<>();

    public int largestIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int m = grid.length;
        int n = grid[0].length;
        // 最终结果, 最大岛屿面积
        int maxArea = 0;
        // 一个岛屿的面积
        int area;
        // 岛屿编号, 从 2 号开始
        int id = 2;
        // 1.遍历 grid[][], 得到所有岛屿及其面积并编号
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 得到编号为 id 的岛屿的面积
                    // dfs 过程中会将属于这个岛屿的陆地("1")全部变为岛屿的 id
                    area = dfs(i, j, id);
                    // 将 (id, area) 加入到 map 中
                    hashmap.put(id, area);
                    // maxArea = Math.max(maxArea, area);
                    // System.out.println("area : " + area + ", id : " + id + ", maxArea : " + maxArea);
                    id++;
                } else if (grid[i][j] == 0) {
                    // 将水域加入 waterSet
                    waterSet.add(i * n + j);
                }
            }
        }

        // 可提前结束执行的一些特殊情况, 可删除, 删除后不影响最终结果
        // 全为陆地, 或者只有一块水域, return m * n
        int size = waterSet.size();
        if (size == 0 || size == 1) {
            return m * n;
        } else if (size == m * n) {
            // 全为水域, return 1
            return 1;
        }
        // 存在水域, 但只有一个岛屿, 返回 2 号岛屿的面积 + 1
        if (hashmap.size() == 1) {
            return hashmap.get(2) + 1;
        }

        // 2.遍历每个水域, 得到各个水域变为陆地后, 将多个岛屿连接后形成的整块大岛屿的面积
        for (Integer waterId : waterSet) {
            // 如果当前(i, j)坐标水域变为陆地
            mergeIsland(waterId / n, waterId % n);
            // 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
            area = getMergedArea();
            // 比较得到当前所有合并后的岛屿的最大面积
            maxArea = Math.max(maxArea, area);
        }
        return maxArea;
    }

    /**
     * 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
     *
     * @return area
     */
    public int getMergedArea() {
        // 表示转变这个水域为陆地, 其面积为 1
        int area = 1;
        // 取出相邻的陆地编号, hashMap 中得到编号为 idNum 的岛屿的面积, 并累加
        for (Integer idNum : hashSet) {
            area += hashmap.get(idNum);
        }
        hashSet.clear();
        return area;
    }

    /**
     * 将当前(i, j)坐标水域上下左右相邻的陆地的编号(大于0)加入到 hashSet 中
     * 如果相邻为水域则不加入, 不做任何操作
     *
     * @param i 当前水域的横坐标
     * @param j 当前水域的纵坐标
     */
    public void mergeIsland(int i, int j) {
        int x, y;
        for (int k = 0; k < 4; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (inGrid(x, y) && grid[x][y] > 0) {
                hashSet.add(grid[x][y]);
            }
        }
    }

    /**
     * 得到得到编号为 id 的岛屿的面积, 并将相应值改为 id
     *
     * @param i  格子的横坐标
     * @param j  格子的纵坐标
     * @param id 岛屿的编号
     * @return area 该 id 岛屿的面积
     */
    public int dfs(int i, int j, int id) {
        if (inGrid(i, j) && grid[i][j] == 1) {
            grid[i][j] = id;
            int x, y;
            int area = 1;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                area += dfs(x, y, id);
            }
            return area;
        }
        return 0;
    }

    /**
     * 判断坐标 (x, y) 是否在网格中
     *
     * @param x 格子的横坐标
     * @param y 格子的纵坐标
     * @return true 在网格中; false 不在网格中, 超出边界
     */
    public boolean inGrid(int x, int y) {
        return inGridX(x) && inGridY(y);
    }

    public boolean inGridX(int x) {
        return x >= 0 && x < grid.length;
    }

    public boolean inGridY(int y) {
        return y >= 0 && y < grid[0].length;
    }
}
```

##### 并查集

> 见评论区

#### [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

##### 回溯（最优解法）

```java
// 回溯(最优解法)
class P980_Solution {
    private int[][] grid;

    public int uniquePathsIII(int[][] grid) {
        this.grid = grid;
        // 开始位置
        int startX = 0, startY = 0;
        // stepNum 表示 grid 中 0 的个数 + 找到 2 时这最后一步, 每经过一个 0 自减, 找到 2 时, stepNum 为 0
        int stepNum = 1;
        // 遍历 grid 得到起始位置 和 总步数
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 0) {
                    stepNum++;
                } else if (grid[i][j] == 1) {
                    startX = i;
                    startY = j;
                }
            }
        }
        return dfs(startX, startY, stepNum);
    }

    public int dfs(int x, int y, int step) {
        // 遍历到边界, 返回 0
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {
            return 0;
        }
        // grid[x][y] 是障碍(为 -1 时)或者已经访问过(为 3 时), 返回 0
        if (grid[x][y] == -1 || grid[x][y] == 3) {
            return 0;
        }
        // 找到结束方格, 但是如果此时(此路径)并没有访问完所有的 0 方格, 则还是认为没有找到满足题意的一条路径
        if (grid[x][y] == 2) {
            return step == 0 ? 1 : 0;
        }
        // 能执行到这里表示 grid[x][y] == 0, 将其置为 3, 表示正在访问或者已经访问过该方格, 在回溯时再将其置为 0
        grid[x][y] = 3;
        // path 表示之前已经访问过若干个 0 方格, 现从此方格开始能访问完所有剩余 0 方格, 并且最终能访问到结束方格的路径数
        // 任何一个从当前方格能够访问到结束方格的路径数等于该方格"上下左右"这四个方格访问到结束方格的路径数的总和
        int path = 0;
        // 按照左上右下的顺序遍历
        path += dfs(x, y - 1, step - 1);
        path += dfs(x - 1, y, step - 1);
        path += dfs(x, y + 1, step - 1);
        path += dfs(x + 1, y, step - 1);
        // 回溯时将其置为 0
        grid[x][y] = 0;
        return path;
    }
}
```

##### 深度优先搜索（递归实现） + 动态规划（状态压缩 DP）

```java
// 2021.12.21
// DFS + 动态规划(状态压缩 DP)
// 由于此题范围为 1 <= grid.length * grid[0].length <= 20
// 可以使用 DFS 结合 状态压缩 DP 来解答此题
// 将在某点处还要走多少个无防碍方格(步数)改为在某点处的状态(id, state)来记录
// 无论时间还是空间, 效率均远远不及上面的回溯方法
class P980_Solution1 {
    int[][] grid;
    int m;
    int n;
    // 右上左下
    int[] dx = new int[]{0, -1, 0, 1};
    int[] dy = new int[]{1, 0, -1, 0};
    // 记录状态
    // int[][] dp; // 220ms, 这种方式涉及到给 dp 数组全体赋值 -1 效率降低 for (int[] row : dp) { Arrays.fill(row, -1); }
    Integer[][] dp; // 82ms 两者空间消耗差不多, 但是是上一种方法的 6 倍左右

    public int uniquePathsIII(int[][] grid) {
        this.grid = grid;
        this.m = this.grid.length;
        this.n = this.grid[0].length;
        // 开始位置
        int startX = 0, startY = 0;

        // 上个方法中的 stepNum 等于 target 的二进制表示中 1 的个数
        int target = 0;
        // 遍历 grid 得到起始位置 和 总步数
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 要走的格子
                if (grid[i][j] % 2 == 0) {
                    target |= code(i, j);
                } else if (grid[i][j] == 1) {
                    // 起点
                    startX = i;
                    startY = j;
                }
            }
        }
        dp = new Integer[m * n][1 << m * n];
        return dfs(startX, startY, target);
    }

    public Integer dfs(int x, int y, int togo) {
        // 如果走到该空格时的这种状态曾经遍历过, 那么直接返回其值
        // 可以将这个判断改变一下放在 for 中
        int id = x * n + y;
        if (dp[id][togo] != null) {
            return dp[id][togo];
        }

        // 找到结束方格, 但是如果此时(此路径)并没有访问完所有的 0 方格, 则还是认为没有找到满足题意的一条路径
        if (grid[x][y] == 2) {
            return togo == 0 ? 1 : 0;
        }

        // path 表示之前已经访问过若干个 0 方格, 现从此方格开始能访问完所有剩余 0 方格, 并且最终能访问到结束方格的路径数
        // 任何一个从当前方格能够访问到结束方格的路径数等于该方格"上下左右"这四个方格访问到结束方格的路径数的总和
        int path = 0;

        // 按照右上左下的顺序遍历
        for (int k = 0; k < 4; k++) {
            int newX = x + dx[k];
            int newY = y + dy[k];
            // 这两个条件也可以放在 dfs 执行开始处
            // 边界条件: 要走的格子在区域内才能走
            if (newX >= 0 && newX < m && newY >= 0 && newY < n) {
                int possibleTogo = code(newX, newY);
                // togo 是还未走过的(剩下要走的)所有空格的一个二进制集合表示, possibleTogo 是 (newX, newY) 方格的一种二进制表示
                // (newX, newY) 可能走, 可能不走
                // 如果 (newX, newY) 处是起始点或者是障碍物点则不走它, 此时 togo & possibleTogo == 0
                // 如果 (newX, newY) 处是空格, 但是该空格曾经走过了, 也就是点 (newX, newY) 在从起点到点 (x,y) 的路径中了
                // 现在不能再从该点 (x,y) 走到点 (newX, newY) 了, 这样就重复走点 (newX, newY)了
                // 此时 togo & possibleTogo == 0

                // 假设 togo == 1010 1010 表示从(x, y)还要走这四个空格
                // 1.起点情况——起点的二进制表示是 0000 0001, 刚好 (newX, newY) 也是起点, togo & possibleTogo == 0, 起点不能走
                // 2.障碍物情况——如果 (newX, newY) 的二进制表示是 0000 0100, 说明该点是已经走过的空格, togo 中已经不包含这个空格了
                // 此时 togo & possibleTogo 也等于 0
                // 3.空格情况——如果 (newX, newY) 的二进制表示是 0000 1000, togo & possibleTogo == 0000 1000 != 0
                // 表示该空格在 togo 要走的空格集合中, 那么下一次就尝试走这个空格
                // 并将这个空格 (newX, newY) 从 togo 从删除, 表示从空格 (newX, newY) 出发去走新 togo 中的空格集合
                // 新的 togo 为 原togo ^ possibleTogo, 此例中则为 1010 1010 ^ 0000 1000 == 1010 0010, 即将相应位置变为 0

                // 返回能通过 (newX, newY) 走 新todo 走到终点的路径数
                if ((togo & possibleTogo) != 0) {
                    path += dfs(newX, newY, togo ^ possibleTogo);
                }
                // 其实吧, 这里就等于是把曾经的 dfs 中的判断 grid[x][y] 为 -1 3 0 等影响是否继续遍历的情况放在了此处, 用状态来代替了
            }
        }

        // 从该点走到终点的所有情况已经得到了, 记录其值
        dp[id][togo] = path;
        return path;
    }

    public int code(int x, int y) {
        return 1 << (x * n + y);
    }
}
```



#### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

##### 深度优先搜索（递归实现）

###### 第一种实现

> 曾经的常规思路

```java
// 深度优先搜索（递归实现）
class P1020_Solution {
    int[][] grid;
    int m;
    int n;
    int numOfEnclaves;
    boolean flag;

    public int numEnclaves(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        if (m == 0) {
            return 0;
        }
        this.n = grid[0].length;
        this.numOfEnclaves = 0;

        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 默认是一个封闭岛屿(无法走出)
                    flag = true;
                    // 该岛屿的面积
                    area = dfs(i, j);
                    if (flag) {
                        // 如果是, 加上这些格子的数量(岛屿面积)
                        numOfEnclaves += area;
                    }
                }
            }
        }

        return numOfEnclaves;
    }

    public int dfs(int i, int j) {
        // 边界条件
        if (i < 0 || i >= m || j < 0 || j >= n) {
            flag = false;
            return 0;
        }

        // 是水域或者曾经遍历过, 跳过遍历
        if (grid[i][j] == 0 || grid[i][j] == 2) {
            return 0;
        }

        grid[i][j] = 2;

        // 上左下右
        return 1 + dfs(i - 1, j)
                + dfs(i, j - 1)
                + dfs(i + 1, j)
                + dfs(i, j + 1);
    }
}
```

###### 第二种实现

> 针对本地，可以换种思考方式，先将与四周边界相连的陆地遍历后，最后grid中还为1的陆地总数即为答案
>
> 三种实现中效率最高

```java
// 深度优先搜索（递归实现）
// 换一种思考方式的解题思路
// 三种实现中效率最高
class P1020_Solution {
    int[][] grid;
    int m;
    int n;

    public int numEnclaves(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        if (m == 0) {
            return 0;
        }
        this.n = grid[0].length;
        int numOfEnclaves = 0;

        // 1.将与左右两边界相连的陆地去掉
        for (int i = 0; i < m; i++) {
            if (grid[i][0] == 1) {
                dfs(i, 0);
            }
            if (grid[i][n - 1] == 1) {
                dfs(i, n - 1);
            }
        }

        // 2.将与上下两边界相连的陆地去掉
        for (int j = 0; j < n; j++) {
            if (grid[0][j] == 1) {
                dfs(0, j);
            }
            if (grid[m - 1][j] == 1) {
                dfs(m - 1, j);
            }
        }

        // 3.最后遍历 grid 中为 1 的格子的数量, 即为答案
        for (int i = 1; i < m - 1; i++) {
            for (int j = 1; j < n - 1; j++) {
                if (grid[i][j] == 1) {
                    numOfEnclaves++;
                }
            }
        }

        return numOfEnclaves;
    }

    public void dfs(int i, int j) {
        // 边界条件
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return;
        }

        // 是水域或者曾经遍历过, 跳过遍历
        if (grid[i][j] == 0 || grid[i][j] == 2) {
            return;
        }

        grid[i][j] = 2;

        // 上左下右
        dfs(i - 1, j);
        dfs(i, j - 1);
        dfs(i + 1, j);
        dfs(i, j + 1);
    }
}
```

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索（队列实现）
// 效率不及 DFS
class P1020_Solution1 {
    int[] dx = new int[]{-1, 0, 1, 0};
    int[] dy = new int[]{0, -1, 0, 1};

    public int numEnclaves(int[][] grid) {
        int m = grid.length;
        if (m == 0) {
            return 0;
        }
        int n = grid[0].length;
        int numOfEnclaves = 0;

        boolean flag;
        // 每块岛屿的面积
        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 默认是一个封闭岛屿(无法走出)
                    flag = true;
                    Queue<Integer> queue = new LinkedList<>();
                    // 该个岛屿第一块陆地入队
                    queue.add(i * n + j);
                    // 标记为已访问
                    grid[i][j] = 2;
                    // 初始为 1
                    area = 1;
                    int id, x, y;
                    while (!queue.isEmpty()) {
                        id = queue.remove();
                        x = id / n;
                        y = id % n;
                        int newX, newY;
                        // 上左下右四块陆地入队
                        for (int k = 0; k < 4; k++) {
                            newX = x + dx[k];
                            newY = y + dy[k];
                            // 如果该块陆地与边界相连, 则 flag 置为 false, 表示该岛屿与边界是相连的
                            // 遍历完后, 该岛屿的面积 area 不加入 numOfEnclaves 中
                            if (newX < 0 || newX >= m || newY < 0 || newY >= n) {
                                flag = false;
                                continue;
                            }
                            // 跳过周围的四块陆地中 是水域或者已经遍历过的陆地
                            if (grid[newX][newY] == 0 || grid[newX][newY] == 2) {
                                continue;
                            }
                            // 此处 grid[newX][newY] 肯定为 1, 表示从未遍历过的陆地
                            // 将其入队, 并置为已访问 2, 面积 area 加 1
                            queue.add(newX * n + newY);
                            grid[newX][newY] = 2;
                            area++;
                        }
                    }
                    // flag 为 false 时, 表示该岛屿与边界相连, 不加上该块岛屿面积
                    if (flag) {
                        numOfEnclaves += area;
                    }
                }
            }
        }
        return numOfEnclaves;
    }
}
```



#### [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

##### 动态规划、递归

> 2021.11.03

```java
class P1137_Solution {
    // 动态规划
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        int[] dp = new int[]{0, 1, 1, 0};
        for (int i = 3; i < n + 1; i++) {
            dp[3] = dp[2] + dp[1] + dp[0];
            dp[0] = dp[1];
            dp[1] = dp[2];
            dp[2] = dp[3];
        }
        return dp[3];
    }

    // 递归
    public int tribonacci1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        return tribonacci1(n - 1) + tribonacci1(n - 2) + tribonacci1(n - 3);
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(1)

##### 矩阵快速幂

> 2021.11.03

```java
class P1137_Solution1 {
    // 快速矩阵幂
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n <= 2) {
            return 1;
        }
        int[][] q = {{1, 1, 1}, {1, 0, 0}, {0, 1, 0}};
        int[][] res = pow(q, n);
        // 此处为何返回 res[0][2], 而不是 res[2][0] + res[2][1] ?
        return res[0][2];
    }

    // n 个矩阵 a 相乘
    public int[][] pow(int[][] a, int n) {
        int[][] ret = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    // 矩阵 a 与矩阵 b 相乘
    public int[][] multiply(int[][] a, int[][] b) {
        int[][] c = new int[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
            }
        }
        return c;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(log n)
> - 空间复杂度：O(1)

> **为何返回的是 `return res[0][2]` ？**
>
> 按照方法二的公式
>
> ```reasonml
> 列矩阵【T(n+2),T(n+1),T(n)】 = n 个 M 矩阵相乘，再与列矩阵 【T(2),T(1),T(0)】(1,1,0) 相乘
> ```
>
> 最后得到的是三行一列的矩阵，T(n) 应该等于   `res[2][0]*T(2) + res[2][1]*T(1) +  res[2][2]*T(0) ` 
>
> 带入 T(2), T(1), T(0) 的值 (1,1,0)，最后  `T(n) = res[2][0] + res[2][1]`
>
> 而方法二答案最终返回的是 `res[0][2]`，是因为方法二的代码实现与文字解答不一致，`return res[0][2]` 是将公式看成了
>
> ```reasonml
> 列矩阵【T(n),T(n-1),T(n-2)】 = n 个 M 矩阵相乘，再与列矩阵 【T(0),T(-1),T(-2)】(0,0,1) 相乘
> ```
>
> 于是乎，T(n) 等于   `res[0][0]*T(0) + res[0][1]*T(-1) +  res[0][2]*T(-2) ` 
>
> 带入 T(0), T(-1), T(-2) 的值 (0,0,1)，最后   `T(n) = res[0][2]`
>
> 至于 T(-1), T(-2) 为何为 0 和 1，是因为
>
> `T(-1) = T(2) - T(1) - T(0) = 1 - 1 - 0 = 0` 
>
> `T(-2) = T(1) - T(0) - T(-1) = 1 - 0 - 0 = 1` 

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

##### 动态规划

```java
class P1143_Solution {
    // 二维动态规划
    public int longestCommonSubsequence1(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        int m = text1.length();
        int n = text2.length();

        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 两字符串的最后一个字符一样
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 为何 text1.charAt(i - 1) != text2.charAt(j - 1) 时
                    // dp[i][j] 为 (dp[i][j - 1], dp[i - 1][j]) 中的较大值?

                    // 分为两种情况

                    // 1.dp[i][j] 可以看作是以下两字符串的状态变换过来的
                    // (1) text1的前(i-1)个字符组成的字符串(记为str1{i-1}) 加上 第 i 个字符('text1.charAt(i-1)',记为 ci), 也就是text1的前 i 个字符组成的字符串
                    // (2) text2的前(j-1)个字符组成的字符串(记为str2{j-1})
                    // 而现在str2{j-1}末尾加上了这第 j 个字符('text2.charAt(j-1)',记为 cj), 这个字符与(ci)不相等, 加上后记为 str2{j}
                    // 由于多了 cj 这个字符, 那么这个最长公共子序列【可能】就变成包含这个 cj 字符(并且这个字符是最长公共子序列最后一个字符)的序列了
                    // 那么这个序列在 str1{i} 中就肯定不是以 ci 结尾的, 或者说是这个最长公共子序列是在 str1{i-1} 中找到的
                    // 也就是将【求 str1{i} 与 str2{j} 中的最长公共子序列的长度问题】变成了【求 str1{i-1} 与 str2{j} 中的最长公共子序列的长度问题】
                    // cj 可能是最长公共子序列的最后一个字符, ci 与 cj 不相等, str1 中存不存在 ci, 与 str2{j} 比较的结果都是一样的
                    // 故此时这种情况下的 dp[i][j] 其实就为 dp[i-1][j]
                    // 那如果这个最长公共子序列不包含 cj 这个尾字符呢?
                    // 那 dp[i][j] 其实就直接为 dp[i][j-1]

                    // 2.dp[i][j] 可以看作是以下两字符串的状态变换过来的
                    // (1) text1的前(i-1)个字符组成的字符串(记为str1{i-1})
                    // (2) text2的前(j-1)个字符组成的字符串(记为str2{j-1}) 加上 第 j 个字符('text2.charAt(j-1)',记为 cj), 也就是text2的前 j 个字符组成的字符串
                    // 而现在str1{i-1}末尾加上了这第 i 个字符('text1.charAt(i-1)',记为 ci), 这个字符与(cj)不相等, 加上后记为 str1{i}
                    // 由于多了 ci 这个字符, 那么这个最长公共子序列【可能】就变成包含这个 ci 字符(并且这个字符是最长公共子序列最后一个字符)的序列了
                    // 那么这个序列在 str2{j} 中就肯定不是以 cj 结尾的, 或者说是这个最长公共子序列是在 str2{j-1} 中找到的
                    // 也就是将【求 str1{i} 与 str2{j} 中的最长公共子序列的长度问题】变成了【求 str1{i} 与 str2{j-1} 中的最长公共子序列的长度问题】
                    // ci 可能是最长公共子序列的最后一个字符, cj 与 ci 不相等, str2 中存不存在 cj, 与 str1{i} 比较的结果都是一样的
                    // 故此时这种情况下的 dp[i][j] 其实就为 dp[i][j-1]
                    // 那如果这个最长公共子序列不包含 ci 这个尾字符呢?
                    // 那 dp[i][j] 其实就直接为 dp[i-1][j]

                    // 综上, 故最终得两者最大值为 dp[i][j]
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }

    // 一维动态规划(滚动数组思想)
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        int m = text1.length();
        int n = text2.length();

        if (m >= n) {
            return lengthOfLongestCommonSubsequence(text1, text2);
        } else {
            return lengthOfLongestCommonSubsequence(text2, text1);
        }
    }

    private int lengthOfLongestCommonSubsequence(String longStr, String shortStr) {
        if (longStr == null || shortStr == null) {
            return 0;
        }
        int m = longStr.length();
        int n = shortStr.length();

        int[] dp = new int[n + 1];

        int pre, temp;
        for (int i = 1; i < m + 1; i++) {
            pre = dp[0];
            for (int j = 1; j < n + 1; j++) {
                temp = dp[j];
                // 两字符串的最后一个字符一样
                if (longStr.charAt(i - 1) == shortStr.charAt(j - 1)) {
                    dp[j] = pre + 1;
                } else {
                    dp[j] = Math.max(dp[j - 1], dp[j]);
                }
                pre = temp;
            }
        }

        return dp[n];
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text 1 和 text 2 的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算。
>
> - 空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text 1和 text 2 的长度。创建了 m+1 行 n+1 列的二维数组 dp。
> - 优化过后的空间复杂度为 O(min(m,n))

#### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

##### 深度优先搜索（递归实现）

```java
// 深度优先遍历(递归实现)
class P1254_Solution {
    int m, n;

    public int closedIsland(int[][] grid) {
        if (grid == null) {
            return 0;
        }
        this.m = grid.length;
        this.n = grid[0].length;
        if (m == 2 || n == 2) {
            return 0;
        }
        
        int numOfClosedIsland = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    if (dfs(grid, i, j)) {
                        numOfClosedIsland++;
                    }
                }
            }
        }
        return numOfClosedIsland;
    }

    public boolean dfs(int[][] grid, int i, int j) {
        // 超出边界, 说明该岛屿不是封闭的, 返回 false
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return false;
        }
        // 该方格可能是水域(为 1 的情况), 或者是曾经访问过的陆地(为 2 的情况), 返回 true
        if (grid[i][j] != 0) {
            return true;
        }
        grid[i][j] = 2;
        // 上左下右遍历
        // 注意 bl 放在 && 后, 即要先 dfs 得到结果后再与 bl 进行 ‘与’ 操作
        // 当然更不能直接将这四个 dfs && 连接起来
        boolean bl = dfs(grid, i - 1, j);
        bl = dfs(grid, i, j - 1) && bl;
        bl = dfs(grid, i + 1, j) && bl;
        bl = dfs(grid, i, j + 1) && bl;
        return bl;
    }
}
```

##### 广度优先搜索（队列实现）

> 待后续补充

##### 并查集

#### [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

##### 广度优先搜索（队列实现） + 贪心算法

> [参考链接](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution/wang-ge-zhong-de-zui-duan-lu-jing-bfssuan-fa-shi-x/)
>
> 他人评论——
>
> 传统BFS：如果点A已经在visited里，那我们就不会第二次加入点A
>
> 本题：如果点A已经在visited里，但是这次我们到点A的路径上碰到的障碍物比上次少，那我们要把点A加入queue

```java
// 广度优先搜索(队列实现) + 贪心算法
class P1293_Solution {
    public int shortestPath(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        // 只有一个方格, 由于 k 是大于等于 1 的, 不管该方格是不是障碍物, 都能通过
        if (m == 1 && n == 1) {
            return 0;
        }
        // 最后一个(右下角)为障碍物, 先将其消除, k 要减 1
        if (grid[m - 1][n - 1] == 1) {
            grid[m - 1][n - 1] = 0;
            k--;
        }
        // 三维标记数组
        // visited[i][j][0] 该方格历史最优剩余能消除障碍物的次数 剩余次数越多, 越有价值(此处贪心, 记录局部最优)
        // visited[i][j][1] 该方格当前此次剩余能消除障碍物的次数
        int[][][] visited = new int[m][n][2];
        // visited[i][j][0] 初始状态为 -1, 不需要初始化 visited[i][j][1]
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited[i][j][0] = -1;
            }
        }

        // 初始化起始点(0, 0)处的 visited[0][0][0] 和 visited[0][0][1] 值为 k , 表示起始点处的
        // (历史最大消除次数 visited[0][0][0]) 和 (从当前该方格出发能够消除的次数 visited[0][0][1])
        visited[0][0][0] = k;
        visited[0][0][1] = k;
        // 构造队列
        Queue<Integer> queue = new LinkedList<>();
        // 初始化队列, 将起始点(0, 0)入队, 0 = 行号 * n + 列号
        queue.add(0);
        // 初始化最短路径步数为 0
        int minSteps = 0;
        // 四个方向
        final int[] dx = new int[]{-1, 1, 0, 0};
        final int[] dy = new int[]{0, 0, -1, 1};
        // BFS 的队列实现 + 贪心
        while (!queue.isEmpty()) {
            // 等于遍历的层数, 每进入一次 while, 表示走了一步
            minSteps++;
            // 提前获取该层需要出队多少个的个数
            // 遍历相同层级下所有节点
            int size = queue.size();
            // 当前方格的 id、横坐标、纵坐标、从该方格出发能够消除障碍的次数
            int id, curX, curY, obsNum;
            for (int i = 0; i < size; i++) {
                // 出队
                id = queue.remove();
                curX = id / n;
                curY = id % n;
                // 从该方格出发能够消除障碍的次数
                obsNum = visited[curX][curY][1];
                // 当前 id 方格相邻的四个方格的 横纵坐标
                int x, y;
                for (int j = 0; j < 4; j++) {
                    x = curX + dx[j];
                    y = curY + dy[j];
                    // 在 grid 内, 不要越界
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        // id 方格的下一步就是终点(右下角), 返回 minSteps, 此为最短路径(步数)
                        if (x == m - 1 && y == n - 1) {
                            return minSteps;
                        }
                        // 如果当该方格为障碍物, 并且到达 id 方格时还能穿越障碍物的次数已经为 0, 则不能再穿越此方格(障碍物)了
                        if (grid[x][y] == 1 && obsNum == 0) {
                            continue;
                        }
                        // 如果该方格是障碍物, 则将其变成可以通过的方格, 并更新其还能消除障碍物的次数
                        // visited[x][y][1] = grid[x][y] == 1 ? obsNum - 1 : obsNum; // 貌似不需要 newObsNum 也可以
                        int newObsNum = grid[x][y] == 1 ? obsNum - 1 : obsNum;
                        // 以下三段代码取其一, 都是正确的, 逻辑不同而已
/*                        // 1. 是第 2 段代码的简化
                        // 如果该方格已被访问过(可能该方格是障碍物, 但是可能曾经通过将其转变为可以通过的方格被访问过)
                        // 并且当前 visited 记录的历史访问该方格时剩余消除障碍物最大次数 > 当前搜索节点层级的剩余消除次数
                        // 如果将其加入队列, 也很有可能得不到更优解了
                        // 因此不更新该方格的 visited 历史值, 此方格也不加入队列, 直接进行下次循环
                        // 反之, 则更新 visited[x][y][0] 和 visited[x][y][1] 为 newObsNum, 并将该方格加入队列
                        // hi, 真是奇怪, 如果将 ">=" 改为 ">", 会出现问题
                        if (visited[x][y][0] != -1 && visited[x][y][0] >= newObsNum) {
                            continue;
                        } else {
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                        }
                        // 此处, 该方格可能曾经从未被访问过, 也可能被访问过
                        // 但是不管何种情况, visited[x][y][0] 和 visited[x][y][0] 均已在上一个 if 判断中更新
                        // 现在只需入队即可
                        //queue.add(x * n + y);*/

/*                        // 2. 比第 1 段好理解的, 但是也比第 1 段多了些重复代码
                        // 上一个 if - else 也可理解为 :
                        // 如果被访问过, 贪心一下, 看通过该方格是否有可能得到更优解, 判断方式是
                        if (visited[x][y][0] != -1) {
                            // 如果此次剩余消除次数没有以前保存的历史消除次数值大, 则认为以更小的消除次数从这个方格出发到达终点
                            // 得到的结果(最短路径步数)
                            // 也不会比以 [已经保存在 visited[x][y][0] 中的这个历史的更大消除次数值的] 这种状态的这个方格出发
                            // 到达终点得到的结果更优
                            // 于是, 不更新, 不入队, 直接下次循环
                            // 这个是大于等于还是等于差别这么大吗?
                            if (visited[x][y][0] >= newObsNum) {
                                continue;
                            } else {
                                // 反之, 如果此次的还能消除障碍的次数更大, 则可能通过该方格去尝试, 能够得到更优解
                                // 于是, 更新 visited 数组值, 并入队
                                visited[x][y][1] = newObsNum;
                                visited[x][y][0] = newObsNum;
                            }
                        } else {
                            // 如果没被访问过, 直接给 visited 数组赋值, 然后入队
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                        }
                        // 此处, 该方格可能曾经从未被访问过, 也可能被访问过
                        // 但是不管何种情况, visited[x][y][0] 和 visited[x][y][0] 均已在上一个 if 判断中更新
                        // 现在只需入队即可
                        //queue.add(x * n + y);*/

                        // 3. 这种也是对的
                        // 由于除了起始方格处的 visited[x][y][0] 值为 k, 其余各方格处的该值初始值都为 -1,
                        // 而 newObsNum 肯定是大于等于 0 的, 肯定比初始值 -1 大,
                        // 又由于需要贪心保证 visited[x][y][0] 能够成为更大值时, 才有可能得到更优解, 才更新其值以及入队
                        // 所以当遇到比 历史保存值(消除障碍数)更大的值时, 就更新该方格的 visited 值, 以及入队
                        // 如果没有, 就什么都不做
                        if (visited[x][y][0] < newObsNum) {
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                            queue.add(x * n + y);
                        }
                    }
                }
            }
        }
        // 未找到路径, 返回 -1
        return -1;
    }
}
```

##### 深度优先搜索 + 记忆化

> 原因在于第二列,在回溯后， 从(6,1)本该拆除(7,1)的障碍物, 但是实际执行时
> 由于 memo[9][1]\memo[8][1]\memo[7][1] 这三个位置在回溯(9,0)(8,0)(7,0)方格时记录值由3变为了4，
> 而当真正回溯到(6,1)时，它不会往下走(7,1)了，虽然此时的 k == 4
>
> 于是有了 if (k >= memo[i][j] || (j == n - 1 && d == 2 && memo[i - dx[d]][j - dy[d]] == memo[i][j])) {}
>
> 此行判断条件的多种情况
>

#### [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)

##### 深度优先搜索（递归实现）（超时未完成）

> 此题相当于求最短路径，使用DFS会超时

```java
// DFS, 超时, 未通过 LeetCode 所有测试
class P1368_Solution1 {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除, 已包含在 dfs 中
        if (m == 1 && n == 1) {
            return 0;
        }

        return dfs(0, 0);
    }

    private int dfs(int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return maxCost;
        }
        if (i == m - 1 && j == n - 1) {
            return 0;
        }
        if (grid[i][j] > 4) {
            return maxCost;
        }

        // 保存该方格的值, 走的方向
        int direction = grid[i][j];
        // +4, 代表已访问
        grid[i][j] += 4;
        // 初始化为最大花费
        int minCost = maxCost;

        for (int k = 0; k < 4; k++) {
            if (k == direction - 1) {
                minCost = Math.min(minCost, dfs(i + dx[k], j + dy[k]));
                if (minCost == 0) {
                    break;
                }
            } else {
                minCost = Math.min(minCost, dfs(i + dx[k], j + dy[k]) + 1);
            }
        }
        // 回溯
        grid[i][j] -= 4;
        return minCost;
    }
}
```

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索（队列实现）
class P1368_Solution3 {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost1(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        // int[][] num = new int[m][n];
        int count = 0;
        int[][] dp = new int[m][n];
        for (int[] row : dp) {
            Arrays.fill(row, maxCost);
        }
        dp[0][0] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(0);

        int id, i, j;
        while (!queue.isEmpty()) {
            id = queue.remove();
            i = id / n;
            j = id % n;
            // num[i][j]++;
            count++;
            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    minCost = dp[i][j] + (grid[i][j] == k + 1 ? 0 : 1);
                    // System.out.println(Arrays.deepToString(dp));
                    if (minCost < dp[x][y]) {
                        queue.add(x * n + y);
                        dp[x][y] = minCost;
                    }
                }
            }
        }

        // System.out.println(Arrays.deepToString(dp));
        // System.out.println(Arrays.deepToString(num));
        System.out.println(count);
        return dp[m - 1][n - 1];
    }

    // 优化-SPFA, 但是貌似效果并不明显
    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        int[][] cost = new int[m][n];
        for (int[] row : cost) {
            Arrays.fill(row, maxCost);
        }
        cost[0][0] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(0);
        // 需要记录当前(i,j)是否在队列中, 可以新建一个数组来记录, 亦或者通过改变 grid[i][j] 处的值来标记是否访问(是否在队列中)
        // 表示在队列中
        grid[0][0] += 4;

        int id, i, j;
        while (!queue.isEmpty()) {
            id = queue.remove();
            i = id / n;
            j = id % n;

            // 表示不在队列中
            grid[i][j] -= 4;

            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    // 是顺方向的没有代价(不加 1)
                    if (grid[i][j] == k + 1 || grid[i][j] == k + 5) {
                        minCost = cost[i][j];
                    } else {
                        minCost = cost[i][j] + 1;
                    }

                    // 如果要此次从 (i,j) 到 (x,y), 更新, 那么应当比曾经到 (x,y) 的代价要更小
                    // 即 minCost < cost[x][y] 时, 找到新的一条到 (x,y) 的代价更小的路径, 则需要更新其代价值
                    // 如果当前方格 (x,y) 已经在队列中, 即随后就会遍历它时, 可以不将它入队, 只需要更新其代价值
                    // 而如果不在队列中, 由于此次又更新了它的代价值(更小了), 那么就有可能通过方格(x,y) 而找到距离终点代价值更小的路径
                    // 故需要将其加入队列中

                    // 其实正常的思路是, 四个方向都应该加入队列, 但是有代价值更小以及当前队列中不需要重复遍历同一个方格
                    // 当队列中没有该方格(后续不会遍历该方格)时, 才将其加入队列
                    if (minCost < cost[x][y]) {
                        cost[x][y] = minCost;
                        if (grid[x][y] <= 4) {
                            queue.add(x * n + y);
                            // 表示在队列中
                            grid[x][y] += 4;
                        }
                    }
                }
            }
        }

        return cost[m - 1][n - 1];
    }

    private boolean inArea(int i, int j) {
        return i >= 0 && i < m && j >= 0 && j < n;
    }
}
```

##### Dijkstra 算法（优先级队列实现）（次优解法）

```java
// Dijkstra 算法(优先级队列实现)(次优解法)
class P1368_Solution4 {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        int[][] cost = new int[m][n];
        for (int[] row : cost) {
            Arrays.fill(row, maxCost);
        }
        cost[0][0] = 0;

        // 优先队列(小顶堆)
        // PriorityQueue<Node> queue = new PriorityQueue<>((n1, n2) -> n1.cost - n2.cost);
        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(n -> n.cost));
        queue.add(new Node(0, 0));

        int id, i, j;
        while (!queue.isEmpty()) {
            // 每次出队都是选择距离起点最短的节点, 遍历该节点的四个方向的节点, 更新这四个方向的节点到通过该节点到起点的距离
            // 如果找到距离起点更近的节点, 则将其添加进队列
            // 由于此队列是优先级队列, 下次出队时会自动选择能够构建最短路径的节点, 继续遍历
            id = queue.remove().id;
            i = id / n;
            j = id % n;

            // 需要记录当前(i,j)距离起点的距离最小值是否得到, 可以新建一个数组来记录, 亦或者通过改变 grid[i][j] 处的值来标记是否访问过(是否得到)
            // 如果已经访问过, 不再访问
            if (grid[i][j] > 4) {
                continue;
            }
            // 置为已经访问过, 起点(0,0)到当前节点(i,j)的距离已经在节点(i,j)添加到队列中时确定, 并且该路径是到目前为止的最短路径
            grid[i][j] += 4;

            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    // 是顺方向的没有代价(不加 1)
                    minCost = cost[i][j] + (grid[i][j] == k + 5 ? 0 : 1);

                    // 如果要此次从 (i,j) 到 (x,y), 更新, 那么应当比曾经到 (x,y) 的代价要更小
                    // 即 minCost < cost[x][y] 时, 找到新的一条到 (x,y) 的代价更小的路径, 则需要更新其代价值
                    // 并将其加入到队列中

                    if (minCost < cost[x][y]) {
                        cost[x][y] = minCost;
                        // 此处肯定 grid[x][y] <= 4
                        queue.add(new Node(x * n + y, cost[x][y]));
                    }
                }
            }
        }

        return cost[m - 1][n - 1];
    }

    private boolean inArea(int i, int j) {
        return i >= 0 && i < m && j >= 0 && j < n;
    }

    static class Node {
        int id;
        int cost;

        public Node(int id, int cost) {
            this.id = id;
            this.cost = cost;
        }

        @Override
        public String toString() {
            return "id:" + id + ", cost:" + cost;
        }
    }
}
```

##### 0-1 广度优先搜索（双端队列实现）（最优解法）

```java
// 0-1 广度优先搜索(双端队列实现)(最优解法)
// 类似 Dijkstra, 貌似就是对 Dijkstra 中优先队列需要排序, 找到最小的代价节点的优化
// 使用双端节点, 每次选择代价为 0 (顺方向)的入队出队, 如果没有顺方向的, 再选择代价为 1 的入队
// 那这么说来其实双端队列就等于两个队列, 不需要代价的加入 0 队列, 需要代价的加入 1 队列, 当队列 0 为空时, 出队 1 队列
// 比起随机的两者添加到同一个队列中, 这种方式能够减少某些节点的入队次数, 从而节省时间消耗
class P1368_Solution {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        int[][] cost = new int[m][n];
        for (int[] row : cost) {
            Arrays.fill(row, maxCost);
        }
        cost[0][0] = 0;

        // 双端队列
        Deque<Integer> deque = new LinkedList<>();
        deque.add(0);

        int id, i, j;
        while (!deque.isEmpty()) {
            id = deque.removeFirst();
            i = id / n;
            j = id % n;

            // 需要记录当前(i,j)距离起点的距离最小值是否得到, 可以新建一个数组来记录, 亦或者通过改变 grid[i][j] 处的值来标记是否访问过(是否得到)
            // 如果已经访问过, 不再访问
            // 在常规的广度优先搜索中, 每个节点最多被添加进队列一次, 而在 0-1 广度优先搜索中, 每个节点最多被添加进双端队列两次(即队首一次, 队尾一次)
            // 因为我们求的是最短路径, 所以当第一次出队列时, 就将该节点标记为已读, 第二次出队列时就不用再处理了
            if (grid[i][j] > 4) {
                continue;
            }
            // 置为已经访问过, 起点(0,0)到当前节点(i,j)的距离已经在节点(i,j)添加到队列中时确定, 并且该路径是到目前为止的最短路径
            grid[i][j] += 4;

            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    // 是顺方向的没有代价(不加 1)
                    minCost = cost[i][j] + (grid[i][j] == k + 5 ? 0 : 1);

                    // 如果要此次从 (i,j) 到 (x,y), 更新, 那么应当比曾经到 (x,y) 的代价要更小
                    // 即 minCost < cost[x][y] 时, 找到新的一条到 (x,y) 的代价更小的路径, 则更新其代价值, 并将其添加到队列中
                    // 而又由于有可能需要代价或者不需要代价
                    // 那么为了先遍历无代价的, 更有可能先走到终点(代价也能最快最小), 可将其加入到队列 0, 而需要代价的加入到队列 1,
                    // 出队时, 只要队列 0 中有节点, 就先出队队列 0 的节点
                    // 这里的队列 0 1 用数据结构 Deque 双端队列来模拟, 分别添加到队列头和队列尾

                    if (minCost < cost[x][y]) {
                        cost[x][y] = minCost;
                        // 此处肯定 grid[x][y] <= 4
                        if (grid[i][j] == k + 5) {
                            deque.addFirst(x * n + y);
                        } else {
                            deque.addLast(x * n + y);
                        }
                    }
                }
            }
        }

        return cost[m - 1][n - 1];
    }

    private boolean inArea(int i, int j) {
        return i >= 0 && i < m && j >= 0 && j < n;
    }
}
```

#### [1411. 给 N x 3 网格图涂色的方案数](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/)

##### 递推

##### 动态规划

```java
class P1411_Solution {
    public int numOfWays(int n) {
        final int divisor = 1000000007;
        long numABC;
        long numABA;
        // dp[0] 表示从前到这一行的三种颜色不一样(ABC)的情况的个数
        // dp[1] 表示从前到这一行的有两种颜色(ABA)的情况的个数
        long[] dp = new long[2];
        dp[0] = 6;
        dp[1] = 6;
        for (int i = 1; i < n; i++) {
            // 保存上一行的 ABC 和 ABA 情况
            numABC = dp[0];
            numABA = dp[1];

            // 下一行的 ABC 情况为上一行的 ABC 的 2 倍 + ABA 的 2 倍
            dp[0] = (numABC + numABA) * 2 % divisor;
            // 下一行的 ABA 情况为上一行的 ABC 的 2 倍 + ABA 的 3 倍
            dp[1] = (numABC * 2 + numABA * 3) % divisor;
        }
        // 返回两数之和
        return (int) (dp[0] + dp[1]) % divisor;
    }
}
```



#### [1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/)

##### 动态规划

```java
// 动态规划
class P1444_Solution {
    public int ways(String[] pizza, int k) {
        final int mod = (int) Math.pow(10, 9) + 7;
        int rows = pizza.length;
        int cols = pizza[0].length();
        int[][][] dp = new int[rows][cols][k + 1];
        int[][] apple = new int[rows + 1][cols + 1];
        // 遍历矩阵, 获取指定右下角矩阵中的苹果数量
/*        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                apple[i][j] = (pizza[i].charAt(j) == 'A' ? 1 : 0)
                        + apple[i + 1][j] + apple[i][j + 1] - apple[i + 1][j + 1];
            }
        }*/
        // 遍历每个小矩阵, 可得到将每个小矩阵切成 1 到 k 块的方案数
        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                // 该矩阵中的苹果数量
                apple[i][j] = (pizza[i].charAt(j) == 'A' ? 1 : 0)
                        + apple[i + 1][j] + apple[i][j + 1] - apple[i + 1][j + 1];
                // 该矩阵中有苹果, 如果没有苹果, 怎么切都没用, 直接下次循环
                if (apple[i][j] > 0) {
                    // 如果只切成一块, 方案数为 1;
                    dp[i][j][1] = 1;
                    // 如果切成 2...k 块, 枚举每种情况横着切和竖着切的方案和 dp[i][j][block]
                    // 本应是 block <= k, 但是如果本身此矩阵内的苹果数就小于要切成的块数 block,
                    // 这种要切成的块数情况不能满足每个块内都有苹果, 于是将结束条件设为
                    // [block <= Math.min(k, apple[i][j])], 可提前结束循环
                    for (int block = 2; block <= k; block++) {
                        // 横着切
                        // horCutNum 横着切的次数
                        for (int horCutNum = (rows - 1) - i; horCutNum >= 1; horCutNum--) {
                            // 如果当前横着切一刀后, 切掉的 [上边] 矩阵内有苹果, dp[i][j][block] 的值
                            // 应加上被切掉后剩下的 [下边] 矩阵切成 block - 1 块的方案数值
                            // 如果没有苹果, 说明此条 [水平线] 不能切, 接着循环判断下一条
                            if (apple[i][j] - apple[i + horCutNum][j] > 0) {
                                dp[i][j][block] = (dp[i][j][block] + dp[i + horCutNum][j][block - 1]) % mod;
                            }
                        }
                        // 竖着切
                        // verWaysNum 竖着切的次数
                        for (int verWaysNum = (cols - 1) - j; verWaysNum >= 1; verWaysNum--) {
                            // 如果当前竖着切一刀后, 切掉的 [左边] 矩阵内有苹果, dp[i][j][block] 的值
                            // 应加上被切掉后剩下的 [右边] 矩阵切成 block - 1 块的方案数值
                            // 如果没有苹果, 说明此条 [垂直线] 不能切, 接着循环判断下一条
                            if (apple[i][j] - apple[i][j + verWaysNum] > 0) {
                                dp[i][j][block] = (dp[i][j][block] + dp[i][j + verWaysNum][block - 1]) % mod;
                            }
                        }
                    }
                }
            }
        }
        // 返回将整个大矩阵切成 k 块的方案数
        return dp[0][0][k];
    }
}
```

> 给我做了一天，最后还是看别人的做的

#### [1462. 课程表 IV](https://leetcode-cn.com/problems/course-schedule-iv/)

##### 深度优先搜索（递归实现）

> 截止到2021.12.14，超过100%

```java
// 深度优先搜索(递归实现)
class P1462_Solution {
    // 答案链表
    List<Boolean> ans;
    // 邻接表构造有向图
    P1462_CourseNode[] adjList;
    // 记忆化是否可达, 1 代表可达, -1 代表不可达, 初始默认值为 0
    // 定义为 byte、short、int 貌似差别也并不大
    // 最开始定义为 boolean类型, 但是参考了他人的代码, 发现超时不能通过全部案例
    int[][] isReachable;

    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
        // 答案链表
        ans = new ArrayList<>(numCourses);
        // 邻接表构造有向图
        adjList = new P1462_CourseNode[numCourses];

        // 记忆化是否可达
        isReachable = new int[numCourses][numCourses];
        // 构建邻接表
        int from, to;
        for (int[] edge : prerequisites) {
            from = edge[0];
            to = edge[1];

            // 记忆可达到
            isReachable[from][to] = 1;
            isReachable[to][from] = -1;

            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new P1462_CourseNode(to, adjList[from]);
            /*
            P1462_CourseNode toNode = new P1462_CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // DFS
        for (int[] query : queries) {
            from = query[0];
            to = query[1];

            if (dfs(from, to)) {
                isReachable[from][to] = 1;
                isReachable[to][from] = -1;
            }
            ans.add(isReachable[from][to] == 1);
        }

        return ans;
    }

    private boolean dfs(int from, int to) {
        if (from == to) {
            return true;
        }
        if (isReachable[from][to] == 1) {
            return true;
        }
        if (isReachable[from][to] == -1) {
            return false;
        }
        // 有向边的起点 from -> 终点 next
        P1462_CourseNode next = adjList[from];

        while (next != null) {
            if (dfs(next.value, to)) {
                isReachable[next.value][to] = 1;
                isReachable[to][next.value] = -1;
                return true;
            }
            next = next.next;
        }

        isReachable[from][to] = -1;
        return false;
    }
}

class P1462_CourseNode {
    // value 为课程编号
    int value;
    P1462_CourseNode next;

    public P1462_CourseNode(int value) {
        this.value = value;
    }

    public P1462_CourseNode(int value, P1462_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

##### 广度优先搜索（队列实现）

> 待定

##### 弗洛伊德（Floyd）算法

```java
// 弗洛伊德(Floyd)算法
// 效率不及 DFS
class P1462_Solution2 {
    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
        // 记忆化是否可达
        boolean[][] isReachable = new boolean[numCourses][numCourses];

        for (int[] edge : prerequisites) {
            isReachable[edge[0]][edge[1]] = true;
        }
        // 中转点
        for (int k = 0; k < numCourses; k++) {
            // 起点
            for (int i = 0; i < numCourses; i++) {
                // 终点
                for (int j = 0; j < numCourses; j++) {
//                    // 如果可达不执行任何操作, 如果不可达则判断通过中转点 k 是否可达
//                    if (!isReachable[i][j]) {
//                        isReachable[i][j] = isReachable[i][k] && isReachable[k][j];
//                    }
                    // 与上等价
                    isReachable[i][j] = isReachable[i][j] || (isReachable[i][k] && isReachable[k][j]);
                }
            }
        }
        // 答案链表
        List<Boolean> ans = new ArrayList<>();
        for (int[] query : queries) {
            ans.add(isReachable[query[0]][query[1]]);
        }
        return ans;
    }
}
```

#### [1494. 并行课程 II](https://leetcode-cn.com/problems/parallel-courses-ii/)

##### 拓扑排序 + 贪心算法（未通过）

##### 动态规划（状态压缩 DP）

```java
// 动态规划: 状态压缩 DP (改进后)
class P1494_Solution {
    public int minNumberOfSemesters(int n, int[][] relations, int k) {
        if (k == 1) {
            return n;
        }
        if (relations.length == 0) {
            return n % k != 0 ? n / k + 1 : n / k;
        }
        // 先修课程 二进制状态压缩
        // pre[i] 保存的是第 i(0到n-1) 门课程的先修课程, 用二进制来表示
        // 例如 i 的先修课程如果是 2 5 7 的话, 则 pre[i] 处保存的值的二进制为 (省略若干个 0 ) 0101 0010, 在第 j(1,4,6) 个位置上的值置为 1
        int[] pre = new int[n];
        // 构造 pre, 通过将 1 左移 (先修课程编号 - 1) 位实现, 这只是一门课程的二进制表示
        // 每当有一门先修课程, 还需要将 (1 左移后的二进制值) 与 (pre[i]) 进行 '或' 运算
        // 例如, 现有三个 relation: (2,1)(5,1)(7,1) , 表示课程 1 有三门先修课程, 分别是 2, 5, 7
        // 初始时: pre[1-1] = pre[0] = 0000 0000
        // 第 1 次: 1 << (2 - 1) = 0000 0010, 此时 pre[0]: 0000 0000 | 0000 0010 = 0000 0010
        // 第 2 次: 1 << (5 - 1) = 0001 0000, 此时 pre[0]: 0000 0010 | 0001 0000 = 0001 0010
        // 第 3 次: 1 << (7 - 1) = 0100 0000, 此时 pre[0]: 0001 0010 | 0100 0000 = 0101 0010
        // 最终得到课程 1(pre 中下标为 0) 的所有先修课程的集合(只是这个集合是以一个二进制形式保存而已, 更重要的是方便取其集合子集)
        for (int[] relation : relations) {
            pre[relation[1] - 1] |= 1 << (relation[0] - 1);
        }
        // 动态规划, 求出每种状态下的最少学习学期数
        // 总状态数 N, 状态可理解为现有 n 门课程, 每门课程有两种情况(可能已学习, 也可能未学习), 共计 2^n = 1 << n 种状态
        final int N = 1 << n;
        // dp[mask] 表示修完 mask 代表的所有课程的最少学习学期数
        // 动态规划就会遍历这 N 种状态, 得到每种状态下的最少学习学期数
        int[] dp = new int[N];
        // 对 dp 数组赋初值, 题目保证能全部修完, 初始化为最大值 n (或 >n 的数)即可
        // 因为不管有多少门课程, k(k>=1) 为多少, n 门课程最多不过 n 学期就能学完
        Arrays.fill(dp, n);
        // 当然对于 dp[0], 即状态 mask == 0, 代表学习 0 门课程的最少学习学期数, 当然是 0, 其余的情况未知, 设为最大值 n
        // 假设为 4 门课程, 初始 0 门课需要 0 学期 dp[0000] = 0, 最终目标是求 dp[1111]
        dp[0] = 0;

        // 其实上面还是没有完全讲清楚 2^n 种状态中的状态到底是什么, 每一种状态 mask 可以理解为
        // 假设现在学习了 (mask的二进制代表的) 这 m 门课程的情况下, 还能从剩下的还未学习的课程中学习哪些课程? 学习多少门课程?
        // 而能够学习的这些课程(肯定它的先修课程已经学完了, 已经存在 mask的二进制 中了)总数可能超过 k
        // 即便没有超过 k, 那学习哪几门课程呢? 这里就会产生多种学习课程组合, 而通过二进制保存的形式, 又能很方便地得到种种组合

        // (mask的二进制代表的)这 m 门课程 是指
        // mask 的值范围为 (0, 2^n), 对于其中一种特定的状态, 一个特定的 mask 值
        // 例如 mask 为 18 = 0001 0010 时, dp[mask] 表示学习(第 2 门课程 和 第 5 门课程)需要学习的最少学期数
        // 但是在以 mask = 18 的遍历过程中, 并不是理解成此轮循环是在求 dp[mask](dp[18])
        // 而是求在假定已经学习了 (课程 2 和 课程 5) 的情况下
        // 若还能学习其它若干门课程, 那么学习这 (课程 2 和 课程 5 以及加上这若干门课程) 的最少学习学期数 dp[newMask]
        // newMask 为 0001 0010 '或上' 这若干门课程集合的二进制表示

        // 优化 2, 使用 cnt 数组, 替代 if (Integer.bitCount(toStudy) <= k) 判断, 改为 if (cnt[toStudy] <= k)
        // cnt 表示 2^n 种情况, 2^n 个二进制数中 1 的个数
        // 即将每次都要计算 toStudy 的二进制数有多少个这个事件提前处理了, 通过数组保存下来, 当遇到时直接查阅与 k 比较即可
        int[] cnt = new int[N];
        cnt[0] = 0;
        for (int i = 1; i < N; i++) {
            // 这个算法很奇妙, 没细看, 我也不懂
            cnt[i] = cnt[i >> 1] + (i & 1);
        }

        // 遍历这 2^n 种状态
        for (int mask = 0; mask < N; mask++) {
            // 与优化 1-1 等价的优化 1-2, 也就是优化 1 那里的多行代码可以替换为 这里的三行代码, 达到同样的效果
            // 此处这么处理的原因在于, 当当前要遍历 mask 状态能否学习其它课程时,
            // 如果该处值还为 n, 说明此前遍历小于 mask 的所有状态时都没能通过学习其它课程到达现在这个状态,
            // 即当前 mask 状态是一个不可达状态, 当然也就不能通过该状态再转变为其它状态
            // 这里说的比较抽象, 举个例子, 假设课程 1 的先修课程是 (2,5,7), 某个状态是 (0000 0011)(12)
            // 那么现在能通过这个状态去学习其它课程吗? 显然不能
            // 因为要学习课程 1, 必须得先学完 (2,5,7), 而现在的状态是只学了 (12), 这是不可能的,
            // 即不能达到这个状态, 也不能从这个状态再转变
            // 那为什么达不到这个状态, 这个状态处的值 dp[mask] 就为 n 呢?
            // 因为在遍历前面几个状态 (0000 0000)( )、(0000 0001)(1)、(0000 0010)(2) 时, 都没有改变 dp[(0000 0011)(12)] 的值
            // 举例: 假设初始时这个有向图只有 (2,5,7) 这三个入度为 0 的节点, 它们是 1 的先修课程, 且 k = 2
            // 第 1 次遍历: 遍历 mask == 0(0000 0000) 时, dp[0] = 0, 遍历改变的是 dp[(2)(5)(7)(25)(27)(57)] 这六种状态的值, 均变为 1
            // 第 2 次遍历: 遍历 mask == 1(0000 0001) 时, dp[1] = n, 由于之前的所有遍历中都没有改变过 dp[1] 的值
            //             说明它不可达, 当然也不会更新其它状态值, 可跳过
            // 第 3 次遍历: 遍历 mask == 2(0000 0010) 时, dp[2] = 1, 由于之前的所有遍历中曾改变了 dp[2] 的值, 使得其值并不为 n,
            //             说明可以通过先学习 mask 代表的课程 2, 再学习其它课程达到其它状态, 更新其它状态值
            //             此轮改变的是 dp[(5)(7)(25)(27)(57)(257)] 这六种状态的值
            //             未改变前各值分别为(1,1,1,1,1,n), 更新后各值为(1,1,1,1,1,2)
            //             dp[(0101 0010)(257)] = dp[80] = min(dp[80],dp[2] + 1) = min(n, 1 + 1) = 2
            // 第 4 次遍历: 遍历 mask == 3(0000 0011) 时, dp[3] = n, 同第 2 次遍历一样, 之前的所有遍历中都没有改变过 dp[3] 的值
            //             说明它不可达, 当然也不会更新其它状态值, 可跳过
            // ......
            if (dp[mask] >= n) {
                continue;
            }
            // boolean valid = true;

            // 当前状态下可学习的所有课程集合(二进制表示)
            int canStudy = 0;
            // 得到当前状态下的 n 门课程中可学习的课程集合 canStudy, 设最终课程数为 c
            // 在 mask 表示的已经学习了 m 门课程的状态下, 对于任意一门课程 i(0<=i<n), 是否能学习课程 i 由两个条件决定
            // 条件 1: 课程 i 肯定是要未学习过的, 也就是课程 i 要不在 mask 表示的 m 门已经学过的课程中才又可能去学习它
            // 条件 2: 课程 i 的所有先修课程都已经学习完毕, 也就是所有的先修课程都包含在 mask 表示的 m 门已经学过的课程中
            // 总结: 能学习课程 i, 课程 i 必须保证之前还未学习过(学过了就不学了), 并且它的所有先修课程都已经学习完毕(先修课程没学完就学不了)
            for (int i = 0; i < n; i++) {

                // 条件 1: (mask & (1 << n)) == 0
                // 1 << i, 表示当前正在判断的这门是否能学习的课程 i 的二进制表示(1 的位置)
                // (mask & (1 << i)) != 0, 说明当前这门要学习的课程 i 已经在此次状态 mask 表示的 m 门已学习的课程中
                // 即已经学过它, 跳过, 不学习它; 反之, 则不存在, 后续条件 2 再判断它的先修课程是否已经学完, 学完则说明该课程 i 可以学习

                // 条件 2: (mask & pre[i]) == pre[i]
                // pre[i] 是课程 i 的所有先修课程, mask 是已经学习的所有课程, 现要判断后者是否包含前者, 也就是说在两者的二进制表示中
                // pre[i] 中为 1 的相应位置, mask 中也必须为 1; pre[i]中为 0 的位置, mask 中可能为 0 或 1
                // 将两者进行 & 运算, mask 中的(pre[i] 中为 1 的)相应位置必须也为 1, 除此外的其它位置置为 0, 最终得到的结果如果与 pre[i] 相等
                // 说明 mask 包含课程 i 的所有先修课程(还可能包含其它课程), 将其保存; 反之, 则不包含所有先修课程, 不能学习课程 i
/*                if ((mask & (1 << i)) == 0 && (mask & pre[i]) == pre[i]) {
                    // 课程 i 未学习过, 且 mask 包含课程 i 的所有先修课程, 则可以学习课程 i, 将课程 i 加入集合 canStudy
                    // canStudy 保存 mask 状态下的每一门可以学习的课程, 每有一门, 就将 canStudy 的相应二进制位置为 1, 表示保存
                    // 例如: 总共 n 门课程中能学习 2,5,7 号课程(下标 i 对应为 1,4,6)
                    // 就将 canStudy 的二进制表示 0000 0000 的第 2,5,7 个位置的 0 在三轮循环中依次置为 1
                    // 初始时: canStudy = 0000 0000
                    // 第 1 次, i == 1: 1 << 1 = 0000 0010, 此时 canStudy: 0000 0000 | 0000 0010 = 0000 0010
                    // 第 2 次, i == 4: 1 << 4 = 0001 0000, 此时 canStudy: 0000 0010 | 0001 0000 = 0001 0010
                    // 第 3 次, i == 6: 1 << 6 = 0100 0000, 此时 canStudy: 0001 0010 | 0100 0000 = 0101 0010
                    // 最终 canStudy 为 0101 0010, 表示当前 mask 这种已经学习了 m 门课程的状态下, 能选择学习的课程为 canStudy 表示的课程集合
                    canStudy |= 1 << i;
                }
*/
                // 优化 1-1 是对前面 if 的优化, 当然也可以不使用此处优化, 而选择优化 1-2 也可以, 同时选择优化 1-1 和 1-2 与单选两者之一的效果是一样的
                // 如果 mask 中包含了这门课程 i, 说明已经学习了这门课程 i, 那么 mask 就一定要包含课程 i 的所有先修课程
                // 才能使得 mask 这种状态作为正确的中转的状态, 能够转移到其它的状态, 不然就是不可能状态
                if ((mask & (1 << i)) != 0) {
                    // mask 包含了课程 i, 但是不包含或者不完全包含课程 i 的所有先修课程, 这种状态就是不对的, 可以跳过
                    if ((mask & pre[i]) != pre[i]) {
                        // 也可以设置 dp[i] == n 或者 n + 1; 来退出循环
                        dp[mask] = n;
                        // valid = false;
                        break;
                    }
                } else {
                    // 如果 mask 中不包含这门课程 i, 再根据是否包含这门课程 i 的所有先修课程, 决定是否能学习这门课程
                    // 包含所有先修课程, 则能学习; 反之, 则不能学习
                    if ((mask & pre[i]) == pre[i]) {
                        canStudy |= 1 << i;
                    }
                }
            }
//            // 如果 mask 是错误状态, 不可能存在的状态, 则直接进行下一次循环
//            if (!valid) {
//                continue;
//            }
            if (dp[mask] == n) {
                continue;
            }
            // 在得到了所有可以学习的课程集合 canStudy 后, 现在要学习这 canStudy 表示的若干门课程中的课程
            // 那究竟要学习几门课程、哪些课程呢? 并且由于每次最多学习 k 门课程, 说明选择学习的课程是不是会受到此条件的限制?

            // 假设 canStudy 为前面提到过的 0101 0010, 现在从这三门课程中挑选课程学习, 有多少种情况呢? 也就是 canStudy 有哪些子集合呢?
            // 列举一下, canStudy 代表 2,5,7 号课程, 所有子集合为 (2)(5)(7)(25)(27)(57)(257), 共 2^n-1 = 2^3-1 = 7 种(不包含空集合)
            // 此时根据 k 值的不同要学习的课程组合的情况也就不同, 例如:
            // k == 1 : 可选择 (2)(5)(7)                   | 表示每次只能在这 7 种组合中挑选出不多于 1 门课程的子集合课程进行学习
            // k == 2 : 可选择 (2)(5)(7)(25)(27)(57)       | 表示每次只能在这 7 种组合中挑选出不多于 2 门课程的子集合课程进行学习
            // k == 3 : 可选择 (2)(5)(7)(25)(27)(57)(257)  | 表示每次只能在这 7 种组合中挑选出不多于 3 门课程的子集合课程进行学习
            // k >= 4 : 同 k == 3, 因为总共可学习的课程就是三门, 也就是全部课程都能学习, 所有的组合情况都能学习
            // 以上是对问题思路的解决, 但是用代码怎么实现呢? 怎么枚举出可学习课程的所有子集呢?

            // 以下是一种枚举方法, 不知道谁发明的, 真是奇妙, 可以特别记忆一下
            /* 枚举可学习课程的子集进行状态转移
               例 1: canStudy = 1010(2,4), 其子集有 2^2-1 = 3 种, 用二进制表示为 (1010)(1000)(0010)
               首先子集一定在 (0000, 1010] 范围内, 过程如下
               第 1 个 初始时: 1010(24), 十进制值为 10
               第 2 个 (1010 - 1) & 1010 = 1001 & 1010 = 1000(4), 十进制值为 8
               第 3 个 (1000 - 1) & 1010 = 0111 & 1010 = 0010(2), 十进制值为 2
               第 4 个 (0010 - 1) & 1010 = 0001 & 1010 = 0000( ), 十进制值为 0, 不合法

               例 2: canStudy = 0101 0010, 其子集有 2^3-1 = 7 种
               用二进制表示为 0101 0010(257)、0101 0000(57)、0100 0010(27)、0100 0000(7)、0001 0010(25)、0001 0000(5)、0000 0010(2)
               首先子集一定在 (0000 0000, 0101 0010] 范围内, 过程如下
               第 1 个 初始时: 0101 0010(257), 十进制值为 2^6+2^4+2^1 = 82
               第 2 个 (0101 0010 - 1) & 0101 0010 = 0101 0001 & 0101 0010 = 0101 0000(57), 十进制值为 2^6+2^4+     = 80
               第 3 个 (0101 0000 - 1) & 0101 0010 = 0100 1111 & 0101 0010 = 0100 0010(27), 十进制值为 2^6+   + 2^1 = 66
               第 4 个 (0100 0010 - 1) & 0101 0010 = 0100 0001 & 0101 0010 = 0100 0000(7),  十进制值为 2^6+   +     = 64
               第 5 个 (0100 0000 - 1) & 0101 0010 = 0011 1111 & 0101 0010 = 0001 0010(25), 十进制值为    +2^4+ 2^1 = 18
               第 6 个 (0001 0010 - 1) & 0101 0010 = 0001 0001 & 0101 0010 = 0001 0000(5),  十进制值为    +2^4+     = 16
               第 7 个 (0001 0000 - 1) & 0101 0010 = 0000 1111 & 0101 0010 = 0000 0010(2),  十进制值为    +   + 2^1 = 2
               第 8 个 (0000 0010 - 1) & 0101 0010 = 0000 0001 & 0101 0010 = 0000 0000( ),  十进制值为    +   +     = 0, 不合法
            */
            for (int toStudy = canStudy; toStudy > 0; toStudy = (toStudy - 1) & canStudy) {
                // Integer.bitCount(study) : 二进制 toStudy 中的 1 的个数, 表示此子集代表的课程数量(假设为 t)
                // 如果能学习此子集代表的课程, 则其子集代表的课程的数量 t 必须要 <= k(一次最多能学习的课程数), 才能学习这个子集课程组合
                // 如果大于 k, 说明在 mask 这种已经学习了 m 门课程的状态下, 虽然有 canStudy 代表的 c 门课程可以选择学习
                // 但是不能通过一次学习就学完这种课程数超过 k 的子集代表的这 t 门课程
                if (cnt[toStudy] <= k) {
                    //  if (Integer.bitCount(toStudy) <= k) {
                    // if (bitCount(toStudy) <= k) {
                    // mask | toStudy 表示 [学习了 mask 代表的 m 门课程和学习了 toStudy 代表的 t(<= k) 门课程] 的
                    // 这种 (m+t) 门课程这种唯一一种组合的状态
                    // 每次更新的值 dp[mask | toStudy] 表示学习 mask | toStudy 这种状态的课程组合的最少学习学期数
                    // 其值等于 曾经的历史状态 dp[mask | toStudy] 与 待定想要更新的状态值 两者中的较小值
                    // 而这个待定想要更新的状态值是 在 mask 这种学习了 m 门课程的状态下的值 dp[mask] 通过一次学习操作(学习这 t 门课程, 学期数加 1)转变过来的
                    // 第 1 种理解:
                    // 即已知 dp[mask] 为学习 mask 代表的这 m 门课程的最少学习学期数, 那么现在要学习另外的 t 门课程
                    // 那么完成后的学期数为 dp[mask]+1, 对应的那个状态是 dp[mask | toStudy]
                    // 第 2 种理解:
                    // dp[mask | toStudy] 表示要学习 (m+t) 门的这种课程组合, 可以通过先学 mask 代表的这 m 门课程, 再在这已学 m 的条件下学另外的 t 门课程
                    // 由前一个状态转变过来, 先学 m 的学期数为 dp[mask], 后学 t 门课程, 需要 1 个学期, 其值为 dp[mask]+1
                    // System.out.println("dp[" + mask + " | " + toStudy + "] : " + dp[mask | toStudy]);
                    int newMask = mask | toStudy;
                    // dp[mask | toStudy] = Math.min(dp[mask | toStudy], dp[mask] + 1);
                    dp[newMask] = Math.min(dp[newMask], dp[mask] + 1);
                    // cnt[0]++;
                    // System.out.println("dp[" + mask + " | " + toStudy + "] : " + dp[mask | toStudy]);
                }
            }
            // 通过上面的描述以及理解, 最终可以总结
            // 其实每次遍历一种 mask 状态, 看可以通过它(mask)能够转变到哪些状态(mask | toStudy), 更新能够转变到的那种状态的 dp 值
            // 而如何转变就是学习 canStudy 中的若干个包含小于等于 k 的课程数的课程子集 toStudy, 满足要求的子集数就是更新状态的次数, 也是能够转变到的状态次数
            // 总结: 也就是每一种状态(mask)都可能由之前循环中的许多种不同状态(< mask)转变而来
            // 而每种状态(mask)也可以通过学习满足要求的 toStudy 课程转变到其它状态(mask | toStudy)
        }
        // System.out.println(Arrays.toString(dp));
        // System.out.println("个数" + cnt[0]);
        // 最种要得到的是学完 n 门课程的最少学习学期数, 即在最后那种 n 位二进制的 n 个位置上的值都为 1 的那个状态
        return dp[N - 1];
    }

    // 第一种求二进制中 1 的个数的方法
    // 这个自己写的和源码的效率相差太大了吧
    // 使用源码是 94 ms
    // 使用这个是 886 ms
    private int bitCount(int a) {
        int count = 0;
        while (a != 0) {
            if ((a & 0x1) == 1) {
                count++;
            }
            a = a >> 1;
        }
        return count;
    }

    // 第二种求二进制中 1 的个数的方法 99ms
    private int getBit(int x) {
        int res = 0;
        while (x > 0) {
            res++;
            x = x & (x - 1);
        }
        return res;
    }
}
```



#### [1857. 有向图中最大颜色值](https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/)

##### 拓扑排序（广度优先搜索 队列实现） + 动态规划

###### 第一次实现 - 2021.10.15

```java
public class P1857_LargestPathValue {
    public static void main(String[] args) {
        // 测试案例 1
        String colors = "abaca";
        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}};
//        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}, {1, 2}, {3, 1}}; // 存在环
//        // 测试案例 2
//        String colors = "a";
//        int[][] edges = {{0, 0}};
//        // 测试案例 3
//        String colors = "g";
//        int[][] edges = {};

        Solution solution = new Solution();
        int largestPathValue = solution.largestPathValue(colors, edges);

        System.out.println(largestPathValue);
    }
}

class Solution {
    public int largestPathValue(String colors, int[][] edges) {

        // 节点个数
        int nodeNum = colors.length();
        // 每个节点的入度
        int[] inDegree = new int[nodeNum];
        // 保存到达每个节点时, 该条路径上的各种颜色出现的次数
        int[][] pathValue = new int[nodeNum][26];
        // 创建邻接表
        Node[] adjList = new Node[nodeNum];

        // 把从 from 节点到所有 to 节点的所有边的关系都保存为
        // 从 from 节点指向的所有的 to 节点形成的一个链表
        // 例如：从字符 ’a‘ 这个节点到 字符 ’b‘’c‘’d‘ 这三个节点的五条边关系保存为
        // {aNode} --> [bNode] --> cNode --> dNode
        // 如果 ’b‘ 到 ’e‘’f‘ ，则
        // {bNode} --> [eNode] --> fNode
        // 其中,[]括号里的[bNode][eNode]两节点才保存在邻接表adjList[from]中
        // from 为相对应的’a‘’b‘在原字符串中的下标
        for (int[] edge : edges) {
            int from = edge[0], to = edge[1];
            // to 节点的入度更新,一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法，与注释的三行等价
            adjList[from] = new Node(to, adjList[from]);
            /*
            Node toNode = new Node(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // 保存入度为 0 的各个节点，有可能是非连通图
        LinkedList<Integer> queue = new LinkedList<>();
        for (int i = 0; i < inDegree.length; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }
        // 如果 queue 中一个都没有, 表示存在环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return -1;
        }

        // 如果无环,当循环结束时, bfsCount 应该等于节点数 nodeNum
        int bfsCount = 0;
        Node next;
        while (!queue.isEmpty()) {
            // 初始时前 initQueueSize = queue.size() 个 cur 代表入度为 0 的从该点开始遍历的出发节点的下标
            // 可以看作有 initQueueSize 个子图
            int cur = queue.remove();
            // adjList[cur] 处存储的是 cur 的下一个节点
            next = adjList[cur];

            // bfsCount 入度为 0 的点的个数
            bfsCount++;
            // 将当前路径上的该点处的相应颜色的值加 1
            pathValue[cur][colors.charAt(cur) - 97]++;
            // 遍历当前节点能够到达的其它所有节点
            while (next != null) {
                // 入度减 1, 减小到 0 时, 将其入队
                inDegree[next.value]--;
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }

                // 更新 next 所有颜色次数
                // 由于当前的这个节点在曾经可能已经在其它路径中被访问过,所以此次访问需要比较上次
                // pathValue[0].length == 26 小写字母个数
                for (int i = 0; i < pathValue[0].length; i++) {
                    pathValue[next.value][i] = Math.max(pathValue[next.value][i], pathValue[cur][i]);
                }
                // next 指向 cur 这个入度为 0 的节点的下一个与它相连的能组成边的点
                next = next.next;
            }
        }

        // 如果无环,当循环结束时, bfsCount 应该等于节点数 nodeNum
        if (bfsCount != nodeNum) {
            return -1;
        }

        // 从 pathValue 二维数组中获取最大值 largestPathValue
        int res = 0;
        for (int[] ints : pathValue) {
            res = Math.max(res, Arrays.stream(ints).max().getAsInt());
        }
//        for (int[] ints : pathValue) {
//            for (int j = 0; j < pathValue[0].length; j++) {
//                res = Math.max(res, ints[j]);
//            }
//        }
        return res;
    }
}

class Node {

    // value 表示第几个字符
    public int value;
    Node next;

    public Node(int value) {
        this.value = value;
    }

    public Node(int value, Node next) {
        this.value = value;
        this.next = next;
    }
}
```

###### 第二次实现 - 2021.12.05

```java
public class Second_P1857_LargestPathValue {
    public static void main(String[] args) {
        // 测试案例 1
        String colors = "abaca";
        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}};
        int[][] edges1 = {{0, 1}, {0, 2}, {2, 3}, {3, 4}, {1, 2}, {3, 1}}; // 存在环

        // 测试案例 2
        String colors2 = "a";
        int[][] edges2 = {{0, 0}}; // 存在环

        // 测试案例 3
        String colors3 = "g";
        int[][] edges3 = {};

        Second_P1857_Solution solution = new Second_P1857_Solution();
        System.out.println(solution.largestPathValue(colors, edges)); // 3
        System.out.println(solution.largestPathValue(colors, edges1)); // -1
        System.out.println(solution.largestPathValue(colors2, edges2)); // -1
        System.out.println(solution.largestPathValue(colors3, edges3)); // 1
    }
}

// 拓扑排序(Topological sort)(BFS 队列实现) + 动态规划
class Second_P1857_Solution {
    public int largestPathValue(String colors, int[][] edges) {

        // 节点个数
        int nodeNum = colors.length();
        // 小写字母个数
        final int letterNum = 26;
        // 各个节点的入度
        int[] inDegree = new int[nodeNum];
        // 动态规划数组, 保存到达各个节点时, 该条路径上的各种颜色出现的次数
        int[][] pathValueDP = new int[nodeNum][letterNum];
        // 创建邻接表
        Node[] adjList = new Node[nodeNum];

        // 把从 from 节点到所有 to 节点的所有边的关系都保存为
        // 从 from 节点指向的所有的 to 节点形成的一个链表
        // 例如: 从字符 ’a‘ 这个节点到字符 ’b‘’c‘’d‘ 这三个节点的四条边关系保存为
        // {aNode} --> [bNode] --> cNode --> dNode
        // 如果字符 ’b‘ 能到 ’e‘’f‘, 则
        // {bNode} --> [eNode] --> fNode
        // 其中, []括号里的 [bNode]、[eNode] 两个节点才保存在邻接表 adjList[from] 中
        // from 为相对应的 ’a‘’b‘ 在原字符串中的下标
        int from, to;
        for (int[] edge : edges) {
            from = edge[0];
            to = edge[1];
            // 更新 to 节点的入度, 一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法, 与注释的三行等价
            adjList[from] = new Node(to, adjList[from]);
            /*
            Node toNode = new Node(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // BFS
        // 保存入度为 0 的各个节点的下标, 有可能是非连通图
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < inDegree.length; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 如果 queue 中一个入度为 0 的节点都没有, 表示图存在环, 并且整个图是一个大环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return -1;
        }

        // bfsCount 表示遍历过程中遍历了多少个入度为 0 的 节点
        // 如果无环, 当循环结束时, bfsCount 应该等于节点总数 nodeNum
        int bfsCount = 0;
        Node next;
        int cur;
        while (!queue.isEmpty()) {
            // 初始时前 initQueueSize = queue.size() 个 cur 代表入度为 0 的从该点开始遍历的出发节点的下标
            // 可以看作有 initQueueSize 个子图 (这个说法是错误的)

            // 出队一个入度为 0 的节点
            cur = queue.remove();
            // adjList[cur] 处存储的是 cur 能够到达的下一个节点 next
            next = adjList[cur];

            // bfsCount 为遍历过程中遍历了的入度为 0 的节点的个数
            bfsCount++;
            // 将当前路径上的该点处的相应颜色的值加 1
            pathValueDP[cur][colors.charAt(cur) - 97]++;

            // 遍历当前节点能够到达的其它所有节点
            while (next != null) {
                // 入度减 1, 减小后为 0 时, 将其入队
                inDegree[next.value]--;
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }

                // 动态规划, 更新 next 所有颜色次数
                // 由于当前的这个 next 节点在曾经可能已经在其它路径中被访问过, 所以此次访问需要比较上次
                // 以确保当前循环结束后, pathValueDP[next.value][i] 处保存的值为
                // 到目前为止, 到达该节点的各条路径中各种颜色(26个字母)出现的最多的次数
                // letterNum == pathValueDP[0].length == 26 小写字母个数
                for (int i = 0; i < letterNum; i++) {
                    pathValueDP[next.value][i] = Math.max(pathValueDP[next.value][i], pathValueDP[cur][i]);
                }
                // 再令 next 为 cur 这个入度为 0 的节点的其它下一个节点(与它相连的能形成有向边的节点)
                // 直到遍历完所有 next 节点后退出循环
                next = next.next;
            }
        }

        // 如果无环, 当循环结束时, bfsCount 应该等于节点总数 nodeNum
        // 如果无法遍历完所有的结点，则意味着当前的图不是有向无环图, 不存在拓扑排序
        if (bfsCount != nodeNum) {
            return -1;
        }

        // 从 pathValueDP 二维数组中获取最大值 largestPathValue
        int res = 0;
//        for (int[] ints : pathValueDP) {
//            res = Math.max(res, Arrays.stream(ints).max().getAsInt());
//        }
        for (int[] ints : pathValueDP) {
            for (int j = 0; j < letterNum; j++) {
                res = Math.max(res, ints[j]);
            }
        }
        return res;
    }
}

class Node {

    // value 表示第几个字符, 节点下标
    int value;
    Node next;

    public Node(int value) {
        this.value = value;
    }

    public Node(int value, Node next) {
        this.value = value;
        this.next = next;
    }
}
```



#### [1905. 统计子岛屿](https://leetcode-cn.com/problems/count-sub-islands/)

##### 深度优先搜索（递归实现）

```java
// 深度优先搜索(递归实现)
// 此题 DFS 效率比 BFS 高
class P1905_Solution {
    int[][] grid1;
    int[][] grid2;
    int m;
    int n;

    public int countSubIslands(int[][] grid1, int[][] grid2) {
        this.grid1 = grid1;
        this.grid2 = grid2;
        this.m = grid1.length;
        this.n = grid1[0].length;

        // grid2 中 子岛屿 的 数目
        int numSubIslands = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    if (dfs(i, j)) {
                        numSubIslands++;
                    }
                }
            }
        }

        return numSubIslands;
    }

    private boolean dfs(int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return true;
        }

        if (grid2[i][j] == 0 || grid2[i][j] == 2) {
            return true;
        }
//        // 可以不创建 bl 变量, 使用 & 符号
//        // 1
//        boolean bl = true;
//
//        // 如果(i,j)处, grid1[i][j]为 0, grid2[i][j]为 1, 说明这个岛屿不是子岛屿
//        if (grid1[i][j] == 0) {
//            bl = false;
//        }
//
//        // 陆地标记已访问
//        grid2[i][j] = 2;
//
//        // 左上下右
//        bl = dfs(i, j - 1) && bl;
//        bl = dfs(i - 1, j) && bl;
//        bl = dfs(i + 1, j) && bl;
//        bl = dfs(i, j + 1) && bl;
//        return bl;


//        // 2
        // && 和 & 都是表示与，区别是 && 只要第一个条件不满足，后面条件就不再判断。
        // 而 & 要对所有的条件都进行判断。

        // 陆地标记已访问
        grid2[i][j] = 2;
        // 左上下右
        return dfs(i, j - 1)
                & dfs(i - 1, j)
                & dfs(i + 1, j)
                & dfs(i, j + 1)
                & grid1[i][j] == 1;
    }
}
```

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索(队列实现)
class P1905_Solution1 {
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int m = grid1.length;
        int n = grid1[0].length;
        // 左上下右
        int[] dx = new int[]{0, -1, 1, 0};
        int[] dy = new int[]{-1, 0, 0, 1};
        // grid2 中 子岛屿 的 数目
        int numSubIslands = 0;
        boolean bl;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    Queue<Integer> queue = new LinkedList<>();
                    queue.add(i * n + j);
                    // 每次重新对 bl 赋初值
                    bl = grid1[i][j] == 1;
                    grid2[i][j] = 2;
                    int id, curX, curY;
                    while (!queue.isEmpty()) {
                        id = queue.poll();
                        curX = id / n;
                        curY = id % n;
                        int x, y;
                        // 左上下右
                        for (int k = 0; k < 4; k++) {
                            x = curX + dx[k];
                            y = curY + dy[k];
                            if (x < 0 || x >= m || y < 0 || y >= n) {
                                continue;
                            }
                            if (grid2[x][y] == 1) {
                                queue.add(x * n + y);
                                // 如果(i,j)处, grid1[i][j]为 0, grid2[i][j]为 1, 说明这个岛屿不是子岛屿
                                if (grid1[x][y] == 0) {
                                    bl = false;
                                }
                                // 陆地标记已访问
                                grid2[x][y] = 2;
                            }
                        }
                    }
                    // bl 为 false 时, 表示该岛屿不是子岛屿
                    if (bl) {
                        numSubIslands++;
                    }
                }
            }
        }
        return numSubIslands;
    }
}
```

#### [2050. 并行课程 III](https://leetcode-cn.com/problems/parallel-courses-iii/)

##### 拓扑排序（广度优先搜索 队列实现） + 动态规划

```java
// 拓扑排序(BFS 队列实现) + 动态规划
class P2050_Solution {
    public int minimumTime1(int n, int[][] relations, int[] time) {
        // 设置数组大小为 n + 1, 方便索引, 下标 0 不起作用
        // 邻接表
        P2050_CourseNode[] adjList = new P2050_CourseNode[n + 1];
        // 各个节点的入度, 每门课程的先修课程的数目
        int[] inDegree = new int[n + 1];
        // 该节点是否有出度, 是否是最后一门才能学习的课程, 或者是无入度无出度的可随时学习的课程
        boolean[] outDegree = new boolean[n + 1];
        // dp 数组, 记录到达各个节点(要学完此课程)所需的最少月份数
        int[] dp = new int[n + 1];
        // 学完所有课程所需要的 最少 月份数
        int minTime = 0;
        // 构造邻接表
        int from, to;
        for (int[] edge : relations) {
            // 有向边起点
            from = edge[0];
            // 有向边终点
            to = edge[1];
            // 头插法构造邻接表, adjList[from] 存储的是所有以 from 课程为先修课程的课程组成的链表
            adjList[from] = new P2050_CourseNode(to, adjList[from]);

            // 终点入度加 1
            inDegree[to]++;
            // from 有后修课程, 置为 true
            outDegree[from] = true;
        }

        // 将入度为 0 的各节点入队, 并更新初始学完这些入度为 0 (无先修课程)的课程的所需的时间就为 time[i - 1]
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
                dp[i] = time[i - 1];
            }
        }

        // 有向无环图
        int cur;
        P2050_CourseNode next;
        while (!queue.isEmpty()) {
            // 此次学习的课程
            cur = queue.poll();
            // 以 cur 课程为先修课程的一门课程 next
            next = adjList[cur];

            while (next != null) {
                // 入度减 1, 表示又学习了 next 的一门先修课程
                inDegree[next.value]--;
                // 当 next 入度减到 0 时, 说明 next 的所有的先修课程都学习完毕(刚学习完的 cur 课程就是它的最后一门先修课程)
                if (inDegree[next.value] == 0) {
                    // 将该 next 课程加入到队列中, 后续就可以学习该课程了
                    queue.add(next.value);
                }

                // 学习完课程 cur 至少需要的月份数为 dp[cur], 此次如果要学习课程 next, 需要的月份数为 dp[cur] + time[next.value - 1]
                // 课程 next 的先修课程课程有多个, 但是在学习 next 之前已经学过了, 它的 dp 值已经确定
                // 那么学完课程 next 所需的最少时间, 就是历次学完它的所有先修课程所花费的时间中的最大值 + 学习课程 next 所需要花费的时间 time[next.value - 1]
                dp[next.value] = Math.max(dp[next.value], dp[cur] + time[next.value - 1]);
                // 继续判断学习完 cur 课程后, 以 cur 课程为先修课程的下一门课程是否可以学习
                next = next.next;
            }
        }
        // 找到所有无出度(出度为 0 )的节点, 即终点, 比较到达终点的所有花费时间中的最大值就是学完所有课程花费的最少时间
        for (int i = 1; i <= n; i++) {
            if (!outDegree[i]) {
                minTime = Math.max(minTime, dp[i]);
            }
        }
        return minTime;
    }

    // 小优化
    public int minimumTime(int n, int[][] relations, int[] time) {
        // 设置数组大小为 n + 1, 方便索引, 下标 0 不起作用
        // 邻接表
        P2050_CourseNode[] adjList = new P2050_CourseNode[n + 1];
        // 各个节点的入度, 每门课程的先修课程的数目
        int[] inDegree = new int[n + 1];
        // 该节点是否有出度, 是否是最后一门才能学习的课程, 或者是无入度无出度的可随时学习的课程
        // boolean[] outDegree = new boolean[n + 1];
        // dp 数组, 记录到达各个节点(要学完此课程)所需的最少月份数
        int[] dp = new int[n + 1];
        // 学完所有课程所需要的 最少 月份数
        int minTime = 0;
        // 构造邻接表
        int from, to;
        for (int[] edge : relations) {
            // 有向边起点
            from = edge[0];
            // 有向边终点
            to = edge[1];
            // 头插法构造邻接表, adjList[from] 存储的是所有以 from 课程为先修课程的课程组成的链表
            adjList[from] = new P2050_CourseNode(to, adjList[from]);

            // 终点入度加 1
            inDegree[to]++;
            // from 有后修课程, 置为 true
            // outDegree[from] = true;
        }

        // 将入度为 0 的各节点入队, 并更新初始学完这些入度为 0 (无先修课程)的课程的所需的时间就为 time[i - 1]
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
                dp[i] = time[i - 1];
            }
        }

        // 有向无环图
        int cur;
        P2050_CourseNode next;
        while (!queue.isEmpty()) {
            // 此次学习的课程
            cur = queue.poll();
            // 以 cur 课程为先修课程的一门课程 next
            next = adjList[cur];

            // 不使用 outDegree
            // next == null, 说明 cur 课程不是任何课程的先修课程,
            // 也即 cur 课程随时可以学习或者 cur 的所有先修课程已经学习完毕并且没有以 cur 课程为先修课程的课程, 此拓扑排序到达了终点
            // 学完所有课程所需的时间就是学完这几门课程时, 它们所需时间的最大值, 所有 dp[cur] 中的最大值, cur 必须满足无后继学习课程(不是任何课程的先修课程)
            // 这样的课程数目, 也就是 minTime 比较次数就是所有课程组成的有向无环图的个数
            if (next == null) {
                minTime = Math.max(minTime, dp[cur]);
                continue;
            }

            while (next != null) {
                // 入度减 1, 表示又学习了 next 的一门先修课程
                inDegree[next.value]--;
                // 当 next 入度减到 0 时, 说明 next 的所有的先修课程都学习完毕(刚学习完的 cur 课程就是它的最后一门先修课程)
                if (inDegree[next.value] == 0) {
                    // 将该 next 课程加入到队列中, 后续就可以学习该课程了
                    queue.add(next.value);
                }

                // 学习完课程 cur 至少需要的月份数为 dp[cur], 此次如果要学习课程 next, 需要的月份数为 dp[cur] + time[next.value - 1]
                // 课程 next 的先修课程课程有多个, 但是在学习 next 之前已经学过了, 它的 dp 值已经确定
                // 那么学完课程 next 所需的最少时间, 就是历次学完它的所有先修课程所花费的时间中的最大值 + 学习课程 next 所需要花费的时间 time[next.value - 1]
                dp[next.value] = Math.max(dp[next.value], dp[cur] + time[next.value - 1]);
                // 继续判断学习完 cur 课程后, 以 cur 课程为先修课程的下一门课程是否可以学习
                next = next.next;
            }
        }
        /* // 找到所有无出度(出度为 0 )的节点, 即终点, 比较到达终点的所有花费时间中的最大值就是学完所有课程花费的最少时间
        for (int i = 1; i <= n; i++) {
            if (!outDegree[i]) {
                minTime = Math.max(minTime, dp[i]);
            }
        }*/
        return minTime;
    }
}

class P2050_CourseNode {
    // value 为课程编号
    int value;
    P2050_CourseNode next;

    public P2050_CourseNode(int value) {
        this.value = value;
    }

    public P2050_CourseNode(int value, P2050_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```



## 剑指 Offer II

### 待定

## 编程过程中遇到的报错问题

P123_在IDEA上并没有此错误，但是在LeetCode中报错了

```java
java.util.ConcurrentModificationException
  at line 1495, java.base/java.util.HashMap$HashIterator.nextNode
  at line 1518, java.base/java.util.HashMap$KeyIterator.next
    
    for (Integer ind : hashSet) {
        if (prices[ind] >= prices[i]) {
            hashSet.remove(ind);
        }
    }
```

> 不能这么操作，要使用迭代器的方式
>

