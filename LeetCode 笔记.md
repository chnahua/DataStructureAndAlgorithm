# LeetCode 笔记

## 我的 LeetCode 记录

### 2021年

|  日期  |                              1                               |                              2                               |                      3                      |                4                |                              5                               |                     6                     |                     7                     |                      8                       |                    9                    |                      10                       |                              11                              |                      12                      |                              13                              |                              14                              |                              15                              |                     16                      |                       17                       |                              18                              |                              19                              |                          20                          |                              21                              |                          22                           |                              23                              |                24                |                  25                   |                    26                     |                27                 |                              28                              |                      29                       |                              30                              |                  31                  |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :-----------------------------: | :----------------------------------------------------------: | :---------------------------------------: | :---------------------------------------: | :------------------------------------------: | :-------------------------------------: | :-------------------------------------------: | :----------------------------------------------------------: | :------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :--------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------------------------------------------------: | :----------------------------------------------------------: | :---------------------------------------------------: | :----------------------------------------------------------: | :------------------------------: | :-----------------------------------: | :---------------------------------------: | :-------------------------------: | :----------------------------------------------------------: | :-------------------------------------------: | :----------------------------------------------------------: | :----------------------------------: |
|  四月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |                                         |                                               |                                                              |                                              |                                                              |                                                              |                                                              |                                             |                                                |                                                              |                                                              |                                                      |                                                              |                                                       |                                                              |                                  |                                       |      <a href="#112-路径总和">112</a>      |                                   |                                                              |                                               |                                                              |                  ——                  |
|  五月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |    <a href="#344-反转字符串">344</a>    |                                               |                                                              |                                              |                                                              |                                                              |                                                              |                                             |                                                |                                                              |                                                              |                                                      |                                                              |                                                       |                                                              |                                  |                                       |                                           |                                   |                                                              |                                               |                                                              |                                      |
|  九月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |                                         |                                               |                                                              |                                              |                                                              |                                                              |                                                              |                                             |                                                |                                                              |    <a href="#105-从前序与中序遍历序列构造二叉树">105</a>     |                                                      |                                                              | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |                                                              |                                  |                                       |                                           |                                   |                                                              |                                               |                                                              |                  ——                  |
|  十月  |                                                              |                                                              |                                             |                                 |                                                              |                                           |                                           |                                              |                                         |                                               |                                                              |                                              |                                                              |                                                              | <a href="#146-LRU 缓存机制">146</a>、<a href="#1857-有向图中最大颜色值">1857</a> |   <a href="#146-LRU 缓存机制">146(2)</a>    |                                                |             <a href="#23-合并K个升序链表">23</a>             |           <a href="#3-无重复字符的最长子串">3</a>            |          <a href="#35-搜索插入位置">35</a>           |                <a href="#15-三数之和">15</a>                 |          <a href="#112-路径总和">112(2)</a>           |              <a href="#113-路径总和 II">113</a>              | <a href="#739-每日温度">739</a>  |                                       | <a href="#147-对链表进行插入排序">147</a> |                                   |                                                              |    <a href="#104-二叉树的最大深度">104</a>    | <a href="#62-不同路径">62</a>、<a href="#63-不同路径 II">63</a> | <a href="#344-反转字符串">344(2)</a> |
| 十一月 | <a href="#200-岛屿数量">200</a>、<a href="#980-不同路径 III">980</a> | <a href="#237-删除链表中的节点">237</a>、<a href="#509-斐波那契数">509</a> | <a href="#1137-第 N 个泰波那契数">1137</a>  |   <a href="#42-接雨水">42</a>   | <a href="#11-盛最多水的容器">11</a>、<a href="#70-爬楼梯">70</a> | <a href="#746-使用最小花费爬楼梯">746</a> |   <a href="#695-岛屿的最大面积">695</a>   |      <a href="#463-岛屿的周长">463</a>       | <a href="#1444-切披萨的方案数">1444</a> |   <a href="#1293-网格中的最短路径">1293</a>   |         <a href="#1293-网格中的最短路径">1293(2)</a>         |      <a href="#93-复原 IP 地址">93</a>       | <a href="#46-全排列">46</a>、<a href="#1254-统计封闭岛屿的数目">1254</a> |                <a href="#494-目标和">494</a>                 |            <a href="#300-最长递增子序列">300</a>             | <a href="#673-最长递增子序列的个数">673</a> | <a href="#673-最长递增子序列的个数">673(2)</a> |                                                              |               <a href="#391-完美矩形">391</a>                |         <a href="#563-二叉树的坡度">563</a>          | <a href="#198-打家劫舍">198</a>、<a href="#213-打家劫舍 II">213</a> |          <a href="#337-打家劫舍 III">337</a>          | <a href="#55-跳跃游戏">55</a>、<a href="#740-删除并获得点数">740</a> | <a href="#45-跳跃游戏 II">45</a> |    <a href="#322-零钱兑换">322</a>    |    <a href="#518-零钱兑换 II">518</a>     |  <a href="#47-全排列 II">47</a>   |             <a href="#1020-飞地的数量">1020</a>              |         <a href="#72-编辑距离">72</a>         | <a href="#145-二叉树的后序遍历">145</a>、<a href="#1143-最长公共子序列">1143</a> |                  ——                  |
| 十二月 |          <a href="#145-二叉树的后序遍历">145(2)</a>          |             <a href="#1905-统计子岛屿">1905</a>              | <a href="#124-二叉树中的最大路径和">124</a> | <a href="#5-最长回文子串">5</a> |        <a href="#1857-有向图中最大颜色值">1857(2)</a>        |       <a href="#207-课程表">207</a>       | <a href="#121-买卖股票的最佳时机">121</a> | <a href="#122-买卖股票的最佳时机 II">122</a> |    <a href="#210-课程表 II">210</a>     | <a href="#123-买卖股票的最佳时机 III">123</a> | <a href="#207-课程表">207(2)</a>、<a href="#210-课程表 II">210(2)</a> | <a href="#188-买卖股票的最佳时机 IV">188</a> |                                                              | <a href="#630-课程表 III">630</a>、<a href="#1462-课程表 IV">1462</a> |           <a href="#1494-并行课程 II">1494(0)</a>            |    <a href="#1494-并行课程 II">1494</a>     |     <a href="#2050-并行课程 III">2050</a>      | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368(2)</a> | <a href="#1411-给 N x 3 网格图涂色的方案数">1411</a> |            <a href="#980-不同路径 III">980(2)</a>            |   <a href="#1687-从仓库到码头运输箱子">1687(0)</a>    |        <a href="#1687-从仓库到码头运输箱子">1687</a>         | <a href="#735-行星碰撞">735</a>  | <a href="#594-最长和谐子序列">594</a> |     <a href="#409-最长回文串">409</a>     | <a href="#825-适龄的朋友">825</a> | <a href="#69-Sqrt(x)">69</a>、<a href="#236-二叉树的最近公共祖先">236</a> | <a href="#864-获取所有钥匙的最短路径">864</a> |            <a href="#33-搜索旋转排序数组">33</a>             |  <a href="#226-翻转二叉树">226</a>   |

### 2022年

| 日期 |                         1                         |                   2                   |                           3                            |                           4                           |                 5                 |                              6                               |                    7                    |                              8                               |                    9                    |                              10                              |                     11                      |                      12                      |                              13                              |                              14                              |                  15                  |                16                 |                       17                        |                18                 |                              19                              |                   20                    |  21  |                   22                    |                  23                   |                       24                        |  25  |                     26                      |  27  |  28  |                   29                    |                     30                      |                        31                        |
| :--: | :-----------------------------------------------: | :-----------------------------------: | :----------------------------------------------------: | :---------------------------------------------------: | :-------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------: | :-------------------------------: | :---------------------------------------------: | :-------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :--: | :-------------------------------------: | :-----------------------------------: | :---------------------------------------------: | :--: | :-----------------------------------------: | :--: | :--: | :-------------------------------------: | :-----------------------------------------: | :----------------------------------------------: |
| 一月 | <a href="#2022-将一维数组转变成二维数组">2022</a> | <a href="#516-最长回文子序列">516</a> |       <a href="#1143-最长公共子序列">1143(2)</a>       |       <a href="#208-实现 Trie (前缀树)">208</a>       |                                   | <a href="#6-Z 字形变换">6</a>、<a href="#472-连接词">472</a> |    <a href="#994-腐烂的橘子">994</a>    |        <a href="#103-二叉树的锯齿形层序遍历">103</a>         | <a href="#729-我的日程安排表 I">729</a> |           <a href="#731-我的日程安排表 II">731</a>           |   <a href="#101-对称二叉树">101(一面)</a>   |  <a href="#732-我的日程安排表 III">732</a>   | <a href="#334-递增的三元子序列">334</a>、<a href="#747-至少是其他数字两倍的最大数">747</a> |            <a href="#239-滑动窗口最大值">239</a>             | <a href="#1001-网格照明">1001(0)</a> | <a href="#1001-网格照明">1001</a> | <a href="#1220-统计元音字母序列的数目">1220</a> | <a href="#539-最小时间差">539</a> | <a href="#217-存在重复元素">217</a>、<a href="#219-存在重复元素 II">219</a> | <a href="#220-存在重复元素 III">220</a> | 二面 | <a href="#1332-删除回文子序列">1332</a> | <a href="#2034-股票价格波动">2034</a> | <a href="#2045-到达目的地的第二短时间">2045</a> | 一面 | <a href="#2121-相同元素的间隔之和">2121</a> | 二面 |      | <a href="#1765-地图中的最高点">1765</a> | <a href="#884-两句话中的不常见单词">884</a> | <a href="#1342-将数字变成 0 的操作次数">1342</a> |
| 二月 |    <a href="#1763-最长的美好子字符串">1763</a>    | <a href="#2000-反转单词前缀">2000</a> | <a href="#1414-和为 K 的最少斐波那契数字数目">1414</a> | <a href="#1725-可以形成最大正方形的矩形数目">1725</a> | <a href="#1219-黄金矿工">1219</a> | <a href="#1701-平均等待时间">1701</a>、<a href="#1748-唯一元素的和">1748</a> | <a href="#1405-最长快乐字符串">1405</a> | <a href="#64-最小路径和">64</a>、<a href="#739-每日温度">739(2)(一面)</a> | <a href="#347-前 K 个高频元素">347</a>  | <a href="#1447-最简分数">1447</a>、<a href="#2006-差的绝对值为 K 的数对数目">2006</a> | <a href="#1984-学生分数的最小差值">1984</a> | <a href="#215-数组中的第K个最大元素">215</a> | <a href="#1189-“气球”的最大数量">1189</a>、<a href="#1712-将数组分成三个子数组的方案数">1712</a> | <a href="#540-有序数组中的单一元素">540</a>、<a href="#1712-将数组分成三个子数组的方案数">1712(2)</a> |                                      |                                   |                                                 |                                   |                                                              |                                         |      |                                         |                                       |                                                 |      |                                             |      |      |                   ——                    |                     ——                      |                        ——                        |

## 日常做题感受与初次总结

### 2021年

|  完成时间  |                           题目编号                           | 感受总结                                                     |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------- |
| 2021.04.26 |           <a href="#112-路径总和">112-路径总和</a>           |                                                              |
| 2021.05.09 |         <a href="#344-反转字符串">344-反转字符串</a>         |                                                              |
| 2021.09.19 | <a href="#105-从前序与中序遍历序列构造二叉树">105-从前序与中序遍历序列构造二叉树</a> |                                                              |
| 2021.09.22 | <a href="#106-从中序与后序遍历序列构造二叉树">106-从中序与后序遍历序列构造二叉树</a> |                                                              |
| 2021.10.15 |       <a href="#146-LRU 缓存机制">146-LRU 缓存机制</a>       |                                                              |
| 2021.10.15 | <a href="#1857-有向图中最大颜色值">1857-有向图中最大颜色值</a> | 【2021.12.05-后期补充】之所以发现这道题，是因为在某次查看他人的笔试中说遇到了其它的某个题，然后评论里说那个题和这个题很像，就来搜搜看看了。这道题对于那时的我，哪怕是此时的我都挺难的，今天再次做这题，还是做不起，还是不足，了解得太少了。 |
| 2021.10.16 |     <a href="#146-LRU 缓存机制">146(2)-LRU 缓存机制</a>      |                                                              |
| 2021.10.18 |     <a href="#23-合并K个升序链表">23-合并K个升序链表</a>     | 思路一致，具体代码实现有差别                                 |
| 2021.10.19 | <a href="#3-无重复字符的最长子串">3-无重复字符的最长子串</a> | 很巧合，与答案思想差不多，实现不同                           |
| 2021.10.20 |        <a href="#35-搜索插入位置">35-搜索插入位置</a>        | 思考的不够简洁，但是挺有逻辑性，官方的或者他人的要简洁些，但是理解上需要总结一下规律 |
| 2021.10.21 |            <a href="#15-三数之和">15-三数之和</a>            | 一开始完全没有头绪，只能想到暴力破解，最后去重，于是直接查看答案，并按照答案写出来 |
| 2021.10.22 |         <a href="#112-路径总和">112(2)-路径总和</a>          | 哈哈，这次做的逻辑简化后和答案一模一样                       |
| 2021.10.23 |        <a href="#113-路径总和 II">113-路径总和 II</a>        | 可以尝试做，但是没有明确思路，就按照答案做了                 |
| 2021.10.24 |           <a href="#739-每日温度">739-每日温度</a>           | 用了比官方暴力解法更为暴力的方法哈哈哈                       |
| 2021.10.26 | <a href="#147-对链表进行插入排序">147-对链表进行插入排序</a> | 同样都是实现插入排序，整体思路一致，但也有些差别，代码实现自然也就不同了 |
| 2021.10.29 |   <a href="#104-二叉树的最大深度">104-二叉树的最大深度</a>   | 这道题很简单，之前做过比这道题更难的相似的题，所以完成不难   |
| 2021.10.30 |            <a href="#62-不同路径">62-不同路径</a>            | 一开始完全没想到是动态规划，以为是递归回溯，但是知道是动态规划后就一下子知道怎么做了 |
| 2021.10.30 |         <a href="#63-不同路径 II">63-不同路径 II</a>         | 和上一题类似，难了一些，多了些条件判断                       |
| 2021.10.31 |       <a href="#344-反转字符串">344(2)-反转字符串</a>        | 看答案前我想着超简单，就是简单的数组头尾数据交换，以后可以不再复习，然而这题官方答案居然使用了双指针，这种思想我没想到，看来还是得要注意下 |
| 2021.11.01 |       <a href="#980-不同路径 III">980-不同路径 III</a>       | 还是看别人的做法完成的，官方做法还有些看不懂                 |
| 2021.11.01 |           <a href="#200-岛屿数量">200-岛屿数量</a>           | 由于今天是先做了P980再做的此题，使用DFS，方便了许多，和官方答案的DFS思路与代码差不多，实现略微不同 |
| 2021.11.02 |   <a href="#237-删除链表中的节点">237-删除链表中的节点</a>   | 差点没读懂题目，虽然做出来了，但是还是不够答案聪明，做得复杂了一点点 |
| 2020.11.02 |         <a href="#509-斐波那契数">509-斐波那契数</a>         | 以前都没有想到过可以用动态规划做这个题，一直以为是递归就行了，但是现在才发现不仅如此，还可以有官方答案的使用矩阵或者特征方程等方式作答 |
| 2021.11.03 | <a href="#1137-第 N 个泰波那契数">1137-第 N 个泰波那契数</a> | 今天才静下心来看了下这个快速矩阵幂的解答方式，线性代数真是厉害 |
| 2021.11.04 |              <a href="#42-接雨水">42-接雨水</a>              | 虽然花的时间比较久，但是还是完成了，并且效率还比较高         |
| 2021.11.05 |      <a href="#11-盛最多水的容器">11-盛最多水的容器</a>      | 由于昨天做了第42题，类型差不多，也有双指针解法，并且比此题难，所以能做出来不意外，但是其实还是对双指针掌握得不够 |
| 2021.11.05 |              <a href="#70-爬楼梯">70-爬楼梯</a>              | 这是一道爬楼梯题，解题方式和前面的斐波那契数几乎一样         |
| 2021.11.06 | <a href="#746-使用最小花费爬楼梯">746-使用最小花费爬楼梯</a> | 这是一道计算爬楼梯最低花费的题，比上一题难了一些，不过由于之前我已经学过做过背包问题，这道题相比较它来说，就很简单了 |
| 2021.11.07 |     <a href="#695-岛屿的最大面积">695-岛屿的最大面积</a>     | 这道题和P200是DFS/BFS类型的题，代码实现上只有些微差别。今后这几天就专注于递归、回溯、DFS/BFS等之类的题了，它们之间的关系有点绕 |
| 2021.11.08 |         <a href="#463-岛屿的周长">463-岛屿的周长</a>         | 此题也是属于岛屿类型的题目，比P200和P695简单许多，并且还有几种不需要DFS的解答方式，有点类似于智力题 |
| 2021.11.08 |         <a href="#827-最大人工岛">827-最大人工岛</a>         | 这道题是以上几道岛屿类型的题目中的最难的一道，可以“填海造陆”了。虽然花的时间比较久，但是还是做出来了，不过有一点疑惑，我采用Set保存了水域，最后“填海造陆”时就不用遍历整个二维数组了，但是它的效率在LeetCode上貌似还不如前者。另外，我貌似没看懂官方答案，还有看到有些使用并查集也能做，这个算法或者技巧我还没学过。 |
| 2021.11.09 |    <a href="#1444-切披萨的方案数">1444-切披萨的方案数</a>    | 本以为这是一道DFS题，感觉也是能够做出来的，我知道重复计算了一些，也优化了一下，可惜最终LeetCode上的测试用例没有通过完。中途也有想过这是不是一道动态规划的题，但是没有想到怎么用动态规划来做。搞了几个小时后，就去看别人怎么做的了，也是看了好久才理解到，真是难想啊，天，这道题连官方解答都没有，题解数加评论数才刚满100，哎，深深叹息。 |
| 2021.11.10 |  <a href="#1293-网格中的最短路径">1293-网格中的最短路径</a>  | 这道题有点像岛屿问题，也想网格中的不同路径问题，还有点像是动态规划的题。于是做这道题时，就在思考是否是用DFS，因为是求一个点到另一个点的最短路径嘛，然后由于有可以移除障碍物的功能在，就想这难道是一道动态规划的题？因为可以递归的求假设只能移除一个，然后求移除两个？然后又觉得不对，因为这题从四个方向都可以走，这个方程的值可能一直在变动，得不到最优解。然后就用DFS+回溯的方式去，先假设后续DFS完成后再回溯更改就行了，最后测试了一些感觉还真是写对了，但是在LeetCode上碰到如果是一个很大的二维数组的测试用例时，会出现超时，这也难怪，因为是求最短路径，这路径数是真的多。最后，看到别人用的BFS来做，我就想着自己也去试，哎，自己对BFS不熟练，写不出来，只有照着做了。这道题也是真的难，现在只看了一个题解，居然还用到了贪心算法，之前只是在学习的时候学过，印象不深，当然也就不会。感觉这个贪心是在如果使用动态规划做不到全局最优解时，才使用贪心来做一个局部最优解？还是得不能太大胆去做困难题啊，真是做不来，不过做了看了，希望以后碰到简单题，来个降维打击哈哈。 |
| 2021.11.11 | <a href="#1293-网格中的最短路径">1293(2)-网格中的最短路径</a> | 今天又用了一天硬是要搞这道题的DFS解法，太累人了，虽然最终通过了，但是耗时还是太多了，并且不能保证所有的以后的案例也能够通过。不过这两三天的硬着头皮做这几道难题，对DFS倒是熟悉了不少，哈哈。 |
| 2021.11.12 |        <a href="#93-复原 IP 地址">93-复原 IP 地址</a>        | 这道回溯题我是没想出来，对我来说还是蛮难的，最后还是在官方代码基础上更改的，并没本质提升。 |
| 2021.11.13 | <a href="#1254-统计封闭岛屿的数目">1254-统计封闭岛屿的数目</a> | 这道题目属于岛屿问题，与P200很类似，之前做过比此更难的，因此相对来说已经不难了，但是还是有些细节上的问题没有一开始就想到。 |
| 2021.11.13 |              <a href="#46-全排列">46-全排列</a>              | 今天这题又是一道回溯题，代码并不多，但是自己写就完全没这个思路。 |
| 2021.11.14 |             <a href="#494-目标和">494-目标和</a>             | 昨晚无意间做到牛客网上的华为题库中一道机试题HJ93，这道题之前理解错题意，做错了，并且自己也做不来，后来发现这道题是一道回溯的题，然后又发现，该题可以等价于这道LeetCode上的这道题，于是再把这道题给解决了，这题居然还能用动态规划做，看来这几个算法和思想真是互通的。 |
| 2021.11.15 |     <a href="#300-最长递增子序列">300-最长递增子序列</a>     | 最长递增子序列，最初做这道类似题是在牛客网的面经中碰到的，然后去做，那道题[**最长上升子序列(三)**](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481)要求的是求出所有的最长递增序列，并且还要求出按照字典排序最小的那个序列，然后做了好久。我首先认为是可以用回溯来做，最后也应该没错，但是题目有要求时间复杂度，回溯就肯定不满足了。于是在LeetCode上搜相关的题，首先搜到的是P673，想了一下，还是做不来，在看到官方答案时，有提示P300这道题是P673的前置题，就是简单一点的题，然后才来做这道题。在知道了是用动态规划解答的情况下，也还是想不出来这个转移过程，而至于贪心+二分查找，刚开始看就很懵。真是挺佩服这个贪心思想，真是想不到，还有这个最后二分查找结束后的那个插入或者赋值的下标真得注意，太模糊了。一道题一天，真是服了，现在的我心理压力好大啊，哎，继续加油吧。明天再独自做做P673。刚才看到了P673这道题评论中推荐的一个[解答](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/yi-bu-yi-bu-tui-dao-chu-zui-you-jie-fa-2-zui-chang/)中提到了个新名词——树状数组？ |
| 2021.11.16 | <a href="#673-最长递增子序列的个数">673-最长递增子序列的个数</a> | 这个题我真得吐了，动态规划的还好，那个贪心+树状数组的解答方式真是太烦了，也许是我最近生活越来越不规律，以及太过焦虑的缘故，真的好累。这个解答方式那就明天再看吧。 |
| 2021.11.17 | <a href="#673-最长递增子序列的个数">673(2)-最长递增子序列的个数</a> | 终于是终于按照答案写好了，那两个二分查找怎么写的，没有仔细看，感觉也是很难写好的。可是还是没有解决求出最小的这个最长上升子序列，后面继续加油吧。这个Flink项目不知道啥时候能做完噢，好漫长，还有刷题，虽然每天都在学，但是进度是真慢啊，哎，越学越没有信心。不过轻松一点的话，就好多了，只是我现在轻松不起来啊。 |
| 2021.11.18 |                             未做                             | 把时间耗在做项目上去了，然后遇到错误，一直去解决错误去了，哎，还是不能先做项目，后做题。 |
| 2021.11.19 |           <a href="#391-完美矩形">391-完美矩形</a>           | 今天还是先去做了项目，哎，差点又是不想做题了，以后还是乖乖地先刷题，再做其它的吧。今天我和华为的HR聊了一下哈哈，我也不知道我是否该选择那里了。还有这个项目到底是还做不噢，我不大确定了，感觉有些超出我的理解范围了，编程太多了，我还不了解理论。其它的面试题还没有复习。 |
| 2021.11.20 |       <a href="#563-二叉树的坡度">563-二叉树的坡度</a>       | 这道题还算简单，不过可能好久没有做到关于树的题了，对于树的递归、DFS还是愣了很久。这半个月来做这个Flink项目，真是太难了，今天又遇到问题了，感觉这个问题是解决不了了，我是不是应该选择放弃，多学一些其它的理论知识更好一些呢？还有差点连曾经做的数仓项目都不能正常运行了，真是焦急死了。 |
| 2021.11.21 |           <a href="#198-打家劫舍">198-打家劫舍</a>           | 有些时间没有做动态规划的题了，有感觉生疏了不少，以前写的有些代码都看不懂，或者说一时间反应不过来，没有曾经做题时的状态了。这道题我的第一感觉以为不该这么做，结果却是这样的，还真是拐不过弯来。 |
| 2021.11.21 |        <a href="#213-打家劫舍 II">213-打家劫舍 II</a>        | 这道题是上面道题的进阶版，多了个限制条件，也是自己尝试了好久，始终没能全部通过，只有看答案咯，而这个答案却是很好理解，但是还是感觉有点玄学的成分，真的这纯粹的就像是数学题了。 |
| 2021.11.22 |       <a href="#337-打家劫舍 III">337-打家劫舍 III</a>       | 二叉树类型的动态规划，又是做不起的一天，这些天的效率是真的明显下降了。 |
| 2021.11.23 |     <a href="#740-删除并获得点数">740-删除并获得点数</a>     | 这道题以看，完全没思路，或者说这两天没有思考题目的状态了，哎。万万没想到这道题可以转换为P198-打家劫舍问题。 |
| 2021.11.23 |            <a href="#55-跳跃游戏">55-跳跃游戏</a>            | 其实自己根本就没什么思路，能想到具体的算法名解决问题，这道题就靠着自己的思路解出来了，结果和官方的第二种方法一样。怎么看都不觉得这是个贪心的思想，我就认为只是个解题方式而已，没必要硬要给它取个名吧。也有可能是我还不够理解这些算法吧。 |
| 2021.11.24 |         <a href="#45-跳跃游戏 II">45-跳跃游戏 II</a>         | 之前也接触过贪心思想，这道题理解起来也还好，但是没有自己尝试写这个代码，照着答案敲了一下。 |
| 2021.11.25 |           <a href="#322-零钱兑换">322-零钱兑换</a>           | 还是不在状态，能够有感觉要这么做，但是还是没有清晰的思路，也写不出来代码。 |
| 2021.11.26 |        <a href="#518-零钱兑换 II">518-零钱兑换 II</a>        | 刚开始用类似于上一题的思路去解决此问题，只需要修改部分即可（其实在做的时候，还是迷迷糊糊的，只是感觉是如此），但是得到结果后发现这样会造成计算重复，和官方答案一比较，发现就是内外层循环位置的问题。并且还考虑过是否是一个二维的DP，但是看到官方答案的答案后，发现是一个一维的，并且有些难理解，所以跟着官方思路，结合凭着感觉的认为是二维的那个思路一思考，发现这个二维的思路和曾经最初学动态规划的那个背包问题很像，于是解决并不难。而当解决了二维的DP后，由于每一次的状态转换只与上一次的有关，依次可以将其转换为一维，并且若将外层循环改为增强for循环，就变成了和官方答案一模一样的代码实现。现在看来，这个学着学着，倒把以前的还忘了。评论里一堆人在讨论，为什么把那个coins放在外层循环，其实如果按照我的学习历程来看，放在外层的才是最基本正常的思维方式，而P322这个题的内外层循环的思维方式才是进行了特别处理的。这道题居然还和爬楼梯的题有相似之处，爬楼梯是一次选择一步或者两步，登上阶梯n步；而这道题是一次选择coins中一个值，选择若干个硬币后，价值为amount。前者为排列数，后者为组合数。 |
| 2021.11.27 |           <a href="#47-全排列 II">47-全排列 II</a>           | 今天又看了一下昨天的P518的相关的动态规划的题解，又多了些理解。今天这道回溯题，是之前做的P46的一道进阶题，做这个回溯题是真不熟练，前面做过几次回溯题，都有些卡顿，基本做不起。这一次本打算放弃了，但是稍稍看了一下P46的代码，其实也不大熟悉了，但是还是做出来了，我的想法也没错，一次搞定。但是始终没有达到那种进入刷题的那种冥想状态，哎，这种感觉真是既熟悉又陌生。今天又发现了两道类似岛屿的题目，这是我半个月前印象最深刻的题目了，但是由于没有复习，还是生了一些，下面几天做吧，等把现在收集的大概七道题做完后，就不能再去做太多新题了，应该着手巩固复习之前做的了。 |
| 2021.11.28 |        <a href="#1020-飞地的数量">1020-飞地的数量</a>        | 哈哈，没有翻以前写的代码，也还是写出来了，并且还同时写出了DFS、BFS两种解法，但是如果说状态，还是没有以前刚学岛屿问题时那么有印象和感觉。这种题连官方解答都没有，哎。再加一句，评论区有人说P130和这题很像，果然很像。 |
| 2021.11.29 |            <a href="#72-编辑距离">72-编辑距离</a>            | 这道动态规划题，不看答案真是想不出来怎么做啊/(ㄒoㄒ)/~~！它的`dp[i][j]`处的状态就由`dp[i][j−1],dp[i−1][j],dp[i−1][j−1])`处的状态转换而来。 |
| 2021.11.30 |   <a href="#145-二叉树的后序遍历">145-二叉树的后序遍历</a>   | 这是道简单题，使用递归实现还是蛮简单的，不过题目中提到是否能使用迭代的方式来解答，我一直对迭代和递归的差别不大了解，今天也没心情做这道题，等到明天来学习这个迭代吧。 |
| 2021.11.30 |    <a href="#1143-最长公共子序列">1143-最长公共子序列</a>    | 不敢确定最终答案的我，居然做对了哈哈，那一刻还是很兴奋的，这些天好久没有作对一道逐步分析做对的题目了。这道题是与P72有些相似，准确来说是同一类型的，并且还要简单一些，如果是想要循序渐进学习的话，确实该先做这题。但是既然已经存在降维打击了，就接受吧哈哈，都是题的嘛，怎么做都是做的。 |
| 2021.12.01 | <a href="#145-二叉树的后序遍历">145(2)-二叉树的后序遍历</a>  | 今天学了这个题的迭代实现，官方的看着好绕，有点懵。这个和迭代有啥关系啊？不就是不用递归，而是手动用栈实现就行了吗？ |
| 2021.12.02 |        <a href="#1905-统计子岛屿">1905-统计子岛屿</a>        | 同样是一道岛屿问题，解题思路以及代码实现都差不多的，我都感觉我快要把这类问题做完了哈哈。 |
| 2021.12.03 | <a href="#124-二叉树中的最大路径和">124-二叉树中的最大路径和</a> | 保存此题大概有一个月了，看到标的是困难标签并且以前是确实没思路，于是一直不敢做，做不起。在前几天我做了一道后序遍历的题目，然后不知道是在哪看到的还是自己想到的这道题是一个后序遍历，然后今天才开始做，一步步分析，发现这道题也并不是特别难的。整个代码结构就是一个二叉树递归实现的正常结构，只是要清楚结束条件是什么，返回值是什么，在遍历过程中需要求什么才是所需答案。有些二叉树题遍历的答案就是递归函数结束的返回值，而有些则是在历次遍历过程中与返回值相关的另一个值，当然该值在遍历各个结点的过程中也会随着返回值变化，例如本题代码实现中的`maxSum`。 |
| 2021.12.04 |         <a href="#5-最长回文子串">5-最长回文子串</a>         | 最长回文子串，这道题在很多地方都听到过了，都一直没做。动态规划的解题方式真是没想出来，而那个中心扩展算法，官方解答确实是根据根据动态规划的解题思路一步步总结而来的，但是最终代码实现完全看不到动态规划的影子。而这个中心扩展算法的做法，之前我也思考过，不过我只能想到从中间往两边找，但是没有它想的这么充分，也没有实现出来。 |
| 2021.12.05 | <a href="#1857-有向图中最大颜色值">1857(2)-有向图中最大颜色值</a> | 虽然前面做过一次，但是今天再回顾，还是同样的做不起，这个拓扑排序+动态规划，真是靠自己想，真想不出来噢，哪怕是告诉了思路，也不能自己手动实现敲出代码来。不过慢慢来嘛，哈哈。难题虽然男，但是当完成时是真的满满的充实感，并且还觉得挺有趣的。 |
| 2021.12.06 |             <a href="#207-课程表">207-课程表</a>             | 昨天找到了这道拓扑排序的题，又无意间发现还有P210_课程表Ⅱ，后面再做这道题吧。又发现搜索“课程表”会出现好几道类似相关的题目，哈哈，我就喜欢这种一个系列的题。由于昨天做了一道拓扑排序+动态规划的困难题，今天再做这道题，简单不少，其实我发现除了通用的BFS模板，对于这种拓扑排序题，也是有属于它的通用的模板。 |
| 2021.12.07 | <a href="#121-买卖股票的最佳时机">121-买卖股票的最佳时机</a> | 这道题虽然是一道动态规划的题，但是如果是在没有学动态规划之前做的话，我想也应该能够做出动态规划这种代码实现，而又正是因为学过了动态规划这种算法或者思想，或者说我提前知道了这是一道动态规划的题，我反而在做时，就不会去它的暴力解法，以及普通地不带入算法思想的只为解题而解题的思考了。 |
| 2021.12.08 | <a href="#122-买卖股票的最佳时机 II">122-买卖股票的最佳时机 II</a> | 这道题比昨天的多了一点点步骤，很小的差别。我做的动态规划，一步步优化，最终倒成了官方答案中的贪心算法，我也是醉了。虽然有这种理解，但是我还是觉得这有些为了说明而说明，为了使用而使用的感觉。而官方的动态规划和我的动态规划也不一样，初看还以为根本不是一回事，它的动态规划思路是`第 i 天交易完后手里没有股票的最大利润`和`第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）`，而我的是`截至到每天，每天的最大利润`，这直接包含了官方的这两种情况，然后就是要去想如何实现得到每天的最大利润。当看到这个题目后，我能想到的就是找到一个最低价格点，然后在紧接着的连续的后面某天最高价格处卖出就能得到最大利润值。于是想到了记录最小价格的天数索引，然后每遇到一个高于昨天的价格就卖，此时就是截至到今天能获取的最大利润，而如果今天价格低于了昨天的价格，说明截至到今天最大获利就是在昨天卖出股票后的获利，于是第一种方式就因此而来。而第二种方式是，让代码实现上看起来更像动态规划。而最后滚动数组的实现方式则变成了官方的贪心算法。另外我在评论区看到了个比较有意思的评论，`不会真有人觉得做了这题就能去炒股吧？这题不论是动态规划还是贪心都是一个思路，“事后诸葛亮”，就是在知道了今天的股市情况后去决定昨天的操作，只要今天相对于昨天涨了，就回昨天买股票，并在今天卖掉。如果今天相对于昨天跌了，就回昨天告诉自己不要买。`补充一下，我还是认为，这个不是贪心，这是肯定能得到最终最优答案的做法，这就是全局最优。 |
| 2021.12.09 |          <a href="#210-课程表 II">210-课程表 II</a>          | 此题又是前几天做过的那道课程表的进阶题，多了一点点不同，这次尝试了使用类似官方的BFS写法“`使用 List<List<Integer>> 构建邻接表`”，但是这种BFS的效率不及“`创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表`”这种方式的高。而使用DFS实现的方法，我还没做，有些力不从心了，这两天去做项目去了，时间一天天拖，真是太折磨了。 |
| 2021.12.10 | <a href="#123-买卖股票的最佳时机 III">123-买卖股票的最佳时机 III</a> | 靠自己做，走了好多弯路，错了好多次，花了五个小时才做出来，效率还很低，啊，艰难啊。而答案的思路真是太巧妙了，这个设定动态规划的方式不同，真的好影响性能，还是得慢慢学啊。 |
| 2021.12.11 |           <a href="#207-课程表">207(2)-课程表</a>            | 同下。                                                       |
| 2021.12.11 |        <a href="#210-课程表 II">210(2)-课程表 II</a>         | 这两道题都很相似，代码实现差不多，今天做的主要就是补充这两道题的DFS题解，发现DFS和BFS差不多，甚至效率还要更高些。但是还是参考了官方代码写出来的，真不敢保证一段日子后，是否还能做出来。 |
| 2021.12.12 | <a href="#188-买卖股票的最佳时机 IV">188-买卖股票的最佳时机 IV</a> | 前面几道相似题都是用的自己的思路，对于这道题再用我以前的思路有点难实现了，于是用了前几题官方的思路，在它们的基础上改变一下就是这道题的解题思路了。不过我还没细看这道题的官方解法，看着还挺多的，貌似还有些优化，等到明天再看吧。（第二天）看了一下这个官方题解，有点懵，但是和我的没有本质区别。看到了一个神奇的[题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-chong-ji-yu-wqs-er-fen-de-you-xiu-zuo-x36r/)，太厉害，到目前为止，我看到过的最难的，难的我都不想看它。 |
| 2021.12.13 |                             未做                             | 只复习了一下上一题的官方题解。                               |
| 2021.12.14 |         <a href="#630-课程表 III">630-课程表 III</a>         | 我今天原本就想做的这道题恰巧又是今天的每日一题，真是巧合哈哈。一直都没有刻意学习过贪心算法，只是在遇到问题时，感性一点地理解了一下贪心算法，原来贪心还是需要证明的，在我印象里一直就是我这么做不能保证得到完全正确答案，但是可能得到答案。这道题是值得长期巩固学习的。噢，对了，这道题和之前的两道课程表题的解题思路已经没有多大的相关性了。 |
| 2021.12.14 |         <a href="#1462-课程表 IV">1462-课程表 IV</a>         | 这道题就是判断有向图中两个节点之间是否可达，使用DFS需要在遍历过程中记忆结果，减少耗时。由于此题的特殊性，还可以使用现有算法——Floyd算法来解决。 |
| 2021.12.15 |                             同下                             | 同下。                                                       |
| 2021.12.16 |       <a href="#1494-并行课程 II">1494-并行课程 II</a>       | 花了差不多三天，两个通宵在做这个题（现在已经17号的凌晨三点了）。这题真是太牛了，走了好多冤枉路，先是尝试拓扑排序（BFS），未完全通过；然后尝试BFS加回溯，未完全通过；然后尝试BFS加回溯加贪心，未完全通过；最后硬着头皮去看他人的状态压缩DP的解答，开始时真想放弃，看得人都懵了，涉及到位运算，注释也不多，看得头痛。不过最后还好，总算理解了，并且自己写了有史以来字数最多的一次注释。但是现在回想起来，我这几天都在做这道题，没有复习其它的，是不是没有弄清楚主次？我找不到工作啊，还都是在凌晨六七点才睡觉/(ㄒoㄒ)/~~。 |
| 2021.12.17 |      <a href="#2050-并行课程 III">2050-并行课程 III</a>      | 今天凌晨睡得还是要早一点，睡的时候都在想这个题怎么做。白天也没有想不出来，但是一看到别人的题解思路，就知道怎么做了，也没看别人的代码就写出来了，哈哈。起初，其实我还以为这道题也可以用状态压缩DP做，但是看到题目的数量级很大，就能肯定是不能使用这个的，但是好奇心还是让我去试了一下，稍稍修改了上一题的代码，发现还是能通过几个案例的哈哈。 |
| 2021.12.18 | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368-使网格图至少有一条有效路径的最小代价</a> | 以为自己能做成功，结果DFS运行超时（此题等价于求最短路径，DFS不适合），使用BFS时对题的理解有些到位，没能全部通过。然后，看了一下别人的，差别其实不大，就是我认为是从左上更新就行了，其实并不是的，还是不能贪心的认为（尝试）这个能得到答案。比较起来，我如果将比较的代码换一下位置，再补上四个方向就对了。这道题还让我接触到了新的BFS算法，什么0-1BFS算法，SPFA算法，这些都是前人论文里的吧，没系统学习过，了解得好不全面。此外此题的最优解法是 Dijkstra 算法，以前学过看过，现在都忘记差不多了，也只有明天再看了。 |
| 2021.12.19 | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368(2)-使网格图至少有一条有效路径的最小代价</a> | 看了一下 Dijkstra 算法和 0-1 BFS，对于这道题来说，这两差不多啊，后者是前者的优化。 |
| 2021.12.20 | <a href="#1411-给 N x 3 网格图涂色的方案数">1411-给 N x 3 网格图涂色的方案数</a> | 这道题昨晚看时第一感觉以及思考方向都对了，但是推的过程错了，今天重推后改正了过来，但是即便是对了也还是没有想到代码怎么写，看了别人的两行解释，自己就明白了，哈哈，真是没想到可以这样思考递推公式。最后，这道题就很轻松地用递推来做了，其实看起来还是挺像动态规划的，说是动态规划也是可以的。这道题是Nx3的网格涂色，我还看到还有一道MxN网格的涂色问题，看别人的题解名字，好像还是道状态压缩DP题。 |
| 2021.12.21 |     <a href="#980-不同路径 III">980(2)-不同路径 III</a>      | 回过头来看这个曾经看不懂的解法——状态压缩 DP，这次总算看懂了，由于之前有了P1494这道状态压缩 DP 解题的经验，这道题就相对而言，简单不是一点半点，但是真要自己独立做出来的话，也还是蛮难的。说一个忘记记录的题外话，昨天我下载了几个WAV格式的无损CD，那低沉的声音真是惊艳到我了，然后发现采样率是1411kbps，碰巧我昨天做的题的题号也是1411，哈哈，这就是巧合吧。 |
| 2021.12.22 |                             同下                             | 同下。                                                       |
| 2021.12.23 | <a href="#1687-从仓库到码头运输箱子">1687-从仓库到码头运输箱子</a> | 第一印象还以为这是一道背包问题呢？结果并不是，但是能肯定的是这是一道动态规划题，不过自己也还是没有思路，就去看别人的题解。哇，又是让我崩溃的一题，看了好多答案，刚开始没有看懂，这些题解要么写的注释太少，要么说得太正式不易懂，不过还好，后来理解思想了。但是最难的却是在处理数组下标时搞了几个小时，可能是今天凌晨做时太疲倦了吧，睡觉时都在想。哎，这个月的效率都好差，跟不上计划，变笨了。 |
| 2021.12.24 |           <a href="#735-行星碰撞">735-行星碰撞</a>           | 以前看到这题时觉得用栈做挺难的，就放着一直没做，今天再做时，感觉也不是挺难的，哈哈，理解了怎么做后，用代码实现其实并不难哈哈。 |
| 2021.12.25 |     <a href="#594-最长和谐子序列">594-最长和谐子序列</a>     | 一下子不知道怎么做，最终解答还是蛮简单的。                   |
| 2021.12.26 |         <a href="#409-最长回文串">409-最长回文串</a>         | 刚开始看到是回文串被吓到了，其实也是挺简单的哈哈，这两天就不做难题了，先过渡一下。 |
| 2021.12.27 |         <a href="#825-适龄的朋友">825-适龄的朋友</a>         | 一开始只能使用暴力解法解决了，官方的那两种解法，没有想到。今天新学到了计数排序，哈哈。 |
| 2021.12.28 |             <a href="#69-Sqrt(x)">69-Sqrt(x)</a>             | 今天看到一个别人的面经，看得我头皮发麻，我好菜啊，好菜，都是些什么鬼题啊，还得努力啊。 |
| 2021.12.28 | <a href="#236-二叉树的最近公共祖先">236-二叉树的最近公共祖先</a> | 开始没有想法，但是慢慢地一步步推，还是做出来了，自我感觉比官方题解写得更好。 |
| 2021.12.29 | <a href="#864-获取所有钥匙的最短路径">864-获取所有钥匙的最短路径</a> | 哇塞，我都以为我做这种网格题做得够多了，DFS和BFS也都有些熟练了，但是这道题又是真滴难到了我。这道题又是一道题解和评论数均为过百的题，虽然有官方题解，但是，写得真是难懂，并且效率还不是很高，可能被其他的伙伴以更有的方式给解决了。官方题解还没仔细看，我挑了个代码看起来有条理和有注释的题解学习了一下。最终这道题不同于常规BFS的地方是，对于同一个位置方格，并不只是入队出队一次，在每次经过同一个方格时的状态会有所不同，而由于这个状态总数是有限的，可以用一个整型数表示出来，那么就想到了用状态压缩的方式，在还未达到最终的状态或者曾经没有遍历过这种状态时，都要再次将该方格入队，不过与之前该方格入队的不同点在于，此次再入队时的状态要与之前的不一致。其实再想想，常规的BFS就是一个点只遍历一次，只有一种状态——遍历过或者为遍历过，而现如今是，每个点存在数种状态，针对每个点的每种状态如果需要访问它，都要判断是否访问。 |
| 2021.12.30 |    <a href="#33-搜索旋转排序数组">33-搜索旋转排序数组</a>    | 果然都是纸老虎，前两天从别的面经里看到考了这道题，就去搜来看，一时间懵住了。今天再看，在已知要使用二分来解决这道题时，慢慢推理还是解出来了，但是花的时间还是蛮多的，没有能够在十几分钟二十分钟内解决这道题，看来能力还是不够啊。不过，不要灰心哈哈，我现在已经过了笔试了，得的分还不错，今天也做了性格测试，下周开始应该就要面试了，加油啊加油啊。马上又是新的一年了，貌似我得更新一下这个文档结构了。 |
| 2021.12.31 |         <a href="#226-翻转二叉树">226-翻转二叉树</a>         | 嘿嘿，做到简单题，愉快度过2021，哈哈哈。这道题其实就是在前序遍历或者后序遍历时，交换一下左右子结点就行啦。 |

### 2022年

|  完成时间  |                           题目编号                           |    难度    | 感受总结                                                     |
| :--------: | :----------------------------------------------------------: | :--------: | :----------------------------------------------------------- |
| 2022.01.01 | <a href="#2022-将一维数组转变成二维数组">2022-将一维数组转变成二维数组</a> |    简单    | 哈哈，平常我都是不做每日一题的，今天恰巧去看，发现LeetCode还藏着这些彩蛋呢！哈哈，今年就从简单开始吧。 |
| 2022.01.02 |     <a href="#516-最长回文子序列">516-最长回文子序列</a>     |    中等    | 今天可能是出去玩儿了的缘故，回来时还挺不在状态的，这道题怎么做的还是我在洗澡时结合以前做的那道回文子串的题想的，虽然慢，最后也还是做出来了。和官方的解法在动态规划的公式上是一致的，只是在循环遍历过程中先后顺序不一致，我是斜线，它是从最后一行往前遍历。在评论区又看到其它的解法说，将这个字符串反转后，求这两个字符串的最长公共子序列即为答案；另外还有一个对动态规划算法题的[讨论](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-si-yao-su-by-a380922457-3/)。 |
| 2022.01.03 |  <a href="#1143-最长公共子序列">1143(2)-最长公共子序列</a>   |    中等    | 昨天的那道题可以转换为求两字符串的最长公共子序列的长度来做，然后想了一下不知道怎么做，结果去查看了下，发现这道题在一个月前已经做过一次了，当时还写了许多的注释，但是这一天以来，都在想怎么做这道题，已经完全忘记曾经怎么做的了，不过可能是在查看上一题的题解中瞄到了以前或者他人写的这道题的代码，结合自己的推理也还是半信半疑地做了出来。与第一次的做法几乎一致，只是定义的dp数组长度不一样罢了，但就因为此，要多做一些初始化的赋值操作，代码看着多了些。 |
| 2022.01.04 | <a href="#208-实现 Trie (前缀树)">208-实现 Trie (前缀树)</a> |    中等    | 这道题其实是几天前的每日一题的前置题，当时觉得没时间，并且一下子吓住了，隔了这么多天才来补。这是我第一次接触到字典树，理解起来还算不难，真是佩服当初想到这些数据结构的人。明天呢，就做那道进阶难题，貌似要用到字典树+DFS。突发奇想，如果更改一下Trie类的实现，将isEnd改为记录该字符串（单词）出现的次数，是不是就是统计词频了？ |
| 2022.01.05 |                             未做                             |            |                                                              |
| 2022.01.06 |             <a href="#472-连接词">472-连接词</a>             |    困难    | 哎，虽然知道要使用字典树 + DFS才能解决，但是有些地方没想明白，没有完全做出来，我一开始就将所有的word都加入到字典树中，再一一遍历是否是连接词，结果对dfs方法的定义有些不准确，到底返回为true是表示是连接词呢还是字典树存在以该word单词呢？结果为了解决这个问题，官方解答中采用了，先对所有word进行排序，先判断长度较短的word是否是连接词，或者将其加入字典树中，这样就避免了每次某word时，字典树中已经保存了word这个单词，那么每次遍历都会返回true这种情况。那么其实这么说来，我还算是自己做出来了大部分的。 |
| 2022.01.06 |           <a href="#6-Z 字形变换">6-Z 字形变换</a>           |    中等    | 今天TAN一下子面了三轮，都面试完了通过了，我还没有开始面呢！搞得我好焦急啊。这道题他说是今天的面试题，做了一下，也不难，关键还是对于数组下标的确定，属于基本操作吧。突然灵感一想，这是不是也可以用来当作加密算法啊？ |
| 2022.01.07 |         <a href="#994-腐烂的橘子">994-腐烂的橘子</a>         |    中等    | 恰巧翻到那个统计各公司最近考了哪个题的网站，看到这道题华为昨天考过，就拿来做做。这道题属于网格问题了，由于有了之前更难的类似类型的题的经验，这道题相对于现在的我来说，已经不是那么难了。但是还是需要半个小时才能写完，不过还好，错误次数不是很多。 |
| 2022.01.08 | <a href="#103-二叉树的锯齿形层序遍历">103-二叉树的锯齿形层序遍历</a> |    中等    | 又是在那网站上随意挑了一道频率高的，貌似还是第一次做而二叉树的层序遍历的题目，和昨天做的P994一样，用到了BFS，并且，在理论上，最后那一次循环不应该再遍历，但是P994可以通过新鲜橘子数目是否大于0来判断最后一次循环是否继续，而在这道题的层序遍历中则不能。对于官方解法，思路有一些小小的不同，整体来看，我思考得更复杂了些。 |
| 2022.01.09 |   <a href="#729-我的日程安排表 I">729-我的日程安排表 I</a>   |    中等    | 原本是想着今天能够去找一个线段树的题，学习一下这种数据结构。于是使用标签搜索了，发现大多数的都是困难题，没敢点（因为今天不想花太多时间），然后就找了一道这里面的是一个系列的题。而这道题的官方官方也没讲到什么线段树，倒是在评论区看到“线段树”的字眼。那后面再学吧。 |
| 2022.01.10 |  <a href="#731-我的日程安排表 II">731-我的日程安排表 II</a>  |    中等    | 今天继续接着做，还是没做起噢，直接看答案了，这个边界计数真是机智。啊啊啊，昨天怎么感觉大半天都是在交流，都没有咋复习。又可能明天就有面试了，啊，还没准备好。不过知道了个新玩意儿，叫倒排索引。 |
| 2022.01.11 |         <a href="#101-对称二叉树">101-对称二叉树</a>         |    简单    | 这道题是今天的一面面试题，哎哟喂，吓死我了，最开始看到这道题，知道很简单，但是一下子用常规的递归思路确实没想出来，不过，很快我就转变思考方式，采用层序遍历，再加上找到的小规律做出来了。虽然中途还是遇到了些bug，面试官也在帮着看，有些地方，按着他说的改，但是基本上主动权还是在我儿，很多地方都是自己独立改好的，他也没提示。 |
| 2022.01.12 | <a href="#732-我的日程安排表 III">732-我的日程安排表 III</a> |    困难    | 今天做题，突然感觉自己好笨，感觉脑子动不起来了，像是停住了一样，啥东西都忘了，真是悲催，希望明天不这样了。这道题前几天都在做相似的，但是今天看到还是没有思路，然而答案却十分简单，如果真是理解投了第二道题，这道题是真的很简单的。不过官方解的效率确实不高，其它伙伴上传的题解中又出现了线段树，不过我还没学，看起来是真费劲。感觉有点累，我想休息了，等待下周的面试。 |
| 2022.01.13 | <a href="#747-至少是其他数字两倍的最大数">747-至少是其他数字两倍的最大数</a> |    简单    | 开始我还真想复杂了，以为是TreeMap或者PriorityQueue，最后一想，不就是求最大值和第二大值的位置吗？ |
| 2022.01.13 |   <a href="#334-递增的三元子序列">334-递增的三元子序列</a>   |    中等    | 由于之前做过了LIS，这道题确实就变得简单多了。不过使用动态规划会超时，只能使用贪心，而这道题由于有三元子序列的限制，也就用不到二分查找了。 |
| 2022.01.14 |     <a href="#239-滑动窗口最大值">239-滑动窗口最大值</a>     |    困难    | 还是不够聪明啊，今天也不够状态，这个题的官方第一种方法是优先队列，我用的也是优先队列，但是没有官方题解那么聪明，我一直主动维护滑动窗口的大小，而官方确实，在检测到不满足要求时，才处理，可以减少很多的查找和删除操作，因此也就没有超时。而第二种方法是使用了单调队列，这个之前学习过，可以说是，看到单调队列几个字，就能立刻反应怎么做，但是这里呢，官方又聪明了一下，单调队列中不是保存的具体递减的每个数的值，而是其在数组中的下标。而对于第三种方法，还没看，明天再说吧，今天就不看了。 |
| 2022.01.15 |        <a href="#1001-网格照明">1001-网格照明(0)</a>         |    困难    | 同下。                                                       |
| 2022.01.16 |          <a href="#1001-网格照明">1001-网格照明</a>          |    困难    | 昨天停了一天的水的电，真是的。这道题昨晚没解决，走了些弯路，还是第一次不是因为超时，而是因为超内存限制而出错，所以说采取正确的数据结构很重要啊。这道题有点考验智商，就看谁能不能想到将二维表示各点，转换到线性的用线来表示一行、一列、一斜线上的各点了。此题我发了[题解](https://leetcode-cn.com/problems/grid-illumination/solution/60msjie-zhi-dao-20220116jin-hu-shuang-ba-c961/)。 |
| 2022.01.17 | <a href="#1220-统计元音字母序列的数目">1220-统计元音字母序列的数目</a> | 算不上困难 | 这道题的解题思路有些类似P1411，还有些像我的笔试第三题，状态转移方程很好推出来，我倒是在数据可能很大，故要取模这里浪费了不少时间，错了很多次。另外这道题也有矩阵快速幂的解法。还没看，其实有些不想看哈哈。 |
| 2022.01.18 |         <a href="#539-最小时间差">539-最小时间差</a>         |    中等    | 这道题，不想多说。开始犯了些错误，后面换了一种方法做对了，并且和官方解思路和代码实现都几乎一样，哈哈。看到了一个新词——鸽笼原理，其实这很像是我思考计数排序的过程，不过没有细想。 |
| 2022.01.19 |       <a href="#217-存在重复元素">217-存在重复元素</a>       |    简单    | 没啥单独说的，和下一题一起说。                               |
| 2022.01.19 |    <a href="#219-存在重复元素 II">219-存在重复元素 II</a>    |    简单    | 这两道题本质差不多。不过由于看了提示，知道了使用哈希表、滑动窗口可以解题，这确实让自己少了些思考过程，以后得注意了。另外，看了这道题的官解才知道原来可以通过`hashSet.add(num)`返回值来判断原`hashSet`中是否存在`num`，这样在后续要添加该`num`的情况下，就不需要通过`hashSet.contains(num)`来判断了。 |
| 2022.01.20 |   <a href="#220-存在重复元素 III">220-存在重复元素 III</a>   |    中等    | 哎，有些心累，还有种方法没看，今天不想看了，等明天二面结束后再说吧，希望就能暂时解脱了。 |
| 2022.01.21 |                             未做                             |            | 今天技术二面面试，做了这道题。给定两个相同长度的整数数组，交换一次两数组中的某个元素，使得交换后的两个数组和的差的绝对值最小，输出交换的元素位置，若无需交换返回 -1 |
| 2022.01.22 |    <a href="#1332-删除回文子序列">1332-删除回文子序列</a>    |    简单    | 今天傍晚知道二面挂了，哎，多的不说了，在那个文档了说过了。这道题是今天的每日一题，看着打的是简单标签，但是真正自己思考怎么做时，完全没头绪，还认为是很难，结果到头来更像是一个脑筋急转弯的题目，真是没想到是这样的。 |
| 2022.01.23 |      <a href="#2034-股票价格波动">2034-股票价格波动</a>      |    中等    | 今天学习复习二面的那些没有回答上的知识点，发现容器不就是集合吗？我不知道这个说法，真是好冤好冤。这道题首先可以确定是肯定要使用Map的，而我以为只使用一个就能解决问题，解决是能解决，只是会超时。看了下官解后，原来都是要使用到多个结构才能在O(1)的时间内返回答案，也就不会超时了。总体来说并不难，就是对题目的理解而思考应当怎样使用怎样的数据结构，知道要使用哈希表后，就是考察对哈希表的基本操作了。不过我现在有点慌，就先不看第二种解决方式了，我该继续复习基础了。现在都过了十二点了，年前最后一周了，希望能有机会再面吧。 |
| 2022.01.24 | <a href="#2045-到达目的地的第二短时间">2045-到达目的地的第二短时间</a> |    困难    | 此题虽然是困难，但是还好我之前就对这个拓扑排序比较熟悉了，即使距离上一次做这种题有一段时间了，但是还是做出来了大半，最后超时了。看了一下官解思路，添加了一个类似于起记忆化作用的数组，用了略微不同于它的思考方式做出了此题，还是蛮开心的哈哈。噢，顺便说一句，我可能要面成都的部门了，看明天的交流情况了。 |
| 2022.01.25 |                             未做                             |            | 成都的部门的一面面试，题目和LeetCode2121很像。               |
| 2022.01.26 | <a href="#2121-相同元素的间隔之和">2121-相同元素的间隔之和</a> |    中等    | 昨晚面试，搜到了这道相似题，今天再来做。如果使用昨晚的思路能做出来，但是会超时O(N^2)，看了一下官方答案，不仅要用到前缀和，还要用到后缀和，真的很巧妙啊。今天好累啊，没有学习其它的内容，明晚就是二面了。 |
| 2022.01.27 |                             未做                             |            | 给一非空的单词列表，返回前 k 个出现次数最多的单词。输出k个单词，应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 |
| 2022.01.28 |                             未做                             |            | 主管面被刷了，继续加油吧，年后面另一个部门吧。               |
| 2022.01.29 |    <a href="#1765-地图中的最高点">1765-地图中的最高点</a>    |    中等    | 多源 BFS，半猜半做的，只是觉得应该这么做，并且做对了哈哈。   |
| 2022.01.30 | <a href="#884-两句话中的不常见单词">884-两句话中的不常见单词</a> |    简单    | 虽说这道题是简单题，但是最初实在是没想到官方这种很聪明的问题解决思路，导致我走了好多弯路。更夸张的是我在遍历哈希表的同时，还涉及到了对其元素的删除，这样就碰到了一个曾经遇到过的异常，并且这次做法的思路都是有问题的，如果这道题是放在面试时做的话，按照今天的做法以及时间，我是肯定要被挂了的。 |
| 2022.01.31 | <a href="#1342-将数字变成 0 的操作次数">1342-将数字变成 0 的操作次数</a> |    简单    | 因为做不起那道本来想做的难题，也没心思看题解，才来做这道今天的每日一题。简简单单地跨年咯。 |
| 2022.02.01 | <a href="#1763-最长的美好子字符串">1763-最长的美好子字符串</a> |  真不简单  | 虎年第一天哈哈。这道题真是没有思路做，只有看答案了。滑动窗口的解法现在不想看。脑子又变笨了啊。 |
| 2022.02.02 |      <a href="#2000-反转单词前缀">2000-反转单词前缀</a>      |    简单    | 又是一道简单，这道题才算是真正的简单嘛，你说是吧。           |
| 2022.02.03 | <a href="#1414-和为 K 的最少斐波那契数字数目">1414-和为 K 的最少斐波那契数字数目</a> |    中等    | 这道题虽然看到提示是贪心，但是完全没想到是参考答案那种贪心，我只是简单的以为先选择大的，那么最终的结果数目就会尽量小了，于是就用到了递归或者DFS（我也没分太清是什么）来做，并且我也不敢相信我没有经过太多的修改，一两次就做对了，哈哈。最后再去看官方的贪心解法，这个原来贪心还真是需要先证明的，我还以为贪心是不能证明的，只能抱着试一试的心态去“贪心”的求解，原来只是很难证明罢了。虽然和贪心的思路以及它的代码实现不一样，但是我的解法最终在求解和为`k`的每个斐波那契数字的时候其实和贪心解法是一样的，都是先找到的最大值并没有回溯太多，因为根据贪心证明，只要每次选择最大的斐波那契数字最后就能得到最终答案了。 |
| 2022.02.04 | <a href="#1725-可以形成最大正方形的矩形数目">1725-可以形成最大正方形的矩形数目</a> |    简单    | 思路还是蛮简单的，不多说啦，十分钟就能解决。                 |
| 2022.02.05 |          <a href="#1219-黄金矿工">1219-黄金矿工</a>          |    中等    | 今天的这道每日一题，没看题目之前我是没有想到是类似网格岛屿问题的，题目看完后，一点都不怕哈哈，我还是挺喜欢做这个网格类使用DFS或BFS来解决的这类问题的，不过这道题还需要在DFS的基础上还要加上一个小回溯要求，哈哈，之前有做过类似的，这道题对我来说，还算简单啦。 |
| 2022.02.06 |      <a href="#1748-唯一元素的和">1748-唯一元素的和</a>      |    简单    | 今天的简单的“每日一题”，不多说啦，就是要注意数据范围，数据范围比较小时是可能可以使用数组代替哈希表记录也是可以的。 |
| 2022.02.06 |      <a href="#1701-平均等待时间">1701-平均等待时间</a>      |    中等    | 昨晚看到这个题时还有点迷糊，然后睡觉或者其它某时刻都偶尔在想怎么做这道题。哈哈，果然我的基本逻辑思路是没问题的，比之其他人的，在代码上还是稍稍多了几行，但是解题核心思想没有太大区别。 |
| 2022.02.07 |    <a href="#1405-最长快乐字符串">1405-最长快乐字符串</a>    |    中等    | 哎，万万没想到这道题让我做了差不多四个小时，况且这个完成的方法在理论上还有点没说清，可能这就是贪心算法很难证明吧。啊啊啊，明天下午就要面试，还说今天晚上复习呢，结果却做了这么久。不管怎么样加油加油吧，我也只能说这个了哈哈。 |
| 2022.02.08 |          <a href="#64-最小路径和">64-最小路径和</a>          |    中等    | 今天一面了，做的是一道做过的题，哈哈739温度题。今天的每日一题之前做过，就没去再重做了。这道题是我随便找的，发现也是和以前的某道题很像。 |
| 2022.02.09 |    <a href="#347-前 K 个高频元素">347-前 K 个高频元素</a>    |    中等    | 这道题和之前的那道面试题很像，虽然知道要用堆或者TreeMap来做，但是由于此题限制了时间复杂度，让我想了好一阵也没有想出来，看到官解后才知道巧妙在何处。另外此题还可以通过快排来实现，哎，又不想看。 |
| 2022.02.10 |          <a href="#1447-最简分数">1447-最简分数</a>          |    中等    | 这道数学题我做不来，不知道怎么求最大公约数。                 |
| 2022.02.10 | <a href="#2006-差的绝对值为 K 的数对数目">2006-差的绝对值为 K 的数对数目</a> |    简单    | 这道题很像LeetCode的第一题求两数之和，由于数据的范围很小，所以可以使用计数的方式代替哈希表记录求解。 |
| 2022.02.11 | <a href="#1984-学生分数的最小差值">1984-学生分数的最小差值</a> |    简单    | 还算简单，没啥想说的。                                       |
| 2022.02.12 | <a href="#215-数组中的第K个最大元素">215-数组中的第K个最大元素</a> |    中等    | 做出来不难，难的是不使用API，自己构建堆和自己写快排。可我现在不想写，我感觉我越来越不想深究算法和学习新的算法了。 |
| 2022.02.13 |  <a href="#1189-“气球”的最大数量">1189-“气球”的最大数量</a>  |    简单    | 话不多说，蛮简单的，没什么特别需要注意的点或技巧。           |
| 2022.02.13 | <a href="#1712-将数组分成三个子数组的方案数">1712-将数组分成三个子数组的方案数</a> |    中等    | 这题隔了很久才来做，我反正是觉得好难啊，真别小看数组类的题目，有些真是蛮难的。这道题要用到二分查找，写二分也蛮难的。 |
| 2022.02.14 | <a href="#1712-将数组分成三个子数组的方案数">1712(2)-将数组分成三个子数组的方案数</a> |    中等    | 晚上睡觉都在想怎么优化和使用三指针做，做着做着发现了某种结论，然后才能三指针。单从做的过程来说，这道题真是算得上困难了，让我苦恼了好久。 |
| 2022.02.14 | <a href="#540-有序数组中的单一元素">540-有序数组中的单一元素</a> |    中等    | 这道题，刚开始我还以为我做不起，但是只要一步步分析就能做出来，只是不能达到官方解法那样简洁。还有这道题哈哈，有点应今天的景，真是有心了哈哈。 |

## 算法理论/问题/区别/总结

### 问题

###### 1.递归、回溯和深度优先搜索(DFS)的区别？动态规划？记忆化搜索（递归？）？

从第<a href="#509-斐波那契数">509</a>题貌似可以看到动态规划其实在有些时候是递归的一种优化？减少递归过程中的计算次数？

2021.11.27

在做P518时，看到了一篇讲解P509和P518的[题解](https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/)，主要讲了一些关于动态规划的套路，也得到了一些思路。

递归是自顶向下，动态规划是自底向上。记忆化搜索（递归）或者带备忘录的搜索（递归）产生的这个数组，其实和动态规划数组最终结果是一样的。这样来看，虽然递归和动态规划有些类似，但是还是有区别，反而是迭代和动态规划的关系更加亲密一点。

2022.01.02

P516的[某个题解](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-si-yao-su-by-a380922457-3/)的评论区中的对动态规划的讨论

> 算法题，其实不是先有了公式或方法才有思路，而是先有思路，把思路用公式、算法表示出来才有了公式、算法。dp的递推公式不是本质，本质是理解动态规划是带记事本的暴力循环
>
> 动态规划适用于能够利用暴力树解决的问题，动态规划通过打表格的方式对暴力树进行剪枝操作。实质上动态规划只是优化手段。个人拙见。

###### 2.迭代？和深度优先搜索有关系吗？——2021.11.08

P463

2021.12.06

来源：P207的官方解答的复杂度分析

递归和深度优先搜索有关系（等价？），迭代和广度优先搜索有关系（等价？）

###### 3.是不是动态规划不适合的时候，就要考虑贪心？——2021.11.10

###### 4.回溯就是在DFS的基础上记忆曾经遍历的过程，在回退过程中会被修改？——2021.11.12

P93

###### 5.回溯 DFS的一些评论

> [评论区](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)
>
> 计算机领域的一些大神爱造词，明明是 DFS 非要叫回溯算法，「明明老一套的神经网络非要起个名称，叫深度学习，明明是加权和非要起个名字叫卷积，明明是对输入加权，非要起个名字叫注意力机制，还有什么 transform」
>
> 「明明是深度优先搜索，非要起个名字叫“回溯法”，就是根据约束剪枝，非要起个名字叫限界函数，明明就是广度优先搜索，非要起个名字叫分支限界。」
>
> 我觉得可以把回溯理解成dfs的一个特殊情况，特殊之处在于一般的dfs完之后不会去清理或者处理当前的结果，因为结果不会影响后续的遍历；但是回溯需要去处理当前的结果，即回到原始状态，这样不会干扰下一次循环。
>
> 回溯算法就是 DFS。把使用回溯算法的「树形结构」画出来，得到一个问题的所有的解的方式，就是在这个树形结构上执行一次深度优先遍历。
>
> 有「撤销操作」是因为深度优先遍历回到以前来过的地方的某个地方时候，相关的变量需要恢复成以前一样，这样去尝试新的方案的时候才是有效的。
>
> 要通过「遍历」所有可能的解的方式得到一个问题的所有的解的时候，就会有「撤销选择」这种操作。

2021.12.05

今天做P1857时，采用了拓扑排序，我想说它不就是个用BFS或者DFS实现的吗？我都怀疑这个是不是也是为了取名而取名。

###### 6.树状数组——2021.11.16

###### 7.拓扑排序不是一种排序算法吧？只是对有向图中节点的一种特定排序规则（现象）的一个命名吧？——2021.12.06

### 排序算法

| 排序算法 | 平均时间复杂度 |     最好情况     |     最坏情况     | 空间复杂度 | 排序方式  | 稳定性 |
| :------: | :------------: | :--------------: | :--------------: | :--------: | :-------: | :----: |
| 冒泡排序 |     O(n^2)     |       O(n)       |      O(n^2)      |    O(1)    | In-place  |  稳定  |
| 选择排序 |     O(n^2)     |      O(n^2)      |      O(n^2)      |    O(1)    | In-place  | 不稳定 |
| 插入排序 |     O(n^2)     |       O(n)       |      O(n^2)      |    O(1)    | In-place  |  稳定  |
| 希尔排序 |   O(n log n)   | O(n (log n) ^ 2) | O(n (log n) ^ 2) |    O(1)    | In-place  | 不稳定 |
| 归并排序 |   O(n log n)   |    O(n log n)    |    O(n log n)    |    O(n)    | Out-place |  稳定  |
| 快速排序 |   O(n log n)   |    O(n log n)    |      O(n^2)      |  O(log n)  | In-place  | 不稳定 |
|  堆排序  |   O(n log n)   |    O(n log n)    |    O(n log n)    |    O(1)    | In-place  | 不稳定 |
| 计数排序 |    O(n + k)    |     O(n + k)     |     O(n + k)     |    O(k)    | Out-place |  稳定  |
|  桶排序  |    O(n + k)    |     O(n + k)     |      O(n^2)      |  O(n + k)  | Out-place |  稳定  |
| 基数排序 |    O(n x k)    |     O(n x k)     |     O(n x k)     |  O(n + k)  | Out-place |  稳定  |

> [来源链接](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)
>
> ![排序算法比较图](.\pictures\排序算法比较图.png)

### 其它算法

#### 布隆过滤器 Bloom Filter

[参考链接](https://blog.csdn.net/jiaomeng/article/details/1495500)

#### 倒排索引

[链接](https://www.cnblogs.com/zlslch/p/6440114.html)

## 算法分类

### 排序算法

| 排序算法 | 字符串 |                   一维数组                   |                 单向链表                  |  栈  | 队列 | 树（二叉树） |  图  |
| :------: | :----: | :------------------------------------------: | :---------------------------------------: | :--: | :--: | :----------: | :--: |
| 冒泡排序 |        |                                              |                                           |      |      |              |      |
| 选择排序 |        |                                              |                                           |      |      |              |      |
| 插入排序 |        |                                              | <a href="#147-对链表进行插入排序">147</a> |      |      |              |      |
| 希尔排序 |        |                                              |                                           |      |      |              |      |
| 归并排序 |        |                                              |                                           |      |      |              |      |
| 快速排序 |        | <a href="#215-数组中的第K个最大元素">215</a> |                                           |      |      |              |      |
|  堆排序  |        |                                              |                                           |      |      |              |      |
| 计数排序 |        |      <a href="#825-适龄的朋友">825</a>       |                                           |      |      |              |      |
|  桶排序  |        |                                              |                                           |      |      |              |      |
| 基数排序 |        |                                              |                                           |      |      |              |      |

### 查找算法

| 查找算法 |                             数组                             |        其它（数学题）        |
| :------: | :----------------------------------------------------------: | :--------------------------: |
| 二分查找 | <a href="#33-搜索旋转排序数组">33</a>、<a href="#35-搜索插入位置">35</a>、<a href="#540-有序数组中的单一元素">540</a>、<a href="#1712-将数组分成三个子数组的方案数">1712</a> | <a href="#69-Sqrt(x)">69</a> |
| 插值查找 |                                                              |                              |

> 线性查找、斐波那契（黄金分割法）查找

### 基础算法

> 使用单一算法就能解决的问题

|            算法            |                            字符串                            |                           一维数组                           |                           二维数组                           |                单向链表                 |              双向链表               |                              栈                              |                             队列                             |                            二叉树                            |                        堆（优先队列）                        |               平衡二叉树、有序集合（TreeMap）                |              前缀树、字典树               |                            有向图                            |                            无向图                            |                        其它（数学题）                        |
| :------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :---------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :---------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|          基本操作          | <a href="#1189-“气球”的最大数量">1189</a>、<a href="#1332-删除回文子序列">1332</a>、<a href="#2000-反转单词前缀">2000</a> | <a href="#42-接雨水">42</a>、<a href="#409-最长回文串">409</a>、<a href="#539-最小时间差">539</a>、<a href="#594-最长和谐子序列">594</a>、<a href="#747-至少是其他数字两倍的最大数">747</a>、<a href="#1725-可以形成最大正方形的矩形数目">1725</a>、<a href="#1748-唯一元素的和">1748</a> | <a href="#6-Z 字形变换">6</a>、<a href="#2022-将一维数组转变成二维数组">2022</a>、<a href="#1701-平均等待时间">1701</a> | <a href="#237-删除链表中的节点">237</a> |                                     |               <a href="#735-行星碰撞">735</a>                |                                                              |                                                              | <a href="#215-数组中的第K个最大元素">215</a>、<a href="#239-滑动窗口最大值">239</a>、<a href="#347-前 K 个高频元素">347</a> | <a href="#729-我的日程安排表 I">729</a>、<a href="#731-我的日程安排表 II">731</a>、<a href="#732-我的日程安排表 III">732</a> | <a href="#208-实现 Trie (前缀树)">208</a> |                                                              |                                                              | <a href="#1342-将数字变成 0 的操作次数">1342</a>、<a href="#1447-最简分数">1447</a> |
|           哈希表           |         <a href="#884-两句话中的不常见单词">884</a>          | <a href="#217-存在重复元素">217</a>、<a href="#219-存在重复元素 II">219</a>、<a href="#409-最长回文串">409</a>、<a href="#594-最长和谐子序列">594</a>、<a href="#2006-差的绝对值为 K 的数对数目">2006</a> | <a href="#391-完美矩形">391</a>、<a href="#1001-网格照明">1001</a> |   <a href="#146-LRU 缓存机制">146</a>   | <a href="#146-LRU 缓存机制">146</a> |                                                              |                                                              |                                                              |            <a href="#2034-股票价格波动">2034</a>             |            <a href="#2034-股票价格波动">2034</a>             |                                           |                                                              |                                                              |                                                              |
|            递归            |                                                              |                                                              |                                                              |                                         |                                     |                                                              |                                                              | <a href="#101-对称二叉树">101</a>、<a href="#124-二叉树中的最大路径和">124</a>、<a href="#145-二叉树的后序遍历">145</a>、<a href="#226-翻转二叉树">226</a>、<a href="#236-二叉树的最近公共祖先">236</a> |                                                              |                                                              |                                           |                                                              |                                                              | <a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>、<a href="#1414-和为 K 的最少斐波那契数字数目">1414</a> |
|            迭代            |                                                              |                                                              |              <a href="#463-岛屿的周长">463</a>               |                                         |                                     |                                                              |                                                              | <a href="#101-对称二叉树">101</a>、<a href="#145-二叉树的后序遍历">145</a> |                                                              |                                                              |                                           |                                                              |                                                              |                                                              |
|            回溯            |              <a href="#93-复原 IP 地址">93</a>               | <a href="#46-全排列">46</a>、<a href="#47-全排列 II">47</a>、<a href="#494-目标和">494</a> | <a href="#980-不同路径 III">980</a>、<a href="#1219-黄金矿工">1219</a> |                                         |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |                                                              |                                                              |                                                              |
|          分治算法          |         <a href="#1763-最长的美好子字符串">1763</a>          |                                                              |                                                              |  <a href="#23-合并K个升序链表">23</a>   |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |                                                              |                                                              |                                                              |
|          贪心算法          |           <a href="#1405-最长快乐字符串">1405</a>            | <a href="#45-跳跃游戏 II">45</a>、<a href="#55-跳跃游戏">55</a>、<a href="#334-递增的三元子序列">334</a> |                                                              |                                         |                                     |                                                              |                                                              |                                                              |              <a href="#630-课程表 III">630</a>               |                                                              |                                           |                                                              |                                                              |    <a href="#1414-和为 K 的最少斐波那契数字数目">1414</a>    |
|          动态规划          | <a href="#5-最长回文子串">5</a>、<a href="#72-编辑距离">72</a>、<a href="#516-最长回文子序列">516</a>、<a href="#1143-最长公共子序列">1143</a> | <a href="#42-接雨水">42</a>、<a href="#121-买卖股票的最佳时机">121</a>、<a href="#122-买卖股票的最佳时机 II">122</a>、<a href="#123-买卖股票的最佳时机 III">123</a>、<a href="#188-买卖股票的最佳时机 IV">188</a>、<a href="#198-打家劫舍">198</a>、<a href="#213-打家劫舍 II">213</a>、<a href="#300-最长递增子序列">300</a>、<a href="#322-零钱兑换">322</a>、<a href="#518-零钱兑换 II">518</a>、<a href="#673-最长递增子序列的个数">673</a>、<a href="#740-删除并获得点数">740</a>、<a href="#746-使用最小花费爬楼梯">746</a> | <a href="#62-不同路径">62</a>、<a href="#63-不同路径 II">63</a>、<a href="#64-最小路径和">64</a>、<a href="#494-目标和">494</a>、<a href="#1444-切披萨的方案数">1444</a> |                                         |                                     |                                                              |                                                              |             <a href="#337-打家劫舍 III">337</a>              |                                                              |                                                              |                                           |                                                              |                                                              | <a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>、<a href="#1220-统计元音字母序列的数目">1220</a>、<a href="#1411-给 N x 3 网格图涂色的方案数">1411</a> |
|        状态压缩 DP         |                                                              |                                                              |                                                              |                                         |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |             <a href="#1494-并行课程 II">1494</a>             |                                                              |                                                              |
|      深度优先搜索 DFS      |                                                              |                                                              | <a href="#200-岛屿数量">200</a>、<a href="#463-岛屿的周长">463</a>、<a href="#695-岛屿的最大面积">695</a>、<a href="#827-最大人工岛">827</a>、<a href="#1020-飞地的数量">1020</a>、<a href="#1254-统计封闭岛屿的数目">1254</a>、<a href="#1905-统计子岛屿">1905</a> |                                         |                                     | <a href="#200-岛屿数量">200</a>、<a href="#695-岛屿的最大面积">695</a> |                              ——                              |             <a href="#563-二叉树的坡度">563</a>              |                                                              |                                                              |       <a href="#472-连接词">472</a>       | <a href="#207-课程表">207</a>、<a href="#210-课程表 II">210</a>、<a href="#1462-课程表 IV">1462</a> |                                                              |                                                              |
|      广度优先搜索 BFS      |                                                              |                                                              |                                                              |                                         |                                     |                                                              | <a href="#200-岛屿数量">200</a>、<a href="#695-岛屿的最大面积">695</a>、<a href="#864-获取所有钥匙的最短路径">864</a>、<a href="#994-腐烂的橘子">994</a>、<a href="#1020-飞地的数量">1020</a>、<a href="#1254-统计封闭岛屿的数目">1254</a>、<a href="#1765-地图中的最高点">1765</a>、<a href="#1905-统计子岛屿">1905</a> |        <a href="#103-二叉树的锯齿形层序遍历">103</a>         |                                                              |                                                              |                                           | <a href="#207-课程表">207</a>、<a href="#210-课程表 II">210</a>、<a href="#1462-课程表 IV">1462</a> | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a>、<a href="#2045-到达目的地的第二短时间">2045</a> |                                                              |
|         普里姆算法         |                                                              |                                                              |                                                              |                                         |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |                                                              |                                                              |                                                              |
|       克鲁斯卡尔算法       |                                                              |                                                              |                                                              |                                         |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |                                                              |                                                              |                                                              |
| 迪杰斯特拉（Dijkstra）算法 |                                                              |                                                              |                                                              |                                         |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |                                                              | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> |                                                              |
|   弗洛伊德（Floyd）算法    |                                                              |                                                              |                                                              |                                         |                                     |                                                              |                                                              |                                                              |                                                              |                                                              |                                           |              <a href="#1462-课程表 IV">1462</a>              |                                                              |                                                              |

> 动态规划可以通过滚动数组思想减小空间复杂度，如题509，貌似42中也是（使用双指针解决时）

### 多种算法

> 同时使用到多种算法才能解决的问题，大部分这类题都属于困难题了

|            算法            | 字符串 |                       一维数组                        |                   二维数组                    | 单向链表 |  栈  |                   队列                    | 树（二叉树） |                            有向图                            |
| :------------------------: | :----: | :---------------------------------------------------: | :-------------------------------------------: | :------: | :--: | :---------------------------------------: | :----------: | :----------------------------------------------------------: |
|      贪心 + 二分查找       |        |         <a href="#300-最长递增子序列">300</a>         |                                               |          |      |                                           |              |                                                              |
|  贪心 + 前缀和 + 二分查找  |        |      <a href="#673-最长递增子序列的个数">673</a>      |                                               |          |      |                                           |              |                                                              |
|     前缀和 + 二分查找      |        | <a href="#1712-将数组分成三个子数组的方案数">1712</a> |                                               |          |      |                                           |              |                                                              |
|         BFS + 贪心         |        |                                                       |                                               |          |      | <a href="#1293-网格中的最短路径">1293</a> |              |                                                              |
|     DFS + 状态压缩 DP      |        |                                                       |      <a href="#980-不同路径 III">980</a>      |          |      |                                           |              |                                                              |
| 拓扑排序（BFS） + 动态规划 |        |                                                       |                                               |          |      |                                           |              | <a href="#1857-有向图中最大颜色值">1857</a>、<a href="#2050-并行课程 III">2050</a> |
|    动态规划 + 单调队列     |        |                                                       | <a href="#1687-从仓库到码头运输箱子">1687</a> |          |      |                                           |              |                                                              |

### 其它技巧

|    其它技巧    |                            字符串                            |                           一维数组                           |                  二维数组                   |                              栈                              |           有序集合（TreeSet）           |                        其它（数学题）                        |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------------------------------------: | :----------------------------------------------------------: | :-------------------------------------: | :----------------------------------------------------------: |
|    数学公式    |                                                              |                                                              |  <a href="#62-不同路径">62</a>（组合数学）  |                                                              |                                         | 【矩阵快速幂】(<a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>、<a href="#1220-统计元音字母序列的数目">1220</a>）、【通项公式】(<a href="#70-爬楼梯">70</a>、<a href="#509-斐波那契数">509</a>、<a href="#1137-第 N 个泰波那契数">1137</a>）、<a href="#69-Sqrt(x)">69</a>（牛顿迭代法） |
|      递推      |                                                              |                                                              |                                             |                                                              |                                         |     <a href="#1411-给 N x 3 网格图涂色的方案数">1411</a>     |
|    滑动窗口    | <a href="#3-无重复字符的最长子串">3</a>、<a href="#1763-最长的美好子字符串">1763</a> | <a href="#219-存在重复元素 II">219</a>、<a href="#1984-学生分数的最小差值">1984</a> |                                             |                                                              | <a href="#220-存在重复元素 III">220</a> |                                                              |
|     单调栈     |                                                              |                                                              |                                             | <a href="#42-接雨水">42</a>、<a href="#739-每日温度">739</a> |                                         |                                                              |
|    单调队列    |                                                              |            <a href="#239-滑动窗口最大值">239</a>             |                                             |                                                              |                                         |                                                              |
| 双指针/三指针  |                                                              | <a href="#11-盛最多水的容器">11</a>、<a href="#15-三数之和">15</a>（排序 + 双指针）、<a href="#42-接雨水">42</a>（感觉像是对动态规划的优化）、<a href="#825-适龄的朋友">825</a>、<a href="#1712-将数组分成三个子数组的方案数">1712</a>（三指针） |                                             |                                                              |                                         |                                                              |
|     并查集     |                                                              |                                                              | <a href="#1254-统计封闭岛屿的数目">1254</a> |                                                              |                                         |                                                              |
|     扫描线     |                                                              |                                                              |                                             |               <a href="#391-完美矩形">391</a>                |                                         |                                                              |
|  中心扩展算法  |               <a href="#5-最长回文子串">5</a>                |                                                              |                                             |                                                              |                                         |                                                              |
| 分块 + 预处理  |                                                              |            <a href="#239-滑动窗口最大值">239</a>             |                                             |                                                              |                                         |                                                              |
|       桶       |                                                              |           <a href="#220-存在重复元素 III">220</a>            |                                             |                                                              |                                         |                                                              |
|      计数      |                                                              |      <a href="#2006-差的绝对值为 K 的数对数目">2006</a>      |                                             |                                                              |                                         |                                                              |
| 前缀和与后缀和 |                                                              |         <a href="#2121-相同元素的间隔之和">2121</a>          |                                             |                                                              |                                         |                                                              |

> 解释，不包含在表中了
>
> 数学公式：
>
> 有些题根据题意可以使用数学上的某些公式或现有定理直接计算得出答案

## 题目合集（待定）

> 对做过的题目中遇到的相似问题或者难度上渐进的系列问题进行汇总

### 我的题解

[P1001](https://leetcode-cn.com/problems/grid-illumination/solution/60msjie-zhi-dao-20220116jin-hu-shuang-ba-c961/)

### 网格中的岛屿问题

P200、P695、P980

### 网格中的不同路径问题、最短路径问题

P62、P63、980

涉及到状态压缩

P864、P980

最长子序列

P334、P300、P673

### 图

#### 拓扑排序 （Topological sort）

P207、P210、P1857

拓扑排序并不是排序算法

#### 最小生成树算法

#### 最短路径算法

http://c.biancheng.net/algorithm/dijkstra.html

实际生产和生活中，经常需要查找最短路径，例如借助高德、腾讯地图等导航工具查找到目的地的最短可行路线，建立道路交通网、物流运输网络、计算机网络等，这时就可以使用最短路径算法。

|                         最短路径算法                         | 描 述                                                        |
| :----------------------------------------------------------: | :----------------------------------------------------------- |
| [迪杰斯特拉算法](http://c.biancheng.net/algorithm/dijkstra.html)（Dijkstra） | 寻找某个特定顶点到其它所有顶点的最短路径，该算法要求所有路径的权值为非负数。 |
| [弗洛伊德算法（](http://c.biancheng.net/algorithm/floyd-warshall.html)Floyd-Warshall） | 寻找各个顶点之间的最短路径，允许非环路的路径权值为负数，该算法不仅适用于稀疏图，在稠密图（路径数量多的图）中寻找最短路径的效率也很高。 |
|                贝尔曼福特算法（Bellman-Ford）                | 寻找某个特定顶点到其它所有顶点的最短路径，该算法允许路径的权值为负数。  推荐阅读：[图解贝尔曼福特算法](https://blog.csdn.net/a8082649/article/details/81812000)：详尽的讲解过程和丰富的实例演示，最终用 Java 语言实现该算法。 |
|                    约翰逊算法（Johnson）                     | 寻找各个顶点之间的最短路径，允许非环路的路径权值为负数，该算法更适用于稀疏图（路径数量少的图）。  推荐阅读：[Johnson 全源最短路径算法](https://blog.csdn.net/aijianxie8808/article/details/101647844)：详细讲解了 Johnson 算法的实现过程，最终实现的演示代码用 C# 实现。[Johnson 全源最短路径算法](https://www.cnblogs.com/mk-oi/p/13604088.html)：以作者自身的理解讲解了 Johnson 算法，最终实现的演示程序用 C++ 实现。 |

### 动态规划

待整理

P322、P518

<a href="#518-零钱兑换 II">518-零钱兑换 II</a>

状态压缩 DP

<a href="#1494-并行课程 II">1494-并行课程 II</a>

回文子串/子序列问题

P5、P516（可转换为求解P1143）

####  路径问题（目录）

[讲解](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485580&idx=1&sn=84c99a0a8ab7b543c3678db577309b97)

62.不同路径（中等）

63.不同路径 II（中等）

64.最小路径和（中等）

120.三角形最小路径和（中等）

931.下降路径最小和（中等）

1289.下降路径最小和 II（困难）

1575.统计所有可行路径（困难）

576.出界的路径数（中等）

1301.最大得分的路径数目（困难）

#### 背包问题（目录）

##### 01背包问题 [第一讲](https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg)

【练习】01背包 : 背包问题 第二讲（416. 分割等和子集）

【学习&练习】01背包 : 背包问题 第三讲（416. 分割等和子集）

##### 完全背包问题

【练习】完全背包 : 背包问题 第五讲（279. 完全平方数）

【练习】完全背包 : 背包问题 第六讲（322. 零钱兑换）

【练习】完全背包 : 背包问题 第七讲（518. 零钱兑换 II）

##### 多重背包问题 第八讲

多重背包（优化篇）

多重背包（优化篇）: 背包问题 第九讲

多重背包（优化篇）: 背包问题 第十讲

##### 混合背包问题 第十一讲

【练习】混合背包

##### 分组背包问题

【练习】分组背包

##### 多维背包问题

【练习】多维背包 : 背包问题 第 * 讲（474. 一和零）
【练习】多维背包 : 背包问题 第 * 讲（879. 盈利计划）

##### 树形背包问题

【练习】树形背包

##### 背包求方案数

【练习】背包求方案数 : 背包问题 第 * 讲（494. 目标和）
【练习】背包求方案数 : 背包问题 第 * 讲（879. 盈利计划）

##### 背包求具体方案

【练习】背包求具体方案 : 背包问题 第 * 讲（1049. 最后一块石头的重量 II）

##### 泛化背包

【练习】泛化背包

01背包问题的状态转移方程:
[![img](https://camo.githubusercontent.com/b5d46dbf2c02e9543c4a89844fb4a6372ef825e2d7b4f3047f702d6ff7580703/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762d63253542692535442535442b7725354269253544253239)](https://camo.githubusercontent.com/b5d46dbf2c02e9543c4a89844fb4a6372ef825e2d7b4f3047f702d6ff7580703/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762d63253542692535442535442b7725354269253544253239)
[![img](https://camo.githubusercontent.com/ae4cf23fb8d6b7160671af13f36383d48e34a43895ebd4b781d26542bd2cdabf/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f6470253542762535442532302533442532304d6174682e6d61782532386470253542762535442532436470253542762d63253542692535442535442b7725354269253544253239)](https://camo.githubusercontent.com/ae4cf23fb8d6b7160671af13f36383d48e34a43895ebd4b781d26542bd2cdabf/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f6470253542762535442532302533442532304d6174682e6d61782532386470253542762535442532436470253542762d63253542692535442535442b7725354269253544253239)

完全背包问题的状态转移方程:
[![img](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)
[![img](https://camo.githubusercontent.com/1668dfe466aeb13c4a0616889aad0163e097f1709620be16815ff6a351899a0b/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d3125354425354276253544253243647025354269253544253542762d63253542692535442535442b7725354269253544253239)](https://camo.githubusercontent.com/1668dfe466aeb13c4a0616889aad0163e097f1709620be16815ff6a351899a0b/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d3125354425354276253544253243647025354269253544253542762d63253542692535442535442b7725354269253544253239)

多重背包问题的状态转移方程:(和完全背包一致)
[![img](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)](https://camo.githubusercontent.com/8d1ae20ab1ba977ecf05f04ca97e9f3f08fe2118ff492a95e5030a3ca04ae65e/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f647025354269253544253542762535442532302533442532304d6174682e6d61782532386470253542692d31253544253542762535442532436470253542692d31253544253542762532302d2532306b25323025354374696d657325323063253542692535442535442532302b2532306b25323025354374696d65732532307725354269253544253239253342)

#### 股票问题

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- 动态规划用于求解 **多阶段决策问题** ；
- 动态规划问题的问法：**只问最优解，不问具体的解**；
- 掌握 **无后效性** 解决动态规划问题：把约束条件设置成为状态。

##### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```
此题到底是不是贪心算法啊？搞不懂为什么大家都说这是个贪心算法，我认为这道题就不是个贪心算法啊。我认为的贪心算法是，当我们不能确定这种方式能得到最优解，但是能得到一个可能是最优解的解的时候才使用贪心的思想。而这道题的这个贪心算法得出来的解，就是最优解，这不是可能得到，而是一定的，因此我认为官方解就不能说是贪心算法。也许是我一步步从动态规划推导出来的，最后得到的结果和官方贪心算法的实现几乎一致，只是思考过程不同，让我觉得非要给解答方式命名，这有些为了刻意做题而刻意套用了这些算法及其思想来解释，虽然说得通，但是这总有些为了做题为了多解而出现的，这并不是正常思考解题步骤的方式。

而对于官方的动态规划题解，我也有不同的看法，我看很多题解也都是说的在某天买股票或者卖股票的利润，这也说的通，不过还是复杂了些。 我想的动态规划是， 截至到每天，每天的最大利润 ，这就直接包含了官方的两种情况。然后就是要去想如何实现得到每天的最大利润。

当看到这个题目后，我能想到的就是找到一个最低价格点，然后在紧接着的连续的后面某天最高价格处卖出就能得到最大利润值。于是想到了记录最小价格的天数索引，然后每遇到一个高于昨天的价格就卖，此时就是截至到今天能获取的最大利润，而如果今天价格低于了昨天的价格，说明截至到今天最大获利就是在昨天卖出股票后的获利，于是第一种方式就因此而来。而第二种方式是，让代码实现上看起来更像动态规划。而最后滚动数组的实现方式则变成了官方的贪心算法。

其实想想，官方分成多个区间求子区间可能最大利润，相加后等于最终答案，整个区间的最大利润，也行。

哎，我不纠结了，多种思考方式也好。以下是我得到与官方贪心算法的代码实现几乎一样的过程——将动态规划dp[]数组压缩成dp整型变量的过程。

其实我有想过，假如我们都不懂动态规划和贪心算法，就是假设我们没学过这两算法，我们能出这道题目的思路应该都是遍历数组，找到一个最小值，又找到后面几天中的最大值（遇到比前一天小的，说明就找到了），然后求其差保存，然后最大值的后面一天就认为是最小值，再去依次找比它大的值求差，最终得到答案。这种没有运用算法的原始的思路也应该不要忘，这个方式做出来的复杂度也是最优的。我的意思是不要为了用算法而用算法，不要为了给自己的解题方式取名而去寻求与现有哪个算法相似。最理想的状态是，做题没想什么算法，但是最火实现却和运用了算法思想解题的一致。我咋感觉是在说武功秘笈，化有招为无招，扯远了扯远了。
```

##### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

##### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

[待学习的题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-chong-ji-yu-wqs-er-fen-de-you-xiu-zuo-x36r/)

第十四讲 最佳买卖股票时机含冷冻期
第十五讲 买卖股票的最佳时机含手续费

## Problems

### 题目记录

| 题目编号                                                     |   数据结构    |                 算法                 | 难度 | 初次完成时间 | 最近完成时间 | 完成次数 | 第一次是否独立完成 | 最近一次完成是否是独立完成 | 是否有不同于官方答案的解题思路 | 是否需要重点复习(ABCD四个等级) |                       页内跳转                        |
| :----------------------------------------------------------- | :-----------: | :----------------------------------: | :--: | :----------: | :----------: | :------: | :----------------: | :------------------------: | :----------------------------: | :----------------------------: | :---------------------------------------------------: |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) |    字符串     |               滑动窗口               | 中等 |  2021.10.19  |  2021.10.19  |    1     | 是                 |             是             |               是               |               C                |        <a href="#3-无重复字符的最长子串">3</a>        |
| [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/) | 字符串 | 动态规划、中心扩展算法、Manacher 算法 | 中等 | 2021.12.04 | 2021.12.04 | 1 | 否 | 否 | 否 | B | <a href="#5-最长回文子串">5</a> |
| [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/) | 数组 | 基本操作 | 中等 | 2022.01.06 | 2022.01.06 | 1 | 是 | 是 | 否 | C | <a href="#6-Z 字形变换">6</a> |
| [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/) |     数组      |                双指针                | 中等 |  2021.11.05  |  2021.11.05  |    1     | 是                 |             是             |               否               |               C                |          <a href="#11-盛最多水的容器">11</a>          |
| [15. 三数之和](https://leetcode-cn.com/problems/3sum/)       |      数组      | 排序+双指针 | 中等 |  2021.10.21  |  2021.10.21  |    1     | 否                 |             否             |               否               |               C               |   <a href="#15-三数之和">15</a>   |
| [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) |     单链表     |                 分治                 | 困难 |  2021.10.18  |  2021.10.18  |    1     | 是                 |             是             |               否               |               A                |         <a href="#23-合并K个升序链表">23</a>          |
| [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) | 数组 | 二分查找 | 中等 | 2021.12.30 | 2021.12.30 | 1 | 是 | 是 | 是 | B | <a href="#33-搜索旋转排序数组">33</a> |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) |     数组      |               二分查找               | 简单 |  2021.10.20  |  2021.10.20  |    1     | 是                 |             是             |               是               |               C                |           <a href="#35-搜索插入位置">35</a>           |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) |     数组      |       动态规划、单调栈、双指针       | 困难 |  2021.11.04  |  2021.11.04  |    1     | 是                 |             是             |               是               |               A                |              <a href="#42-接雨水">42</a>              |
| [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/) | 数组 | 贪心 | 中等 | 2021.11.24 | 2021.11.24 | 1 | 否 | 否 | 否 | B | <a href="#45-跳跃游戏 II">45</a> |
| [46. 全排列](https://leetcode-cn.com/problems/permutations/) | 数组 | 回溯 | 中等 | 2021.11.13 | 2021.11.13 | 1 | 否 | 否 | 否 | B | <a href="#46-全排列">46</a> |
| [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) | 数组 | 回溯 | 中等 | 2021.11.27 | 2021.11.27 | 1 | 是 | 是 | 否 | B | <a href="#47-全排列 II">47</a> |
| [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/) | 数组 | 贪心 | 中等 | 2021.11.23 | 2021.11.23 | 1 | 是 | 是 | 否 | C | <a href="#55-跳跃游戏">55</a> |
| [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/) |     数组      |          动态规划/组合数学           | 中等 |  2021.10.30  |  2021.10.30  |    1     | 是                 |             是             |               是               |               B                |             <a href="#62-不同路径">62</a>             |
| [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) |     数组      |               动态规划               | 中等 |  2021.10.30  |  2021.10.30  |    1     | 是                 |             是             |               是               |               B                |           <a href="#63-不同路径 II">63</a>            |
| [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) | 数组 | 动态规划 | 中等 | 2022.02.08 | 2022.02.08 | 1 | 是 | 是 | 否 | C | <a href="#64-最小路径和">64</a> |
| [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/) | 数学题 | 二分查找 | 简单 | 2021.12.28 | 2021.12.28 | 1 | 是 | 是 | 否 | D | <a href="#69-Sqrt(x)">69</a> |
| [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) |    数学题     | 递归、动态规划、矩阵快速幂、通项公式 | 简单 |  2021.11.05  |  2021.11.05  |    1     | 是                 |             是             |               否               |               D                |              <a href="#70-爬楼梯">70</a>              |
| [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) | 字符串 | 动态规划 | 困难 | 2021.11.29 | 2021.11.29 | 1 | 否 | 否 | 否 | B | <a href="#72-编辑距离">72</a> |
| [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/) | 字符串 | 回溯 | 中等 | 2021.11.12 | 2021.11.12 | 1 | 否 | 否 | 否 | B | <a href="#93-复原 IP 地址">93</a> |
| [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) | 二叉树 | 递归、迭代 | 简单 | 2022.01.11 | 2022.01.11 | 1 | 是 | 是 | 是 | B | <a href="#101-对称二叉树">101</a> |
| [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) | 二叉树 | BFS（层序遍历） | 中等 | 2022.01.08 | 2022.01.08 | 1 | 是 | 是 | 是 | B | <a href="#103-二叉树的锯齿形层序遍历">103</a> |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |    二叉树     |               DFS、BFS               | 简单 |  2021.10.29  |  2021.10.29  |    1     | 是                 |             是             |               否               |               C                |        <a href="#104-二叉树的最大深度">104</a>        |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |    二叉树     |                 递归                 | 中等 |  2021.09.19  |  2021.09.19  |    1     | 否                 |             否             |               否               |               A                | <a href="#105-从前序与中序遍历序列构造二叉树">105</a> |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) |    二叉树     |                 递归                 | 中等 |  2021.09.22  |  2021.09.22  |    1     | 否                 |             否             |               否               |               A                | <a href="#106-从中序与后序遍历序列构造二叉树">106</a> |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  |    二叉树     |              递归、DFS               | 简单 |  2021.04.26  |  2021.10.22  |    2     | 否                 |             是             |               否               |              A->C              |            <a href="#112-路径总和">112</a>            |
| [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) |    二叉树     |               DFS、BFS               | 中等 |  2021.10.23  |  2021.10.23  |    1     | 否                 |             否             |               否               |               B                |          <a href="#113-路径总和 II">113</a>           |
| [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) | 数组 | 动态规划 | 简单 | 2021.12.07 | 2021.12.07 | 1 | 是 | 是 | 否 | C | <a href="#121-买卖股票的最佳时机">121</a> |
| [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) | 数组 | 动态规划 | 中等 | 2021.12.08 | 2021.12.08 | 1 | 是 | 是 | 是 | C | <a href="#122-买卖股票的最佳时机 II">122</a> |
| [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/) | 数组 | 动态规划 | 困难 | 2021.12.10 | 2021.12.10 | 1 | 是 | 是 | 是 | B | <a href="#123-买卖股票的最佳时机 III">123</a> |
| [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) | 二叉树 | 递归（后序遍历） | 困难 | 2021.12.03 | 2021.12.03 | 1 | 是 | 是 | 是 | B | <a href="#124-二叉树中的最大路径和">124</a> |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 二叉树 | 递归、迭代 | 简单 | 2021.11.30 | 2021.12.01 | 2 | 是 | 否 | 否 | B | <a href="#145-二叉树的后序遍历">145</a> |
| [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/) | 双链表 | 哈希表 | 中等 |  2021.10.15  |  2021.10.16  |    2     | 否                 |             否             |               是               |               A                |          <a href="#146-LRU 缓存机制">146</a>          |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) |     链表      |               插入排序               | 中等 |  2021.10.26  |  2021.10.26  |    1     | 是                 |             是             |               是               |               B                |       <a href="#147-对链表进行插入排序">147</a>       |
| [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/) | 数组 | 动态规划 | 困难 | 2021.12.12 | 2021.12.12 | 1 | 是 | 是 | 否 | B | <a href="#188-买卖股票的最佳时机 IV">188</a> |
| [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) | 数组 | 动态规划 | 中等 | 2021.11.21 | 2021.11.21 | 1 | 否 | 否 | 否 | C | <a href="#198-打家劫舍">198</a> |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/) |     数组      |               DFS、BFS               | 中等 |  2021.11.01  |  2021.11.01  |    1     | 是                 |             是             |               否               |               A                |            <a href="#200-岛屿数量">200</a>            |
| [207. 课程表](https://leetcode-cn.com/problems/course-schedule/) | 图 | DFS、BFS | 中等 | 2021.12.06 | 2021.12.11 | 2 | 是 | 是 | 否 | B | <a href="#207-课程表">207</a> |
| [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) | Trie（前缀树、字典树） | 基本操作 | 中等 | 2022.01.04 | 2022.01.04 | 1 | 否 | 否 | 否 | B | <a href="#208-实现 Trie (前缀树)">208</a> |
| [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/) | 图 | DFS、BFS | 中等 | 2021.12.09 | 2021.12.11 | 2 | 是 | 是 | 否 | B | <a href="#210-课程表 II">210</a> |
| [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/) | 数组 | 动态规划 | 中等 | 2021.11.21 | 2021.11.21 | 1 | 否 | 否 | 否 | C | <a href="#213-打家劫舍 II">213</a> |
| [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) | 数组、堆 | 推排序、快速排序 | 中等 | 2022.02.12 | 2022.02.12 | 1 | 是 | 是 | 否 | B | <a href="#215-数组中的第K个最大元素">215</a> |
| [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/) | 数组 | 哈希表 | 简单 | 2022.01.19 | 2022.01.19 | 1 | 是 | 是 | 否 | D | <a href="#217-存在重复元素">217</a> |
| [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/) | 数组 | 哈希表、滑动窗口 | 简单 | 2022.01.19 | 2022.01.19 | 1 | 是 | 是 | 否 | C | <a href="#219-存在重复元素 II">219</a> |
| [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/) | 数组 | 滑动窗口 + 有序集合、桶 | 中等 | 2022.01.20 | 2022.01.20 | 1 | 否 | 否 | 否 | B | <a href="#220-存在重复元素 III">220</a> |
| [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) | 二叉树 | 递归（前序遍历、后序遍历） | 简单 | 2021.12.31 | 2021.12.31 | 1 | 是 | 是 | 否 | D | <a href="#226-翻转二叉树">226</a> |
| [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) | 二叉树 | 递归（前序遍历） | 中等 | 2021.12.28 | 2021.12.28 | 1 | 是 | 是 | 是 | C | <a href="#236-二叉树的最近公共祖先">236</a> |
| [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) |     单链表     |             链表基础操作             | 简单 |  2021.11.02  |  2021.11.02  |    1     | 是                 |             是             |               否               |               D                |        <a href="#237-删除链表中的节点">237</a>        |
| [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/) | 数组、队列、堆 | 优先队列、单调队列、分块 + 预处理 | 困难 | 2022.01.14 | 2022.01.14 | 1 | 否 | 否 | 否 | A | <a href="#239-滑动窗口最大值">239</a> |
| [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) | 数组 | 动态规划、贪心 + 二分查找 | 中等 | 2021.11.15 | 2021.11.15 | 1 | 否 | 否 | 否 | B | <a href="#300-最长递增子序列">300</a> |
| [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) | 数组 | 记忆化搜索、动态规划 | 中等 | 2021.11.25 | 2021.11.25 | 1 | 否 | 否 | 否 | B | <a href="#322-零钱兑换">322</a> |
| [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/) | 数组 | 贪心 | 中等 | 2022.01.13 | 2022.01.13 | 1 | 是 | 是 | 否 | B | <a href="#334-递增的三元子序列">334</a> |
| [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/) | 二叉树 | 动态规划 | 中等 | 2021.11.22 | 2021.11.22 | 1 | 否 | 否 | 否 | B | <a href="#337-打家劫舍 III">337</a> |
| [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/) |     数组      |                双指针                | 简单 |  2021.05.09  |  2021.10.31  |    2     | 是                 |             是             |               是               |               D                |           <a href="#344-反转字符串">344</a>           |
| [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/) | 堆 | 优先队列 | 中等 | 2022.02.09 | 2022.02.09 | 1 | 是 | 是 | 否 | B | <a href="#347-前 K 个高频元素">347</a> |
| [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/) | 数组 | 哈希表 | 困难 | 2021.11.19 | 2021.11.19 | 1 | 否 | 否 | 否 | B | <a href="#391-完美矩形">391</a> |
| [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/) | 数组 | 基本操作、哈希表 | 简单 | 2021.12.26 | 2021.12.26 | 1 | 是 | 是 | 否 | D | <a href="#409-最长回文串">409</a> |
| [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/) | 数组 | 迭代、DFS | 简单 | 2021.11.08 | 2021.11.08 | 1 | 是 | 是 | 否 | B | <a href="#463-岛屿的周长">463</a> |
| [472. 连接词](https://leetcode-cn.com/problems/concatenated-words/) | Trie（前缀树、字典树） | DFS + 记忆化搜索 | 困难 | 2022.01.06 | 2022.01.06 | 1 | 否 | 否 | 否 | A | <a href="#472-连接词">472</a> |
| [494. 目标和](https://leetcode-cn.com/problems/target-sum/) | 数组 | 回溯、动态规划 | 中等 | 2021.11.14 | 2021.11.14 | 1 | 否 | 否 | 否 | B | <a href="#494-目标和">494</a> |
| [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/) |    数学题     | 递归、动态规划、矩阵快速幂、通项公式 | 简单 |  2021.11.02  |  2020.11.02  |    1     | 是                 |             是             |               否               |               D                |           <a href="#509-斐波那契数">509</a>           |
| [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) | 字符串 | 动态规划 | 中等 | 2022.01.02 | 2022.01.02 | 1 | 是 | 是 | 否 | B | <a href="#516-最长回文子序列">516</a> |
| [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/) | 数组 | 动态规划 | 中等 | 2021.11.26 | 2021.11.26 | 1 | 否 | 否 | 是 | A | <a href="#518-零钱兑换 II">518</a> |
| [539. 最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/) | 数组 | 基本操作（排序、鸽笼原理） | 中等 | 2022.01.18 | 2022.01.18 | 1 | 是 | 是 | 否 | B | <a href="#539-最小时间差">539</a> |
| [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/) | 数组 | 二分查找 | 中等 | 2022.02.14 | 2022.02.14 | 1 | 是 | 是 | 是 | C | <a href="#540-有序数组中的单一元素">540</a> |
| [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/) | 二叉树 | DFS | 简单 | 2021.11.20 | 2021.11.20 | 1 | 是 | 是 | 否 | D | <a href="#563-二叉树的坡度">563</a> |
| [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/) | 数组 | 基本操作、哈希表 | 简单 | 2021.12.25 | 2021.12.25 | 1 | 否 | 否 | 否 | C | <a href="#594-最长和谐子序列">594</a> |
| [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/) | 堆 | 贪心 | 困难 | 2021.12.14 | 2021.12.14 | 1 | 否 | 否 | 否 | A | <a href="#630-课程表 III">630</a> |
| [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) | 数组 | 动态规划、贪心 + 前缀和 + 二分查找 | 中等 | 2021.11.16 | 2021.11.17 | 2 | 否 | 否 | 否 | A | <a href="#673-最长递增子序列的个数">673</a> |
| [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/) | 数组 | DFS、BFS | 中等 | 2021.11.07 | 2021.11.07 | 1 | 是 | 是 | 否 | A | <a href="#695-岛屿的最大面积">695</a> |
| [729. 我的日程安排表 I](https://leetcode-cn.com/problems/my-calendar-i/) | 平衡二叉树 | 基本操作 | 中等 | 2022.01.09 | 2022.01.09 | 1 | 否 | 否 | 否 | B | <a href="#729-我的日程安排表 I">729</a> |
| [731. 我的日程安排表 II](https://leetcode-cn.com/problems/my-calendar-ii/) | 平衡二叉树 | 基本操作 | 中等 | 2022.01.10 | 2022.01.10 | 1 | 否 | 否 | 否 | B | <a href="#731-我的日程安排表 II">731</a> |
| [732. 我的日程安排表 III](https://leetcode-cn.com/problems/my-calendar-iii/) | 平衡二叉树 | 基本操作 | 困难 | 2022.01.12 | 2022.01.12 | 1 | 否 | 否 | 否 | B | <a href="#732-我的日程安排表 III">732</a> |
| [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/) | 栈 | 基本操作 | 中等 | 2021.12.24 | 2012.12.24 | 1 | 是 | 是 | 否 | B | <a href="#735-行星碰撞">735</a> |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) |     栈      |    单调栈    | 中等 |  2021.10.24  |  2022.02.08  |    2     | 是                 |             是             |               是               |               B               |            <a href="#739-每日温度">739</a>            |
| [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/) | 数组 | 动态规划 | 中等 | 2021.11.23 | 2021.11.23 | 1 | 否 | 否 | 否 | B | <a href="#740-删除并获得点数">740</a> |
| [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/) |     数组      |               动态规划               | 简单 |  2021.11.06  |  2021.11.06  |    1     | 是                 |             是             |               是               |               C                |       <a href="#746-使用最小花费爬楼梯">746</a>       |
| [747. 至少是其他数字两倍的最大数](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/) | 数组 | 基本操作 | 简单 | 2022.01.13 | 2022.01.13 | 1 | 是 | 是 | 否 | D | <a href="#747-至少是其他数字两倍的最大数">747</a> |
| [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/) | 数组 | 排序 + 双指针、计数排序 + 前缀和 | 中等 | 2021.12.27 | 2021.12.27 | 1 | 是 | 是 | 是 | B | <a href="#825-适龄的朋友">825</a> |
| [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/) | 数组 | DFS | 困难 | 2021.11.08 | 2021.11.08 | 1 | 是 | 是 | 是 | A | <a href="#827-最大人工岛">827</a> |
| [864. 获取所有钥匙的最短路径](https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/) | 数组 | BFS + 状态压缩 | 困难 | 2021.12.29 | 2021.12.29 | 1 | 否 | 否 | 否 | A+ | <a href="#864-获取所有钥匙的最短路径">864</a> |
| [884. 两句话中的不常见单词](https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/) | 字符串 | 哈希表 | 简单 | 2022.01.30 | 2022.01.30 | 1 | 是 | 是 | 否 | C | <a href="#884-两句话中的不常见单词">884</a> |
| [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/) |     数组      |          回溯、DFS + 状态压缩 DP          | 困难 |  2021.11.01  |  2021.12.21  |    2    | 否                 |             否             |               否               |               A                |          <a href="#980-不同路径 III">980</a>          |
| [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/) | 数组 | BFS | 中等 | 2022.01.07 | 2022.01.07 | 1 | 是 | 是 | 是 | B | <a href="#994-腐烂的橘子">994</a> |
| [1001. 网格照明](https://leetcode-cn.com/problems/grid-illumination/) | 数组 | 哈希表 | 困难 | 2022.01.16 | 2022.01.16 | 1 | 是 | 是 | 是 | B | <a href="#1001-网格照明">1001</a> |
| [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/) | 数组 | DFS、BFS、并查集 | 中等 | 2021.11.28 | 2021.11.28 | 1 | 是 | 是 | 是 | B | <a href="#1020-飞地的数量">1020</a> |
| [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/) |    数学题     |      递归、动态规划、矩阵快速幂      | 简单 |  2021.11.03  |  2021.11.03  |    1     | 是                 |             是             |               否               |               D                |      <a href="#1137-第 N 个泰波那契数">1137</a>       |
| [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) | 字符串 | 动态规划 | 中等 | 2021.11.30 | 2022.01.03 | 2 | 是 | 是 | 否 | B | <a href="#1143-最长公共子序列">1143</a> |
| [1189. “气球” 的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balloons/) | 字符串 | 基本操作 | 简单 | 2022.02.13 | 2022.02.13 | 1 | 是 | 是 | 否 | D | <a href="#1189-“气球”的最大数量">1189</a> |
| [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/) | 数组 | 回溯 | 中等 | 2022.02.05 | 2022.02.05 | 1 | 是 | 是 | 否 | B | <a href="#1219-黄金矿工">1219</a> |
| [1220. 统计元音字母序列的数目](https://leetcode-cn.com/problems/count-vowels-permutation/) | 数学题 | 动态规划、矩阵快速幂 | 困难 | 2022.01.17 | 2022.01.17 | 1 | 是 | 是 | 否 | C | <a href="#1220-统计元音字母序列的数目">1220</a> |
| [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/) | 数组 | DFS、BFS、并查集 | 中等 | 2021.11.13 | 2021.11.13 | 1 | 是 | 是 | 否 | B | <a href="#1254-统计封闭岛屿的数目">1254</a> |
| [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/) | 队列 | BFS + 贪心 | 困难 | 2021.11.10 | 2021.11.11 | 2 | 否 | 否 | 是 | A+ | <a href="#1293-网格中的最短路径">1293</a> |
| [1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/) | 字符串 | 基本操作 | 简单 | 2022.01.22 | 2022.01.22 | 1 | 否 | 否 | 否 | D | <a href="#1332-删除回文子序列">1332</a> |
| [1342. 将数字变成 0 的操作次数](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/) | 数学题 | 基本操作 | 简单 | 2022.01.31 | 2022.01.31 | 1 | 是 | 是 | 否 | D | <a href="#1342-将数字变成 0 的操作次数">1342</a> |
| [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/) | 数组 | BFS、Dijkstra 算法、0-1 BFS | 困难 | 2021.12.18 | 2021.12.19 | 2 | 否 | 否 | 否 | A | <a href="#1368-使网格图至少有一条有效路径的最小代价">1368</a> |
| [1405. 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/) | 字符串 | 贪心 | 中等 | 2022.02.07 | 2022.02.07 | 1 | 是 | 是 | 是 | B | <a href="#1405-最长快乐字符串">1405</a> |
| [1411. 给 N x 3 网格图涂色的方案数](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/) | 数学题 | 递推、动态规划 | 困难 | 2021.12.20 | 2021.12.20 | 1 | 是 | 是 | 否 | B | <a href="#1411-给 N x 3 网格图涂色的方案数">1411</a> |
| [1414. 和为 K 的最少斐波那契数字数目](https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/) | 数学题 | 贪心 | 中等 | 2022.02.03 | 2022.02.03 | 1 | 是 | 是 | 是 | B | <a href="#1414-和为 K 的最少斐波那契数字数目">1414</a> |
| [1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/) | 数组 | 动态规划 | 困难 | 2021.11.09 | 2021.11.09 | 1 | 否 | 否 | 否 | A+ | <a href="#1444-切披萨的方案数">1444</a> |
| [1447. 最简分数](https://leetcode-cn.com/problems/simplified-fractions/) | 数学题 | 数学最大公约数 | 中等 | 2022.02.10 | 2022.02.10 | 1 | 否 | 否 | 否 | C | <a href="#1447-最简分数">1447</a> |
| [1462. 课程表 IV](https://leetcode-cn.com/problems/course-schedule-iv/) | 图 | DFS、BFS、Floyd | 中等 | 2021.12.14 | 2021.12.14 | 1 | 是 | 是 | 是 | B | <a href="#1462-课程表 IV">1462</a> |
| [1494. 并行课程 II](https://leetcode-cn.com/problems/parallel-courses-ii/) | 图 | 状态压缩 DP | 困难 | 2021.12.16 | 2021.12.16 | 1 | 否 | 否 | 否 | A++ | <a href="#1494-并行课程 II">1494</a> |
| [1687. 从仓库到码头运输箱子](https://leetcode-cn.com/problems/delivering-boxes-from-storage-to-ports/) | 数组 | 动态规划 + 单调队列 | 困难 | 2021.12.23 | 2021.12.23 | 1 | 否 | 否 | 否 | A | <a href="#1687-从仓库到码头运输箱子">1687</a> |
| [1701. 平均等待时间](https://leetcode-cn.com/problems/average-waiting-time/) | 数组 | 简单逻辑 基本操作 | 中等 | 2022.02.06 | 2022.02.06 | 1 | 是 | 是 | 是 | C | <a href="#1701-平均等待时间">1701</a> |
| [1712. 将数组分成三个子数组的方案数](https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/) | 数组 | 前缀和 + 二分查找、三指针 | 中等 | 2022.02.13 | 2022.02.14 | 2 | 是 | 是 | 是 | B | <a href="#1712-将数组分成三个子数组的方案数">1712</a> |
| [1725. 可以形成最大正方形的矩形数目](https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/) | 数组 | 基本操作 | 简单 | 2022.02.04 | 2022.02.04 | 1 | 是 | 是 | 否 | D | <a href="#1725-可以形成最大正方形的矩形数目">1725</a> |
| [1748. 唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/) | 数组 | 基本操作 | 简单 | 2022.02.06 | 2022.02.06 | 1 | 是 | 是 | 否 | D | <a href="#1748-唯一元素的和">1748</a> |
| [1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/) | 字符串 | 分治、滑动窗口 | 简单 | 2022.02.01 | 2022.02.01 | 1 | 否 | 否 | 否 | B | <a href="#1763-最长的美好子字符串">1763</a> |
| [1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/) | 队列 | BFS | 中等 | 2022.01.29 | 2022.01.29 | 1 | 是 | 是 | 否 | B | <a href="#1765-地图中的最高点">1765</a> |
| [1857. 有向图中最大颜色值](https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/) |      图       |             拓扑排序（BFS） + 动态规划             | 困难 |  2021.10.15  |  2021.12.05  |    2     | 否                 |             否             |               否               |               A+               |      <a href="#1857-有向图中最大颜色值">1857</a>      |
| [1905. 统计子岛屿](https://leetcode-cn.com/problems/count-sub-islands/) | 数组 | DFS、BFS | 中等 | 2021.12.02 | 2021.12.02 | 1 | 是 | 是 | 否 | B | <a href="#1905-统计子岛屿">1905</a> |
| [1984. 学生分数的最小差值](https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/) | 数组 | 排序 + 滑动窗口 | 简单 | 2022.02.11 | 2022.02.11 | 1 | 是 | 是 | 否 | D | <a href="#1984-学生分数的最小差值">1984</a> |
| [2000. 反转单词前缀](https://leetcode-cn.com/problems/reverse-prefix-of-word/) | 字符串 | 基本操作 | 简单 | 2022.02.02 | 2022.02.02 | 1 | 是 | 是 | 是 | D | <a href="#2000-反转单词前缀">2000</a> |
| [2006. 差的绝对值为 K 的数对数目](https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/) | 数组 | 计数、哈希表 | 简单 | 2022.02.10 | 2022.02.10 | 1 | 是 | 是 | 是 | C | <a href="#2006-差的绝对值为 K 的数对数目">2006</a> |
| [2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/) | 数组 | 基本操作 | 简单 | 2022.01.01 | 2022.01.01 | 1 | 是 | 是 | 是 | D | <a href="#2022-将一维数组转变成二维数组">2022</a> |
| [2034. 股票价格波动](https://leetcode-cn.com/problems/stock-price-fluctuation/) | 哈希表 | 哈希表 + 有序集合、哈希表 + 优先队列 | 中等 | 2022.01.23 | 2022.01.23 | 1 | 否 | 否 | 否 | B | <a href="#2034-股票价格波动">2034</a> |
| [2045. 到达目的地的第二短时间](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/) | 无向图 | BFS | 困难 | 2022.01.24 | 2022.01.24 | 1 | 是 | 是 | 是 | A | <a href="#2045-到达目的地的第二短时间">2045</a> |
| [2050. 并行课程 III](https://leetcode-cn.com/problems/parallel-courses-iii/) | 图 | 拓扑排序（BFS） + 动态规划 | 困难 | 2021.12.17 | 2021.12.17 | 1 | 否 | 否 | 否 | A | <a href="#2050-并行课程 III">2050</a> |
| [2121. 相同元素的间隔之和](https://leetcode-cn.com/problems/intervals-between-identical-elements/) | 数组 | 哈希表 + 前缀后缀和 | 中等 | 2022.01.26 | 2022.01.26 | 1 | 否 | 否 | 否 | B | <a href="#2121-相同元素的间隔之和">2121</a> |

> 页内跳转：#后 字符省略，空格变为 -
>
> <a href="#"></a>

> #### 数组——暂定可删
>

> | 题目编号                                                     | 数据结构——数组 |    算法     | 难度 | 初次完成时间 | 最近完成时间 | 完成次数 | 第一次是否独立完成 | 最近一次完成是否是独立完成 | 是否有不同于官方答案的解题思路 | 是否需要重点复习(ABCD四个等级) |                             备注                             |             页内跳转              |
> | :----------------------------------------------------------- | :------------: | :---------: | :--: | :----------: | :----------: | :------: | ------------------ | :------------------------: | :----------------------------: | :---------------------------: | :----------------------------------------------------------: | :-------------------------------: |
> 

### 题目汇总

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

##### 滑动窗口

```java
class P3_Solution {
    /**
     * @param s 要查找的字符串
     * @return maxLen 字符串 s 中不含有重复字符的 最长子串 的长度
     */
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        } else if (s.length() == 1) {
            return 1;
        }
        StringBuilder longestSubstring = new StringBuilder();
        // 初始化 将字符串 s 中的第一个字符加入子串中
        longestSubstring.append(s.charAt(0));
        // 初始化 最大长度 为 1 或者 0 均可
        int maxLen = 1;
        // 字符串中待比较的字符下标
        int indexStr = 1;
        // 字符串中待比较的字符在子串中的下标 如果有,返回下标;如果没有,返回 -1
        int indexSub = 0;
        while (indexStr < s.length()) {
            // indexSub = longestSubstring.indexOf(s.charAt(indexStr) + ""); // 效率不及下者
            // indexSub = longestSubstring.indexOf(String.valueOf(s.charAt(indexStr))); // 效率不及下者
            indexSub = longestSubstring.toString().indexOf(s.charAt(indexStr));
            // 如果子串中没有找到该字符,将该字符加入到子串中,并且 indexStr++,比较下一个字符
            if (indexSub == -1) {
                longestSubstring.append(s.charAt(indexStr));
                indexStr++;
            } else {
                // 如果子串中找到了该字符,说明此时子串为当前的最大子串,maxLen 为前一个 maxLen 和 当前子串长度 两者中的较大值
                maxLen = Math.max(maxLen, longestSubstring.length());
                // 在子串中删除找到的字符以前的所有字符(包括这个字符)
                // 例如 s = abcdbe 中,当比较到第二个 b 时,子串为 abcd, 重复的字符为 b, 删除 ab, 即(包含) indexSub 之前的所有字符
                // 删除后为 cd
                longestSubstring.delete(0, indexSub + 1);
                // 再在末尾加上这个重复的字符 即此时子串为 cdb
                longestSubstring.append(s.charAt(indexStr));
                // 继续比较下一个
                indexStr++;
            }
        }
        return Math.max(maxLen, longestSubstring.length());
    }
}
```

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

##### 动态规划

```java
// 动态规划
// 此方法效率低, 在官方答案上更改而来
class P5_Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len == 0 || len == 1) {
            return s;
        }

        // 最长回文子串长度
        int maxLen = 1;
        // (第一条)最长回文子串的开始下标
        int begin = 0;

        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化
        for (int i = 0; i <= len - 2; i++) {
            // 所有长度为 1 的子串都是回文串
            dp[i][i] = true;
            // 所有长度为 2 的子串中两字符相同的子串为回文串
            // 不相同则不是回文子串, 为 false, (可省略) /* else { dp[i][j] = false; } */
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                maxLen = 2;
                begin = i;
            }
        }
        // 所有长度为 1 的子串都是回文串
        dp[len - 1][len - 1] = true;

        // 先枚举子串长度
        for (int subLen = 3; subLen <= len; subLen++) {
            // 枚举左边界，左边界的上限设置可以宽松一些, 但是这里设置得最小(临界值), 这样的话 右边界 j 就肯定不会越界
            for (int i = 0; i <= len - subLen; i++) {
                // 由 subLen 和 i 可以确定右边界，即 j - i + 1 = subLen 得
                int j = subLen + i - 1;

                // 如果这两字符相同, 则看内部子串是否为回文子串, 内部是则是, 内部不是则不是
                // 如果不相同, 则肯定不是回文子串, 为 false, (可省略) /* else { dp[i][j] = false; } */
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度 subLen 和起始位置 i
                if (dp[i][j] && subLen > maxLen) {
                    maxLen = subLen;
                    begin = i;
                }
            }
        }
        // 测试输出
//        for (int i = 0; i < len; i++) {
//            System.out.println(Arrays.toString(dp[i]));
//        }
        return s.substring(begin, begin + maxLen);
    }
}
```

##### 中心扩展算法

> 这也不算是一种通用的解题方法或者说算法，感觉只能适用于少量题目

```java
// 中心扩展算法
class P5_Solution {
    String s;
    int len;

    public String longestPalindrome(String s) {
        if (s == null) {
            return "";
        }
        this.s = s;
        this.len = s.length();
        if (len == 0 || len == 1) {
            return s;
        }

        // 最长回文子串的左右下标
        int start = 0, end = 0;
        // tempMaxLen 遍历过程中的最长回文子串长度
        int len1, len2, tempMaxLen;
        for (int i = 0; i < len; i++) {
            // 以 s.charAt(i) 为中心的奇数长度的回文子串的长度
            len1 = expandAroundCenter(i, i);
            // 以 s.charAt(i) 和 s.charAt(i + 1) 为中心的偶数长度的回文子串的长度
            len2 = expandAroundCenter(i, i + 1);
            // 此次循环中以上两种情况得到的最长回文子串的较大值
            tempMaxLen = Math.max(len1, len2);
            // 如果比历史的最长回文子串长, 更新
            if (tempMaxLen > end - start) {
                // 以上两种情况(回文子串长度为奇数或偶数)都能得到如下求左右下标的公式
                start = i - (tempMaxLen - 1) / 2;
                end = i + tempMaxLen / 2;
            }
        }

        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(int left, int right) {
        while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 返回此最长回文子串的长度
        return right - left - 1;
    }
}
```

##### Manacher 算法

#### [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

##### 基本操作——按行排序

```java
// 按行排序
class P6_Solution {
    // 我的解法, 思路同官方解法一, 按行排序
    public String convert1(String s, int numRows) {
        if (numRows == 1) {
            return s;
        }
        List<ArrayList<Character>> list = new ArrayList<>(numRows);
        // 此处一定要初始化, 之前在做课程表相关题时就遇到过
        for (int i = 0; i < numRows; i++) {
            list.add(new ArrayList<>());
        }
        // flag 表示是当前字符添加到链表上, 链表是增序(从上往下)还是降序(从左往右)
        boolean flag = true;
        // index 表示是当前字符添加到哪个链表上
        int index = 0;
        for (int i = 0; i < s.length(); i++) {
            if (flag) {
                list.get(index).add(s.charAt(i));
                index++;
                // 转变为从左往右添加
                if (index == numRows) {
                    flag = false;
                    index = numRows - 2;
                }
            } else {
                list.get(index).add(s.charAt(i));
                index--;
                // 转变为从上往下添加
                if (index == -1) {
                    flag = true;
                    index = 1;
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        for (ArrayList<Character> str : list) {
            for (Character character : str) {
                sb.append(character);
            }
        }
        return sb.toString();
    }

    // 针对上一个我的解法和官方解法一的代码优化, 解题思路基本不变, 只更改代码细节和实现方式
    public String convert(String s, int numRows) {
        if (numRows == 1) {
            return s;
        }
        List<StringBuilder> list = new ArrayList<>(numRows);
        for (int i = 0; i < numRows; i++) {
            list.add(new StringBuilder());
        }
        // curRow 表示是当前字符添加到哪个链表上
        int curRow = 0;
        // 每次添加完一个字符后, 都要确定下一个字符要添加在哪个 sb 后, 相应的索引可能要 加 1(从上往下) 或者减 1(从左往右)
        int flag = -1;
        for (int i = 0; i < s.length(); i++) {
            list.get(curRow).append(s.charAt(i));
            if (curRow == 0 || curRow == numRows - 1) {
                // 转变方向
                flag = -flag;
            }
            curRow += flag;
        }
        StringBuilder ans = new StringBuilder();
        for (StringBuilder row : list) {
            ans.append(row);
        }
        return ans.toString();
    }
}
```

##### 基本操作——按行访问

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

##### 双指针

2021.11.05

> 与官方解题思路一致，实现代码上有些微区别

```java
/**
 * 双指针
 */
class P11_Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                area = Math.max(area, (right - left) * height[left]);
                left++;
            } else {
                area = Math.max(area, (right - left) * height[right]);
                right--;
            }
            // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
        }
        return area;
    }

    // 逻辑优化 —— 不计算中间过程中肯定小于等于已知最大 area 的面积
    // 但是会多了很多其它代码以及逻辑判断
    public int maxArea1(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        int temp;
        while (left < right) {
            while (height[left] < height[right]) {
                temp = left;
                area = Math.max(area, (right - left) * height[left]);
                left++;
                while (left < right && height[left] <= height[temp]) {
                    left++;
                }
                // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
            }
            while (height[left] >= height[right]) {
                temp = right;
                area = Math.max(area, (right - left) * height[right]);
                right--;
                while (left < right && height[right] <= height[temp]) {
                    right--;
                }
                // System.out.println("left : " + left + " | right : " + right + " | area : " + area);
                if (right <= left) {
                    break;
                }
            }
        }
        return area;
    }
}
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

##### 排序 + 双指针

```java
class P15_Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int len = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        if (len < 3) {
            return ans;
        }
        Arrays.sort(nums);
        if (nums[0] > 0) {
            return ans;
        }
        int first, second, third;
        // 枚举 a
        for (first = 0; first < len; first++) {
            // 和上一次枚举的数不相同
            if(first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            third = len - 1;
            // 枚举 b c
            for (second = first + 1; second < len; second++) {
                // 和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > -nums[first]) {
                    third--;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了,可以退出循环
                if (second == third) {
                    break;
                }
                // 找到
                if (nums[second] + nums[third] == -nums[first]) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}
```

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class P23_Solution {
    // 分治合并
    public ListNode mergeKLists(ListNode[] lists) {
        int k = lists.length;
        // 链表为空，直接返回
        if (k == 0) {
            return null;
        }

        while (true) {
            if (k == 1) {
                return lists[0];
            } else if (k == 2) {
                return mergeTwoLists(lists[0], lists[k - 1]);
            }
            // 有奇数个链表,先将最后一个链表合并到第一个链表中,就可以看作有偶数个链表
            if (k % 2 == 1) {
                lists[0] = mergeTwoLists(lists[0], lists[k - 1]);
            }
            k = k / 2;
            // 将偶数(2k)个链表分别两两合并(第 i 个和第 i + k 个)成为前(k)个链表, 类似于归并排序——分治
            for (int i = 0; i < k; i++) {
                lists[i] = mergeTwoLists(lists[i], lists[i + k]);
            }
        }
    }

    // 顺序合并
    public ListNode mergeKLists2(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            // 链表为空,直接返回
            return null;
        } else if (len == 1) {
            // 只有一个链表,直接返回该链表
            return lists[0];
        }

        // 将其它链表依次插入到第一个链表中，类似于插入排序,性能不如前一个
        for (int i = 1; i < len; i++) {
            lists[0] = mergeTwoLists(lists[0], lists[i]);
        }

        return lists[0];
    }

    // 我的 mergeTwoLists
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) {
            list1 = list2;
            return list1;
        } else if (list2 == null) {
            return list1;
        }

        ListNode fromList;
        ListNode toList;
        // 将两个链表中的第一个节点值较小的那个链表认为被插入链表 toList
        if (list1.val <= list2.val) {
            fromList = list2;
            toList = list1;
        } else {
            fromList = list1;
            toList = list2;
        }
        // cur 初始化为被插入链表 toList 的第一个节点
        ListNode cur = toList;
        ListNode pre = new ListNode();
        // pre 指向被插入链表 toList 的第一个节点
        pre.next = cur;
        ListNode temp;
        // 将 fromList 链表中的元素插入到 toList 链表中
        while (fromList != null && cur != null) {
            // toList 链表中的当前节点的值小于等于当前 fromList 链表中的第一个节点的值时
            // 改变 toList 链表中的 pre 和 cur 指针
            if (cur.val <= fromList.val) {
                pre = cur;
                cur = cur.next;
            } else {
                // 此时,fromList 链表中的第一个节点的值小于 cur 节点处的值,大于等于 pre 节点处的值
                // 将 fromList 链表中的第一个节点 插入到 pre 和 cur 之间
                temp = fromList.next;
                pre.next = fromList;
                fromList.next = cur;
                pre = fromList;
                fromList = temp;
            }
        }
        if (cur == null) {
            pre.next = fromList;
        }
        return toList;
    }

    // 官方的 mergeTwoLists, 实现更简洁
    public ListNode mergeTwoLists1(ListNode list1, ListNode list2) {
        if (list1 == null || list2 == null) {
            return list1 != null ? list1 : list2;
        }

        ListNode head = new ListNode();
        ListNode tail = head;
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }

        tail.next = list1 == null ? list2 : list1;
        return head.next;
    }
}
```

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

##### 二分查找

```java
class P33_Solution {
    // 顺序查找
    // 时间复杂度: O(n)
    // 空间复杂度: O(1)
    public int search1(int[] nums, int target) {
        int n = nums.length;
        if (n <= 0) {
            return -1;
        } else if (n == 1) {
            if (nums[0] == target) {
                return 0;
            } else {
                return -1;
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] == target) {
                return i;
            }
        }
        return -1;
    }

    // 二分查找
    // 时间复杂度: O(log n)
    // 空间复杂度: O(1)
    public int search2(int[] nums, int target) {
        int n = nums.length;
        // 可删的特殊情况判断
        if (n <= 0) {
            return -1;
        } else {
            if (nums[0] == target) {
                return 0;
            } else if (nums[n - 1] == target) {
                return n - 1;
            }
            if (n == 1) {
                return -1;
            }
        }
        int left = 0, right = n - 1, mid;
        // onTheLeft 为真 target 在左边
        boolean onTheLeft = target >= nums[0];
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] < target) {
                // 题目保证 nums 中的每个值都 独一无二
                // mid 在左边
                if (nums[mid] >= nums[0]) {
                    left = mid + 1;
                } else {
                    // mid 在右边
                    // target 在左边
                    if (onTheLeft) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }
            } else if (nums[mid] > target) {
                // mid 在右边
                if (nums[mid] < nums[0]) {
                    right = mid - 1;
                } else {
                    // mid 在左边
                    // target 在左边
                    if (onTheLeft) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }
            }
        }
        return -1;
    }

    // 二分查找
    // 时间复杂度: O(log n)
    // 空间复杂度: O(1)
    // 代码简化
    public int search(int[] nums, int target) {
        int n = nums.length;
        // 可删的特殊情况判断
        if (n <= 0) {
            return -1;
        } else {
            if (nums[0] == target) {
                return 0;
            } else if (nums[n - 1] == target) {
                return n - 1;
            }
            if (n == 1) {
                return -1;
            }
        }
        int left = 0, right = n - 1, mid;
        // onTheLeft 为真 target 在左边
        boolean onTheLeft = target >= nums[0];
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] < target) {
                // target 和 mid 在同一边
                if (!onTheLeft || nums[mid] >= nums[0]) {
                    left = mid + 1;
                } else {
                    // target 在左边, mid 在右边
                    right = mid - 1;
                }
            } else if (nums[mid] > target) {
                // target 和 mid 在同一边
                if (onTheLeft || nums[mid] < nums[0]) {
                    right = mid - 1;
                } else {
                    // target 在右边, mid 在左边
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```java
class P35_Solution {
    public int searchInsert1(int[] nums, int target) {
        if (nums.length == 1) {
            if (nums[0] >= target) {
                return 0;
            } else {
                return 1;
            }
        }
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        if (mid == 0) {
            if (nums[0] > target) {
                return 0;
            } else if (nums[1] > target) {
                return 1;
            }
        } else if (mid == nums.length - 1) {
            if (nums[mid] < target) {
                return mid + 1;
            } else if (nums[mid - 1] < target) {
                return mid;
            }
        } else {
            if (nums[mid - 1] > target) {
                return mid - 1;
            } else if (nums[mid] > target) {
                return mid;
            } else if (nums[mid + 1] > target) {
                return mid + 1;
            }
        }
        return 0;
    }

    public int searchInsert(int[] nums, int target) {
        if (nums.length == 1) {
            if (nums[0] >= target) {
                return 0;
            } else {
                return 1;
            }
        }
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        // left > right 的情形, 数组中无目标值
        // 表示最后一步从 right = middle - 1 分支跳出, 也即 nums[middle] > target, 重新插入位置即为 mid
        if (right < mid) {
            return mid;
        }
        // 表示 nums[mid] < target, 重新插入位置为 mid + 1, 此时的 mid + 1 也等于 left
        return mid + 1;
        // 也等价于 return right == mid - 1 ? mid : mid + 1;
        // 也等价于 return left == mid + 1 ? left : mid;
    }
}
```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

##### 我的解法

###### 2021.11.04

> 2021.11.04 解法，首次完成

```java
class P42_Solution {
    public int trap(int[] height) {
        int len = height.length;
        if (len <= 2) {
            return 0;
        }
        // 左边柱子 和 右边柱子
        int left = 0, right;
        // 遍历到 left 时, left [左边]所有柱子的高度和
        int leftSum;
        // 遍历到 right 时, right [左边]所有柱子的高度和
        // 初始时 rightSum 为第一个柱子的高度
        int rightSum = height[0];
        // 水滴, 也就是面积
        int water = 0;

        // 1.左边部分
        // 每次循环都是找到以 left 为左边, right 为右边围成的坑, 直到最高柱子结束循环
        // 此处 while(true) 也对
        while (left < len) {

            leftSum = rightSum;
            right = left + 1;
            // 从 left 柱子的下一个柱子开始遍历
            while (right < len) {
                rightSum += height[right];
                // 在 left 柱子的右侧找到第一个比 left 柱子更高或者相等高度的柱子 right
                if (height[right] >= height[left]) {
                    // 计算 left 与 right 之间能装多少水滴
                    water += (right - left - 1) * height[left] - (rightSum - leftSum - height[right]);
                    break;
                }

                // 没有找到就找下一个柱子是否比 left 柱子高
                right++;
            }
            // 退出内层 while 时, 如果 right < len, 说明在 left 到 height.length - 1 之间, 找到了 right 柱子,
            // right 柱子比 left 柱子高或者高度相等, 直接进行下次外层 while 循环
            if (right < len) {
                // 下一次外层 while 循环是从 right 处找到以 right 为左边条边的坑
                left = right;
            } else if (right == len) {
                // 退出内层 while 时, 如果 right == len, 那么此时 left 柱子的高度值 height[left] 最大,
                // 当然在 left 到 height.length - 1 之间也就找不到 right 柱子满足要求了,
                // 于是直接退出外层 while 循环, 从数组末尾开始往前找
                break;
            }
        }
//        // 测试, 输出结束时的柱子总高度
//        System.out.println("1 ---- < " + leftSum);
//        System.out.println("1 ---- > " + rightSum);

        // 2.右边部分
        // 记录最高柱子的下标
        int max = left;
        right = len - 1;
        // 重设为 0;
        // 此处
        // 遍历到 left 时, left [右边]所有柱子的高度和
        // 初始时 leftSum 为最后一个柱子的高度
        leftSum = height[len - 1];
        // 遍历到 right 时, right [右边]所有柱子的高度和
        rightSum = 0;
        while (right >= max) {

            rightSum = leftSum;
            left = right - 1;

            while (left >= max) {
                leftSum += height[left];
                if (height[left] >= height[right]) {
                    water += (right - left - 1) * height[right] - (leftSum - rightSum - height[left]);
                    break;
                }

                left--;
            }
            if (left >= max) {
                right = left;
            }
            // 右边条边为最高柱子时结束外层 while 循环, 此时 water 值即为答案
            if (right == max) {
                break;
            }
        }
//        // 测试, 输出结束时的柱子总高度
//        System.out.println("2 ---- < " + leftSum);
//        System.out.println("2 ---- > " + rightSum);
        return water;
    }
}
```

```java
/**
 * 相比较于上一个, 此处将上述的步骤进行了封装, 并且小小改变了一下计算 water 的方式,
 * 由于只需要知道 leftSum 和 rightSum 之间的差值即可,
 * 故将 water 公式中的 leftSum 与 rightSum 之差更改为 midSum
 */
class P42_Solution1 {
    // 水滴, 也就是面积
    private int water;

    public int trap(int[] height) {
        if (height.length <= 2) {
            return 0;
        }
        // 初始化水滴数为 0
        water = 0;
        // 得到最高柱子的下标, 同时也会计算最高柱子前的所有水滴数
        int max = leftWater(height);
        // 得到最终的 water 数
        rightWater(height, max);
        return water;
    }

    /**
     * 1.左边部分
     * 从左往右遍历, 计算最高柱子之前的坑中的水滴数, 返回最高柱子的下标
     *
     * @param height 数组
     * @return left 结束时 left 为最高柱子的下标
     */
    public int leftWater(int[] height) {
        // 左边柱子 和 右边柱子
        int left = 0, right;
        // left 与 right 之间(包含height[right])的所有方格数(柱子高度)总和
        int midSum;

        int len = height.length;
        // 每次循环都是找到以 left 为左边, right 为右边围成的坑, 直到最高柱子结束循环
        while (left < len) {
            // 从 left 柱子的下一个(右边)柱子开始往右遍历
            right = left + 1;
            // 新一轮循环, 置为 0
            midSum = 0;
            while (right < len) {
                midSum += height[right];
                // 在 left 柱子的右侧找到第一个比 left 柱子更高或者相等高度的柱子 right
                if (height[right] >= height[left]) {
                    // 计算 left 与 right 之间能装多少水滴
                    // water += (right - left - 1) * height[left] - (midSum - height[right]);
                    water += calWater(left, right, height[left], height[right], midSum);
                    break;
                }

                // 没有找到就找下一个柱子是否比 left 柱子高
                right++;
            }
            // 退出内层 while 时, 如果 right < len, 说明在 left 到 height.length - 1 之间, 找到了 right 柱子,
            // right 柱子比 left 柱子高或者高度相等, 直接进行下次外层 while 循环
            if (right < len) {
                // 下一次外层 while 循环是从 right 处找到以 right 为左边条边的坑
                left = right;
            } else if (right == len) {
                // 退出内层 while 时, 如果 right == len, 那么此时 left 柱子的高度值 height[left] 最大,
                // 当然在 left 到 height.length - 1 之间也就找不到 right 柱子满足要求了,
                // 于是直接退出外层 while 循环, 从数组末尾开始往前找
                break;
            }
        }
        // 最高柱子下标
        return left;
    }

    /**
     * 2.右边部分
     * 从右往左遍历, 计算从末尾到最高柱子之间的坑中的水滴数
     *
     * @param height 数组
     * @param max    最高柱子下标
     */
    public void rightWater(int[] height, int max) {
        // 左边柱子 和 右边柱子
        int left, right = height.length - 1;
        // left 与 right 之间(包含height[left])的所有方格数(柱子高度)总和
        int midSum;
        // 倒序遍历
        while (right >= max) {
            // 从 right 柱子的下一个(左边)柱子开始往左遍历
            left = right - 1;
            // 新一轮循环, 置为 0
            midSum = 0;
            while (left >= max) {
                midSum += height[left];
                if (height[left] >= height[right]) {
                    // 计算 left 与 right 之间能装多少水滴
                    // water += (right - left - 1) * height[right] - (midSum - height[left]);
                    water += calWater(left, right, height[left], height[right], midSum);
                    break;
                }

                left--;
            }
            if (left >= max) {
                right = left;
            }
            // 右边条边为最高柱子时结束外层 while 循环, 此时 water 值即为答案
            if (right == max) {
                break;
            }
        }
    }

    /**
     * 计算 left 与 right 之间的水滴数
     *
     * @param left        左边柱子的下标
     * @param right       右边柱子的下标
     * @param leftHeight  左边柱子的高度
     * @param rightHeight 右边柱子的高度
     * @param midSum      左右两边柱子之间的所有柱子的高度和(包含 leftHeight 与 rightHeight 中的较大值)
     * @return waterSum   left 与 right 之间的水滴数
     */
    public int calWater(int left, int right, int leftHeight, int rightHeight, int midSum) {
        int waterSum = 0;
        if (leftHeight > rightHeight) {
            waterSum = (right - left - 1) * rightHeight - (midSum - leftHeight);
        } else {
            waterSum = (right - left - 1) * leftHeight - (midSum - rightHeight);
        }
        return waterSum;
    }
}
```

> 2021.11.04 凌晨
>
> 我还没看官方答案，等白天再来看是否比官方答案差很多。
>
> 我的思路是：因为接水滴，肯定要有一个坑，就是有left边和right边，那么从左往右遍历，找到比left边高或者高度相等的right 边，找到了的话就可以计算这个坑的水滴了，然后下一次遍历将这个right边作为left边，去找它的right边，如果没有找到，说明现在这个left边的高度是最高的，那么就从末尾倒序开始用同样的思维找，直到这个最高边为止。
>
> 不同之处在于，从前往后遍历时，left是固定的，找的是 right边；而倒序查找时，固定的是 right 边，找的是 left边。
>
> 想想复杂度
>
> 时间复杂度：当找到最高柱子时，遍历了`j + n - j` 次，j 为最高柱子的下标，然后反向又要遍历 `n - j` 次，可能不是很精确，这公式只有常数次误差 ，那么总共就是 `2n - j`，如果最高柱子在末尾，就为 n , 在数组头， 就为 2n，时间复杂度为 `O(n)`
>
> 空间复杂度：我就只创建了几个整形int变量，所以为`O(1)`
>
> 2021.11.04 下午
>
> 在看了之前其他人的代码后，发现我这思路其它人也有写过，哈哈，巧了。
>
> 至于官方参考答案，
>
> 方法一的动态规划是在有水滴的地方，一列一列加的，总共遍历了 3n 次
>
> 方法二的单调栈是在有水滴的地方，一行一行加的，次数应该是为 2n 次，不知道具体是否准确
>
> 方法三的双指针是在方法一的动态规划上将遍历次数减少，将方法一循环中的 `ans += Math.min(leftMax[i], rightMax[i]) - height[i];` 变成了 方法三中的 `if ... else ...`， 在动态规划的同时，计算雨水 ans，而方法一，是将动态规划做完后，再从头遍历一遍得到的雨水量 ans。 还有一点区别是，方法一的动态规划是用了两个数组保存了所有位置处的左边最高柱子和右边最高柱子的下标，空间复杂度为O(n)，而方法三由于边遍历边计算，不需要保留每个位置处的左边最高柱子和右边最高柱子的下标，采用了两个整型变量`leftMax`和`rightMax `代替了这两个数组，于是降低了空间复杂度。
>
> 方法一三都是一列一列计算的，而我的思路是一个水坑一个水坑计算的。

##### 暴力解法

##### 动态规划

##### 单调栈

##### 双指针

> 双指针好难理解啊

###### 官方的第一个参考解法

```Java
class Solution {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int ans = 0;
        int left_max = 0, right_max = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= left_max) {
                    left_max = height[left];
                } else {
                    ans += (left_max - height[left]);
                }
                ++left;
            } else {
                if (height[right] >= right_max) {
                    right_max = height[right];
                } else {
                    ans += (right_max - height[right]);
                }
                --right;
            }
        }
        return ans;
    }
}
```

###### 官方的第二个参考解法

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}
```

###### 我修改后

> 根据 官方的第二个参考解法 修改

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = height[left], rightMax = height[right];
        while (left < right) {
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left; 
                leftMax = Math.max(leftMax, height[left]);
            } else {
                ans += rightMax - height[right];
                --right;
                rightMax = Math.max(rightMax, height[right]);
            }
        }
        return ans;
    }
}
```

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

##### 贪心

###### 第一种实现：反向查找出发位置

```java
// 贪心: 方法一: 反向查找出发位置
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class P45_Solution1 {
    public int jump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return 0;
        }
        // 要走到的位置
        int position = nums.length - 1;
        // 跳跃次数
        int steps = 0;
        while (position > 0) {
            for (int i = 0; i < position; i++) {
                if (i + nums[i] >= position) {
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n^2)，其中 n 是数组长度。有两层嵌套循环，在最坏的情况下，例如数组中的所有元素都是 1，position 需要遍历数组中的每个位置，对于 position 的每个值都有一次循环。
>
>
> - 空间复杂度：O(1)
>

###### 第二种实现：正向查找可到达的最大位置

```java
// 贪心: 方法二：正向查找可到达的最大位置
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class P45_Solution {
    public int jump(int[] nums) {
        if (nums == null) {
            return 0;
        }

        int n = nums.length;

        if (n <= 1) {
            return 0;
        }
        // 每一段遍历要走到的最后位置, 遍历过程中比较确定下一步能够走到的最远位置
        // 上次跳跃可达范围右边界（下次的最右起跳点）
        int end = 0;
        // 目前能跳到的最远位置
        int maxPosition = 0;
        // 跳跃次数
        int steps = 0;

        for (int i = 0; i < n - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]);
            if (i == end) {
                // 目前能跳到的最远位置变成了下次起跳位置的右边界
                end = maxPosition;
                steps++;
            }
        }

        return steps;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 是数组长度
> - 空间复杂度：O(1)

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

##### 回溯

```java
class P46_Solution {
    int[] nums;
    int len;
    // 使用一个动态数组保存所有可能的全排列
    List<List<Integer>> ans;
    Deque<Integer> path;
    boolean[] used;

    public List<List<Integer>> permute(int[] nums) {
        this.nums = nums;
        this.len = nums.length;
        this.used = new boolean[len];
        this.path = new ArrayDeque<>(len);
        this.ans = new ArrayList<>();
        // 长度为 0, 返回 [[]]
        if (len == 0) {
            return ans;
        }
        // 只有一个数, 返回 [[nums[0]]]
        if (len == 1) {
            path.add(nums[0]);
            ans.add(new ArrayList<>(path));
            return ans;
        }

        dfs(0);
        return ans;
    }

    public void dfs(int depth) {
        // 遍历到的层数 等于 数字的个数时
        if (depth == len) {
            // 将当前路径添加进 ans 中
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                dfs(depth + 1);

                path.removeLast();
                used[i] = false;
            }
        }
    }
}
```

BFS 待定

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```java
class P47_Solution {
    int[] nums;
    int n;
    List<List<Integer>> ans;
    Deque<Integer> path;
    boolean[] visited;

    public List<List<Integer>> permuteUnique(int[] nums) {
        this.nums = nums;
        this.n = nums.length;
        this.ans = new ArrayList<>();
        this.path = new ArrayDeque<>(n);
        this.visited = new boolean[n];

        // 特殊情况处理 长度为 1 的序列直接返回
        if (n == 1) {
            path.add(nums[0]);
            ans.add(new ArrayList<>(path));
            return ans;
        }

        // 从第一个位置开始遍历
        backtrack(0);

        return ans;
    }

    public void backtrack(int depth) {
        if (depth == n) {
            ans.add(new ArrayList<>(path));
            return;
        }
        // 将确定该层的元素的值保存在 hashSet 中, 下一次遍历如果遇到该值, 则跳过, 剪枝所用
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 0; i < n; i++) {
            // 没有遍历过当前位置并且当前位置值在曾经也没有被遍历过
            if (!visited[i] && !hashSet.contains(nums[i])) {

                path.add(nums[i]);
                visited[i] = true;

                hashSet.add(nums[i]);
                // 遍历下一个位置
                backtrack(depth + 1);

                // 回溯 更新
                path.removeLast();
                visited[i] = false;
            }
        }
    }
}
```



#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

##### 我的解法

```java
class P50_Solution {
    // 我的 同官方解法 二
    public boolean canJump1(int[] nums) {
        // 特殊情况判断
        if (nums == null || nums.length == 0) {
            return false;
        }
        int n = nums.length;
        if (n == 1) {
            return true;
        }
        if (n == 2) {
            return nums[0] >= 1;
        }

        // 能够到达终点(最后一个下标)的最小索引
        // 从后往前遍历, 在已知位于 i 到 n - 1 之间的 minIndexOfCanJump 能够到达 n - 1 位置的前提下
        // 如果 i 能够到达 minIndexOfCanJump, 说明 i 也能到达 n - 1, 那么此时更新 minIndexOfCanJump 值为 i
        int minIndexOfCanJump = n - 1;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] >= minIndexOfCanJump - i) {
                minIndexOfCanJump = i;
            }
        }

        // 如果最终 minIndexOfCanJump 等于了 0, 说明从 0 可以跳到 n - 1
        return minIndexOfCanJump == 0;
    }

    // 我的优化 —— 反而效率降低了
    public boolean canJump(int[] nums) {
        // 特殊情况判断
        if (nums == null || nums.length == 0) {
            return false;
        }
        int n = nums.length;
        if (n == 1) {
            return true;
        }
        if (n == 2) {
            return nums[0] >= 1;
        }

        // 能够到达终点(最后一个下标)的最小索引
        // 从后往前遍历, 在已知位于 i 到 n - 1 之间的 minIndexOfCanJump 能够到达 n - 1 位置的前提下
        // 如果 i 能够到达 minIndexOfCanJump, 说明 i 也能到达 n - 1, 那么此时更新 minIndexOfCanJump 值为 i
        int minIndexOfCanJump = n - 1;
        int maxJump = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] >= minIndexOfCanJump - i) {
                minIndexOfCanJump = i;
            }
            // 以下几行可删
            int j = n - 2 - i;
            if (j > maxJump) {
                return false;
            }
            maxJump = Math.max(maxJump, j + nums[j]);
            if (maxJump >= minIndexOfCanJump) {
                return true;
            }
        }

        // 如果最终 minIndexOfCanJump 等于了 0, 说明从 0 可以跳到 n - 1
        return minIndexOfCanJump == 0;
    }
}
```

##### 贪心

> 这个想法说成贪心，感觉过于为了取名而取名了，就是个思路而已



#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

##### 动态规划

```java
public class P62_UniquePaths {
    public static void main(String[] args) {
        int m = 3;
        int n = 3;
        P62_Solution solution = new P62_Solution();
        System.out.println(solution.uniquePaths(m, n));
        System.out.println(solution.uniquePaths1(m, n));
        System.out.println(solution.uniquePaths2(m, n));
    }
}

class P62_Solution {
    // 简单的动态规划
    // 时间复杂度：O(mn)
    // 空间复杂度：O(mn)
    public int uniquePaths(int m, int n) {
        int[][] arr = new int[m + 1][n + 1];
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (i == m - 1 && j == n - 1) {
                    arr[m - 1][n - 1] = 1;
                } else {
                    arr[i][j] = arr[i + 1][j] + arr[i][j + 1];
                }
            }
        }
        return arr[0][0];
    }

    // 动态规划, 上一个方法的等价, 不用每次循环内判断
    // 此方法和代码实现与官方答案一极为类似, 可以等价
    // 时间复杂度：O(mn)
    // 空间复杂度：O(mn)
    public int uniquePaths1(int m, int n) {
        // 只有一行, 返回 1
        if (m == 1) {
            return 1;
        }
        int[][] arr = new int[m][n];
        // 最后一行置为 1
        for (int j = 0; j < n; j++) {
            arr[m - 1][j] = 1;
        }
        // 最后一列置为 1
        for (int i = 0; i < m; i++) {
            arr[i][n - 1] = 1;
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                arr[i][j] = arr[i + 1][j] + arr[i][j + 1];
            }
        }
        return arr[0][0];
    }

    // 优化上一个方法的空间复杂度, 只用一个一维数组来记录路径长度,
    // 并且由于交换m,n的值对答案无影响, 因此该数组长度最好为 min(m,n)
    // 时间复杂度：O(mn)
    // 空间复杂度：O(min(m,n))
    public int uniquePaths2(int m, int n) {
        // 只有一行, 返回 1
        if (m == 1) {
            return 1;
        }
        // m 为较大值(代表行), n 为较小值(代表列)
        if (m < n) {
            int temp = m;
            m = n;
            n = temp;
        }
        int[] arr = new int[n];
        arr[n - 1] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                arr[j] += +arr[j + 1];
            }
        }
        return arr[0];
    }
}
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

##### 动态规划

```java
class P63_Solution {
    // 时间复杂度: O(nm), 其中 m 为网格的行数, n 为网格的列数, 只需要遍历所有网格一次即可
    // 空间复杂度: O(m)O(m), 利用滚动数组优化, 可以只用 O(n) 大小的空间来记录当前行到右下角的 path 值
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 行
        int m = obstacleGrid.length;
        // 列
        int n = obstacleGrid[0].length;
        // 右下角为障碍物, 返回 0
        if (obstacleGrid[m - 1][n - 1] == 1) {
            return 0;
        }
        // 只有一行且无障碍物, 返回 1
        if (m == 1) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[0][j] == 1) {
                    return 0;
                }
            }
            return 1;
        }
        // 只有一列且无障碍物, 返回 1
        if (n == 1) {
            for (int i = 0; i < m; i++) {
                if (obstacleGrid[i][0] == 1) {
                    return 0;
                }
            }
            return 1;
        }

        // 「滚动数组思想」把空间复杂度优化成 O(n)
        int[] dp = new int[n];
        dp[n - 1] = 1;

        for (int i = m - 1; i >= 0; i--) {
            // 等价于 dp[n - 1] = (obstacleGrid[i][n - 1] != 1) ? dp[n - 1] : 0;
            if (obstacleGrid[i][n - 1] == 1) {
                dp[n - 1] = 0;
            }
            for (int j = n - 2; j >= 0; j--) {
                // 等价于 dp[j] = (obstacleGrid[i][j] != 1) ? dp[j] + dp[j + 1] : 0;
                // 如果该格子是障碍物, 则不能从该格子走到右下角, dp[j] 为 0
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else {
                    // 如果不是障碍物, 则从该格子走到右下角的路径数为
                    // 下边一个格子走到右下角的路径数 (dp[j]) 与右边一个格子走到右下角的路径数 (dp[j + 1]) 的和
                    dp[j] += dp[j + 1];
                }
            }
        }
        return dp[0];
//        // 也可以为
//        // 「滚动数组思想」把空间复杂度优化成 O(n)
//        int[] dp = new int[n + 1];
//        dp[n - 1] = 1;
//
//        for (int i = m - 1; i >= 0; i--) {
//            for (int j = n - 1; j >= 0; j--) {
//                // 等价于 dp[j] = (obstacleGrid[i][j] != 1) ? dp[j] + dp[j + 1] : 0;
//                if (obstacleGrid[i][j] == 1) {
//                    dp[j] = 0;
//                    continue;
//                }
//                dp[j] += dp[j + 1];
//            }
//        }
//        return dp[0];
    }
}
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

##### 动态规划

```java
// 动态规划
class P64_Solution {
    // 时间复杂度 O(MN), 2 ms 95.93%
    // 空间复杂度 O(MN), 44.1 MB 5.06%
    public int minPathSum1(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        // 右下角终点处
        dp[m - 1][n - 1] = grid[m - 1][n - 1];
        // 最后一行 m-1
        for (int j = n - 2; j >= 0; j--) {
            dp[m - 1][j] = dp[m - 1][j + 1] + grid[m - 1][j];
        }
        // 最后一列 n-1
        for (int i = m - 2; i >= 0; i--) {
            dp[i][n - 1] = dp[i + 1][n - 1] + grid[i][n - 1];
        }
        // 其余 m-2 行 n-2 列
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                dp[i][j] = Math.min(dp[i][j + 1], dp[i + 1][j]) + grid[i][j];
            }
        }/*
        for (int[] row : dp) {
            System.out.println(Arrays.toString(row));
        }*/
        return dp[0][0];
    }

    // 滚动数组思想优化空间复杂度为 O(N)
    // 时间复杂度 O(MN), 2 ms 95.93%
    // 空间复杂度 O(N), 43.7 MB 9.23%
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[] dp = new int[n];
        // 右下角终点处
        dp[n - 1] = grid[m - 1][n - 1];
        // 最后一行 m-1
        for (int j = n - 2; j >= 0; j--) {
            dp[j] = dp[j + 1] + grid[m - 1][j];
        }
        System.out.println(Arrays.toString(dp));
        // 其余 m-2 行
        for (int i = m - 2; i >= 0; i--) {
            dp[n - 1] += grid[i][n - 1];
            for (int j = n - 2; j >= 0; j--) {
                dp[j] = Math.min(dp[j + 1], dp[j]) + grid[i][j];
            }
            System.out.println(Arrays.toString(dp));
        }
        return dp[0];
    }
}
```



#### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

##### 二分查找

```java
class P69_Solution {
    // 当 x 很大时, 数据 int target == mid * mid 会溢出
    // 定义成 long target == (long)mid * mid 就不会了
    public int mySqrt1(int x) {
        int left = 0, right = x;
        int mid = 0;
        long target;
        while (left <= right) {
            mid = left + (right - left) / 2;
            target = (long) mid * mid;
            if (target == x) {
                return mid;
            } else if (target > x) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return right < mid ? mid - 1 : mid;
    }

    // 刚开始以为使用 mid * mid 的方式不能比较, 于是想到使用 x / mid 与 mid 比较的方式
    public int mySqrt(int x) {
        if (x == 0 || x == 1) {
            return x;
        }
        int left = 0, right = x;
        int mid = 0;
        int y;
        while (left <= right) {
            mid = left + (right - left) / 2;
            y = x / mid;
            if (mid == y) {
                return mid;
            } else if (mid > y) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // return right < mid ? mid - 1 : mid; // right == mid - 1, left == mid, 返回 mid - 1
        // return left > mid ? mid : mid - 1; //  left == mid + 1, right == mid, 返回 mid
        // 综上, 可直接返回 right
        return right;
    }
}
```

##### 牛顿迭代法



#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

##### 递归

##### 记忆化递归

##### 动态规划

2021.11.05

> 之前做过斐波那契数列，这题和它一模一样

```java
// 最初我还以为这个状态转移方程不对
class P70_Solution {
    // 动态规划
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 2;
        }
        int[] dp = new int[]{1, 2, 0};
        for (int i = 3; i <= n; i++) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
}
```

##### 矩阵快速幂

##### 通项公式

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

##### 动态规划

```java
class P72_Solution {
    // 二维动态规划
    // 时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。
    // 空间复杂度 ：O(mn)，我们需要大小为 O(mn) 的 DP 数组来记录状态值。
    public int minDistance1(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length();
        int n = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        int[][] dp = new int[m + 1][n + 1];

        // 边界状态初始化
        // 空串转换为字符串的转换次数为字符串的长度
        // 初始化首列
        for (int i = 0; i < m + 1; i++) {
            dp[i][0] = i;
        }
        // 字符串转换为空串的转换次数为字符串的长度
        // 初始化首行
        for (int j = 0; j < n + 1; j++) {
            dp[0][j] = j;
        }
        // 计算所有 DP 值
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 三种情况的最小值
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1]);
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }

    // 一维动态规划(滚动数组思想)
    // 时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。
    // 空间复杂度 ：O(n)，我们需要大小为 O(n) 的 DP 数组来记录状态值。
    public int minDistance2(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length();
        int n = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        int[] dp = new int[n + 1];

        // 边界状态初始化, 初始化 dp 数组
        // 字符串转换为空串的转换次数为字符串的长度
        for (int j = 0; j < n + 1; j++) {
            dp[j] = j;
        }
        // 计算所有 DP 值
        for (int i = 1; i < m + 1; i++) {
            // 初始化保存 dp[0] 处的值为 pre
            int pre = i;
            for (int j = 1; j < n + 1; j++) {
                // pre 保存的是现在第 i 次循环中 dp[j - 1] 处的值
                // 而此时 dp[j - 1] 及其以后的值都是上次(第 i - 1 次)循环中的值
                int temp = pre;
                // 三种情况的最小值
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1]);
                } else {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1] + 1);
                }
                // 此时的 pre 保存的就是当前次循环中 dp[j] 处的值, 但是现在还不能给 dp[j] 赋值
                // 因为下一次 j + 1 的循环还需要用到上次(第 i - 1 次)循环中 dp[j] 处的值
                // 但是在此处就要更新 dp[j - 1] 处的值了, 因为后续的循环用不到上次(第 i - 1 次)循环中 dp[j - 1] 处的值了
                dp[j - 1] = temp;
            }
            // 循环结束后, dp 的最后一个位置处的次数还没更新, 在此处更新
            dp[n] = pre;
        }
        return dp[n];
    }

    // 一维动态规划(滚动数组思想)
    // 时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。
    // 空间复杂度 ：O(min(m,n))，我们需要大小为 O(min(m,n)) 的 DP 数组来记录状态值。
    public int minDistance(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length();
        int n = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        if (m >= n) {
            return getMinDistance(word1, word2);
        } else {
            return getMinDistance(word2, word1);
        }
    }

    public int getMinDistance(String longWord, String shortWord) {
        if (shortWord == null || longWord == null) {
            return 0;
        }
        int m = longWord.length();
        int n = shortWord.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        int[] dp = new int[n + 1];

        // 边界状态初始化, 初始化 dp 数组
        // 字符串转换为空串的转换次数为字符串的长度
        for (int j = 0; j < n + 1; j++) {
            dp[j] = j;
        }
        // 计算所有 DP 值
        for (int i = 1; i < m + 1; i++) {
            // 初始化保存 dp[0] 处的值为 pre
            int pre = i;
            for (int j = 1; j < n + 1; j++) {
                // pre 保存的是现在第 i 次循环中 dp[j - 1] 处的值
                // 而此时 dp[j - 1] 及其以后的值都是上次(第 i - 1 次)循环中的值
                int temp = pre;
                // 三种情况的最小值
                if (longWord.charAt(i - 1) == shortWord.charAt(j - 1)) {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1]);
                } else {
                    pre = Math.min(Math.min(dp[j] + 1, pre + 1), dp[j - 1] + 1);
                }
                // 此时的 pre 保存的就是当前次循环中 dp[j] 处的值, 但是现在还不能给 dp[j] 赋值
                // 因为下一次 j + 1 的循环还需要用到上次(第 i - 1 次)循环中 dp[j] 处的值
                // 但是在此处就要更新 dp[j - 1] 处的值了, 因为后续的循环用不到上次(第 i - 1 次)循环中 dp[j - 1] 处的值了
                dp[j - 1] = temp;
            }
            // 循环结束后, dp 的最后一个位置处的次数还没更新, 在此处更新
            dp[n] = pre;
        }
        return dp[n];
    }
}
```



#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

##### 回溯

> 在官方代码基础上更改的，并没本质提升，这题我自己挺难做的

```java
// 回溯
class P93_Solution {
    static final int SEG_COUNT = 4;
    int len;
    int[] segments = new int[SEG_COUNT];
    List<String> ans;
    // List<String> ans = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        ans = new ArrayList<>();
        if (s == null) {
            return ans;
        }
        this.len = s.length();
        if (len < 4 || len > 12) {
            return ans;
        }

        if (len == 4) {
            StringBuilder ipAddr = new StringBuilder();
            for (int i = 0; i < 4; i++) {
                ipAddr.append(s.charAt(i));
                if (i <= 2) {
                    ipAddr.append('.');
                }
            }
            ans.add(ipAddr.toString());
            return ans;
        }

        dfs(s, 0, 0);
        return ans;
    }

    public void dfs(String s, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) {
            if (segStart == len) {
                StringBuilder ipAddr = new StringBuilder();
                for (int i = 0; i < SEG_COUNT; i++) {
                    ipAddr.append(segments[i]);
                    if (i <= 2) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串, 那么提前回溯
        if (segStart == len) {
            return;
        }

        // 删除此 if 不影响结果
        if (len - segStart > (SEG_COUNT - segId) * 3) {
            return;
        } else if (len - segStart == (SEG_COUNT - segId) * 3) {
            for (int i = 0; i < SEG_COUNT - segId; i++) {
                int temp = s.charAt(segStart + i * 3) - '0';
                if (temp == 0 || temp > 2) {
                    return;
                }
                if (temp == 2) {
                    int temp1 = s.charAt(segStart + i * 3 + 1) - '0';
                    if (temp1 >= 6) {
                        return;
                    }
                    if (temp1 == 5 && (s.charAt(segStart + i * 3 + 2) - '0') >= 6) {
                        return;
                    }
                }
            }
            StringBuilder ipAddr = new StringBuilder();
            for (int i = 0; i < SEG_COUNT; i++) {
                if (i < segId) {
                    ipAddr.append(segments[i]);
                } else {
                    ipAddr.append(s.substring(segStart, segStart + 3));
                }
                if (i <= 2) {
                    ipAddr.append('.');
                }
            }
            ans.add(ipAddr.toString());
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int i = segStart; i < len; i++) {
            addr = addr * 10 + (s.charAt(i) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, i + 1);
            } else {
                break;
            }
        }
    }
}
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

##### 我的解法

```java
// 面试时写的代码, 有一些不改变逻辑以及所使用的数据结构的小修改, 使其能够直接复制在 LeetCode 上
class ODInterview_2022_01_11_solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root.left);
        queue.add(root.right);
        while (!queue.isEmpty()) {
            int size = queue.size();
            TreeNode[] arr = new TreeNode[size / 2];
            // 前一半
            for (int i = 0; i < size / 2; i++) {
                TreeNode node = queue.remove();
                arr[i] = node;
                if (node != null) {
                    queue.add(node.left);
                    queue.add(node.right);
                }
            }
            // 后一半
            for (int i = 1; i <= size / 2; i++) {
                TreeNode node = queue.remove();
                // 两个都为 null
                if (node == null && arr[size / 2 - i] == null) {
                    continue;
                }
                // 其中一个为 null
                if (node == null || arr[size / 2 - i] == null) {
                    return false;
                }
                // 两个都不为 null 判断值是否相等
                if (node.val != arr[size / 2 - i].val) {
                    return false;
                }
                queue.add(node.left);
                queue.add(node.right);
            }
        }
        return true;
    }
}
```

##### 迭代

```java
// 模式识别 广度周游(队列)
// 迭代
// 本来想觉得使用双端队列也行, 但是发现判断的逻辑逻辑可以实现, 但是添加进 queue 的顺序不对
// 于是, 想起刚才看了一眼的那个迭代代码, 但是没有看解释, 发现原来是这样的思维过程
// 现在我该想想怎么从迭代转换到递归
class P101_solution1 {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root.left);
        queue.add(root.right);
        while (!queue.isEmpty()) {
            TreeNode first = queue.remove();
            TreeNode second = queue.remove();
            // 两个都为 null
            if (first == null && second == null) {
                continue;
            }
            // 其中一个为 null
            if (first == null || second == null) {
                return false;
            }
            // 两个都不为 null 判断值是否相等
            if (first.val != second.val) {
                return false;
            }
            // 每两个对称的结点, 要判断一个结点的子结点与另一个结点的子结点是否对称
            // 只需要将两个要判断的子结点按照相应顺序添加进 queue 即可
            // 要判断 first.left 与 second.right 是否对称, 将其加入 queue
            queue.add(first.left);
            queue.add(second.right);

            // 要判断 first.right 与 second.left 是否对称, 将其加入 queue
            queue.add(first.right);
            queue.add(second.left);
        }
        return true;
    }
}
```

##### 递归（最优解法）

```java
// 模式识别 深度周游(递归) (最优解法)
class P101_solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return checkTowNode(root.left, root.right);
    }

    private boolean checkTowNode(TreeNode first, TreeNode second) {
        // 两个都为 null
        if (first == null && second == null) {
            return true;
        }
        // 其中一个为 null
        if (first == null || second == null) {
            return false;
        }
        // 两个都不为 null 判断值是否相等
        if (first.val != second.val) {
            return false;
        }

        // 两颗小子树是否轴对称
        return checkTowNode(first.left, second.right) && checkTowNode(first.right, second.left);
    }
}
```



#### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

##### 广度优先搜索（队列实现、层序遍历）

```java
// 我的解法, 与官方解法的遍历思路不同, 但本质还是一样的
// 我的解法是根据左右, 每次遍历的时候, 遍历结点左右顺序会有所不同, 添加到队列中时, 会选择是添加到队列尾还是队列首, 添加到 ans 中时都是添加到末尾;
// 而官方解法是在每次遍历的时候, 都是先左后右遍历, 添加到队列中时, 也是只添加到队列尾, 添加元素到 ans 中时, 会根据是奇偶层, 会选择是添加到头还是尾
class P103_Solution {
    public List<List<Integer>> zigzagLevelOrder1(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        // index 表示当前该层二叉树应当添加在 ans 的那个链表上, while 循环结束后的 index 值为 ans 的长度
        // 也表示 二叉树的深度, 遍历二叉树的层数, 遍历队列的层数
        int index = -1;
        ans.add(new ArrayList<>());
        // 根结点 root 添加在第一个链表上, 链表下标为 0
        index++;
        ans.get(index).add(root.val);
        // 提前结束, 可删除, 后续 while 中也会有等价的判断
        if (root.left == null && root.right == null) {
            return ans;
        }
        // 根据 flag 的值的不同, 出队位置不同、遍历左右子结点顺序不同、将左右子结点添加到队列 deque 的首还是尾也有不同
        // flag 为 false 时, 从 deque 的 [队列首] 出队结点 node, 先遍历 右结点, 后遍历 左结点, 各子结点添加到 deque 的 [队列尾]
        // flag 为 true 时, 从 deque 的 [队列尾] 出队结点 node, 先遍历 左结点, 后遍历 右结点, 各子结点添加到 deque 的 [队列首]
        boolean flag = false;
        Deque<TreeNode> deque = new LinkedList<>();
        // 初始时 根结点 root 入队
        deque.add(root);
        int size;
        while (!deque.isEmpty()) {
            // 每次在添加一层结点(已在 deque 和 ans 中)的子结点(马上要遍历添加到 deque 和 ans 中)时, 都要提前创建这个要添加到的链表
            ans.add(new ArrayList<>());
            // 链表的下标索引
            index++;
            // 队列长度, 该层结点数, 出队结点数
            size = deque.size();
            for (int i = 0; i < size; i++) {
                if (!flag) {
                    // [队列首] 出队结点 node
                    TreeNode node = deque.remove();
                    // 先遍历 右结点
                    if (node.right != null) {
                        // 添加到 [队列尾]
                        deque.add(node.right);
                        ans.get(index).add(node.right.val);
                    }
                    // 后遍历 左结点
                    if (node.left != null) {
                        // 添加到 [队列尾]
                        deque.add(node.left);
                        ans.get(index).add(node.left.val);
                    }
                } else {
                    // [队列尾] 出队结点 node
                    TreeNode node = deque.removeLast();
                    // 先遍历 左结点
                    if (node.left != null) {
                        // 添加到 [队列首]
                        deque.addFirst(node.left);
                        ans.get(index).add(node.left.val);
                    }
                    // 后遍历 右结点
                    if (node.right != null) {
                        // 添加到 [队列首]
                        deque.addFirst(node.right);
                        ans.get(index).add(node.right.val);
                    }
                }
            }
            // 该层结点遍历结束, 变换方向
            flag = !flag;
        }
        // 当最后一层结点添加到 deque 以及 ans 后, 此时 deque 不为空, 那么就还会再次遍历这最后一层结点, 寻找它的子结点, 但是这显然是不可能实现的
        // 于是就多执行了一次 ans.add(new ArrayList<>()); 于是要在返回结果前将最后这个空 list 移除
        ans.remove(index);
        return ans;
    }

    // 小修改, 基本思路逻辑不变, 测试用例上无性能提升
    // 修改 int index 为 List<Integer> list
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        ans.add(new ArrayList<>());
        // 根结点 root 添加在第一个链表上
        ans.get(0).add(root.val);
        // 提前结束, 可删除, 后续 while 中也会有等价的判断
        if (root.left == null && root.right == null) {
            return ans;
        }
        // 根据 flag 的值的不同, 出队位置不同、遍历左右子结点顺序不同、将左右子结点添加到队列 deque 的首还是尾也有不同
        // flag 为 false 时, 从 deque 的 [队列首] 出队结点 node, 先遍历 右结点, 后遍历 左结点, 各子结点添加到 deque 的 [队列尾]
        // flag 为 true 时, 从 deque 的 [队列尾] 出队结点 node, 先遍历 左结点, 后遍历 右结点, 各子结点添加到 deque 的 [队列首]
        boolean flag = false;
        Deque<TreeNode> deque = new LinkedList<>();
        // 初始时 根结点 root 入队
        deque.add(root);
        int size;
        while (!deque.isEmpty()) {
            // 每次在添加一层结点(已在 deque 和 ans 中)的子结点(马上要遍历添加到 deque 和 ans 中)时, 都要提前创建这个要添加到的链表
            List<Integer> list = new ArrayList<>();
            ans.add(list);
            // 队列长度, 该层结点数, 出队结点数
            size = deque.size();
            for (int i = 0; i < size; i++) {
                if (!flag) {
                    // [队列首] 出队结点 node
                    TreeNode node = deque.remove();
                    // 先遍历 右结点
                    if (node.right != null) {
                        // 添加到 [队列尾]
                        deque.add(node.right);
                        list.add(node.right.val);
                    }
                    // 后遍历 左结点
                    if (node.left != null) {
                        // 添加到 [队列尾]
                        deque.add(node.left);
                        list.add(node.left.val);
                    }
                } else {
                    // [队列尾] 出队结点 node
                    TreeNode node = deque.removeLast();
                    // 先遍历 左结点
                    if (node.left != null) {
                        // 添加到 [队列首]
                        deque.addFirst(node.left);
                        list.add(node.left.val);
                    }
                    // 后遍历 右结点
                    if (node.right != null) {
                        // 添加到 [队列首]
                        deque.addFirst(node.right);
                        list.add(node.right.val);
                    }
                }
            }
            // 该层结点遍历结束, 变换方向
            flag = !flag;
        }
        // 当最后一层结点添加到 deque 以及 ans 后, 此时 deque 不为空, 那么就还会再次遍历这最后一层结点, 寻找它的子结点, 但是这显然是不可能实现的
        // 于是就多执行了一次 ans.add(new ArrayList<>()); 于是要在返回结果前将最后这个空 list 移除
        ans.remove(ans.size() - 1);
        return ans;
    }
}
```



#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

class P104_Solution {
    // DFS
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else if (root.left == null && root.right == null) {
            return 1;
        }
        int leftDepth = 0;
        int rightDepth = 0;
        // 左子树的深度
        if (root.left != null) {
            leftDepth = maxDepth(root.left);
        }
        // 右子树的深度
        if (root.right != null) {
            rightDepth = maxDepth(root.right);
        }
        return Math.max(leftDepth, rightDepth) + 1;
    }

    // DFS 对上方法的逻辑简化
    public int maxDepth1(TreeNode root) {
        if (root == null) {
            return 0;
        } else if (root.left == null && root.right == null) {
            return 1;
        }
        return Math.max(maxDepth1(root.left), maxDepth1(root.right)) + 1;
    }
}
```



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 必须放在这里，后续两方法中都要使用到这个属性
    // 使用k,v记录中序遍历数组中各节点值与其索引值,通过前序遍历中的第一个值就为头节点,然后在该map中找到对应中序遍历数组中的该值的下标
    private Map<Integer, Integer> indexMap = null;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;

        indexMap = new HashMap<Integer, Integer>();

        for(int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int pre_left, int pre_right, int in_left, int in_right) {
        // 一个左右子树对应的那部分数组长度大于等于1时才有节点,只有一个节点的情况是pre_left等于pre_right,那么没有节点的情况是pre_left>pre_right
        if (pre_left > pre_right) {
            return null;
        }
        // 前序遍历中第一个结点为根节点,保存其值
        int rootValPre = preorder[pre_left];
        // 中序遍历得到根节点所在位置索引值
        int rootIndexIn = indexMap.get(rootValPre);
        // 构造根节点
        TreeNode rootNode = new TreeNode(rootValPre);
        // 统计左子树中有多少个节点
        int left_size = rootIndexIn - in_left;
        // 递归遍历左子树,得到左节点
        rootNode.left = myBuildTree(preorder, inorder, pre_left + 1, pre_left + left_size, in_left, rootIndexIn - 1);
        // 递归遍历右子树,得到右节点
        rootNode.right = myBuildTree(preorder, inorder, pre_left + left_size + 1, pre_right, rootIndexIn + 1, in_right);
        return rootNode;
    }
}
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private Map<Integer, Integer> indexMap = null;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;

        indexMap = new HashMap<Integer,Integer>();

        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        return myBuildTree(inorder, postorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] inorder, int[] postorder, int in_left, int in_right, int post_left, int post_right) {

        if (post_left > post_right) {
            return null;
        }
        // 获取后序遍历中最后一位的值,即为根节点
        int rootVal = postorder[post_right];
        // 在中序遍历MAP中找到相应rootVal所在中序遍历数组中的索引位置
        int rootIndexIn = indexMap.get(rootVal);
        // 构造根节点
        TreeNode rootNode = new TreeNode(rootVal);
        // 计算左子树长度
        int left_size = rootIndexIn - in_left;
        // 递归遍历左子树,得到左节点
        rootNode.left = myBuildTree(inorder, postorder, in_left, rootIndexIn - 1, post_left, post_left + left_size - 1);
        // 递归遍历右子树,得到右节点
        rootNode.right = myBuildTree(inorder, postorder, rootIndexIn + 1, in_right, post_left + left_size, post_right - 1);
        return rootNode;
    }
}
```



#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

已定义节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
```

##### 2021.04.26

我的做法（第一种）

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return Order(root, targetSum);
    }
    
    public boolean Order(TreeNode node, int pathSum) {
        if (node == null) {
            return false;
        }
        
        pathSum = pathSum - node.val;
        boolean leftRet = false;
        boolean rightRet = false;
        
        if (node.left == null && node.right == null) {
            if(pathSum == 0) {
                return true;
            }
        }
        if (node.left != null) {
            leftRet = Order(node.left, pathSum);
        }
        if (node.right != null) {
            rightRet = Order(node.right, pathSum);
        }
        
        return leftRet || rightRet;
    }
}
```

我的方法（第二种）较第一种小改，无本质变化

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return Order(root, targetSum);
    }
    
    public boolean Order(TreeNode node, int pathSum) {
        if (node == null) {
            return false;
        }
        
        pathSum = pathSum - node.val;
        
        if (node.left == null && node.right == null) {
            if(pathSum == 0) {
                return true;
            }
        }
        
        return Order(node.left, pathSum) || Order(node.right, pathSum);
    }
}
```

##### 2021.10.22——第二次做——独立完成

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

class P112_Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }
        targetSum = targetSum - root.val;
        if (root.left != null) {
            if (hasPathSum(root.left, targetSum)) {
                return true;
            }
        }
        if (root.right != null) {
            return hasPathSum(root.right, targetSum);
        }
        return false;
    }

    // 对上一个方法的简化, 发现和官方解法一样了
    public boolean hasPathSum1(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```



官方做法（递归）

思路及算法

观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。
>
> 空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(log N)。

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

**给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。**

**叶子节点 是指没有子节点的节点。**

前言
注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。

方法一：深度优先搜索
思路及算法

我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

```Java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    Deque<Integer> path = new LinkedList<Integer>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }

    public void dfs(TreeNode root, int sum) {
        if (root == null) {
            return;
        }
        path.offerLast(root.val);
        sum -= root.val;
        if (root.left == null && root.right == null && sum == 0) {
            ret.add(new LinkedList<Integer>(path));
        }
        dfs(root.left, sum);
        dfs(root.right, sum);
        path.pollLast();
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为 O(N)，并且每一条路径的节点个数也为 O(N)，因此要将这些路径全部添加进答案中，时间复杂度为 O(N^2)。
>
> 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。

方法二：广度优先搜索
思路及算法

我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。

```java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    Map<TreeNode, TreeNode> map = new HashMap<TreeNode, TreeNode>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queueNode = new LinkedList<TreeNode>();
        Queue<Integer> queueSum = new LinkedList<Integer>();
        queueNode.offer(root);
        queueSum.offer(0);

        while (!queueNode.isEmpty()) {
            TreeNode node = queueNode.poll();
            int rec = queueSum.poll() + node.val;

            if (node.left == null && node.right == null) {
                if (rec == targetSum) {
                    getPath(node);
                }
            } else {
                if (node.left != null) {
                    map.put(node.left, node);
                    queueNode.offer(node.left);
                    queueSum.offer(rec);
                }
                if (node.right != null) {
                    map.put(node.right, node);
                    queueNode.offer(node.right);
                    queueSum.offer(rec);
                }
            }
        }

        return ret;
    }

    public void getPath(TreeNode node) {
        List<Integer> temp = new LinkedList<Integer>();
        while (node != null) {
            temp.add(node.val);
            node = map.get(node);
        }
        Collections.reverse(temp);
        ret.add(new LinkedList<Integer>(temp));
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，其中 N 是树的节点数。分析思路与方法一相同。
>
> 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数。

##### 2021.10.23

第一次做，没做出来，这是答案DFS的解法

```java
class P113_Solution {
    List<List<Integer>> ans = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return ans;
    }

    public void dfs(TreeNode root, int targetSum) {
        if (root == null) {
            return;
        }
        path.offerLast(root.val);
        targetSum = targetSum - root.val;
        if (root.left == null && root.right == null && targetSum == 0) {
            ans.add(new LinkedList<Integer>(path));
        }
        dfs(root.left, targetSum);
        dfs(root.right, targetSum);
        path.pollLast();
    }
}
```



#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

###### 方法一：**线性表**

因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。

因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        List<ListNode> list = new ArrayList<ListNode>();
        ListNode node = head;
        while (node != null) {
            list.add(node);
            node = node.next;
        }
        int i = 0, j = list.size() - 1;
        while (i < j) {
            list.get(i).next = list.get(j);
            i++;
            if (i == j) {
                break;
            }
            list.get(j).next = list.get(i);
            j--;
        }
        list.get(i).next = null;
    }
}
```

> **复杂度分析**
>
> 时间复杂度：O(N)*O*(*N*)，其中 N*N* 是链表中的节点数。
>
> 空间复杂度：O(N)*O*(*N*)，其中 N*N* 是链表中的节点数。主要为线性表的开销。

###### 方法二：寻找链表中点 + 链表逆序 + 合并链表

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1.找到原链表的中点（参考「876. 链表的中间结点」）。

​	我们可以使用快慢指针来 O(N) 地找到链表的中间节点。
2.将原链表的右半端反转（参考「206. 反转链表」）。

​	我们可以使用迭代法实现链表的反转。
3.将原链表的两端合并。

​	因为两链表长度相差不超过1，因此直接合并即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    public void mergeList(ListNode l1, ListNode l2) {
        ListNode l1_tmp;
        ListNode l2_tmp;
        while (l1 != null && l2 != null) {
            l1_tmp = l1.next;
            l2_tmp = l2.next;

            l1.next = l2;
            l1 = l1_tmp;

            l2.next = l1;
            l2 = l2_tmp;
        }
    }
}
```

> **复杂度分析**
>
> 时间复杂度：O(N)，其中 N是链表中的节点数。
>
> 空间复杂度：O(1)。

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

##### 暴力解法

> 见官网

##### 动态规划

```java
// 动态规划
class P121_Solution {
    // 动态规划
    // 时间复杂度 O(n)
    // 空间复杂度 O(n)
    // 无注释, 最初版本, dp 定义为 int[] dp = new int[n + 1];
    public int maxProfit0(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }

        int minPriceIndex = 0;
        int[] dp = new int[n + 1];

        for (int i = 1; i < n + 1; i++) {
            if (prices[i - 1] > prices[minPriceIndex]) {
                dp[i] = Math.max(prices[i - 1] - prices[minPriceIndex], dp[i - 1]);
            } else {
                dp[i] = dp[i - 1];
                minPriceIndex = i - 1;
            }
        }
        return dp[n];
    }

    // 动态规划
    // 时间复杂度 O(n)
    // 空间复杂度 O(n)
    // 有注释, 第二个版本, dp 定义为 int[] dp = new int[n];
    public int maxProfit1(int[] prices) {
        // 特殊情况处理
        if (prices == null) {
            return 0;
        }
        // 天数
        int n = prices.length;
        // 特殊情况处理
        if (n == 0 || n == 1) {
            return 0;
        }

        int[] dp = new int[n];

        // 价格最小的天数索引
        int minPriceIndex = 0;
        for (int i = 1; i < n; i++) {
            // 如果第 i 天比之前的所有天中的最低价格高
            // 那么dp[i]等于, 在今天选择卖出股票或者不卖出股票就可能取得到这前 i 天能卖出的最大值
            // 卖出股票——利润为 prices[i] - prices[minPriceIndex]
            // 不卖股票——利润为前一天的 dp 值 dp[i-1]
            if (prices[i] > prices[minPriceIndex]) {
                dp[i] = Math.max(prices[i] - prices[minPriceIndex], dp[i - 1]);
            } else {
                // 如果今天的股票价格是历史最低的话, 可以认为如果在今天买入, 在日后某天卖出的话, 也许会得到更高的利润
                // 而由于今天的股票价格是历史最低, 那么截至到今天, 今天能赚到的最大利润为前 i 天能卖出的最大值, 也就是 dp[i-1]
                dp[i] = dp[i - 1];
                // 更新最小价格的索引位置
                minPriceIndex = i;
            }
        }
        return dp[n - 1];
    }

    // 动态规划(滚动数组思想)
    // 时间复杂度 O(n)
    // 空间复杂度 O(1)
    // 优化版本, dp 定义为 int[] dp = new int[2];
    public int maxProfit(int[] prices) {
        // 特殊情况处理
        if (prices == null) {
            return 0;
        }
        // 天数
        int n = prices.length;
        // 特殊情况处理
        if (n == 0 || n == 1) {
            return 0;
        }

        // 最大利润
        int dp = 0;

        // 价格最小的天数索引, 可把这个最小价格索引改为直接保存最小价格值 minPrice
        int minPriceIndex = 0;
        for (int i = 1; i < n; i++) {
            // 如果第 i 天比之前的所有天中的最低价格高
            // 那么dp[i]等于, 在今天选择卖出股票或者不卖出股票就可能取得到这前 i 天能卖出的最大值
            // 卖出股票——利润为 prices[i] - prices[minPriceIndex]
            // 不卖股票——利润为前一天的 dp 值, 就为 dp 本身
            if (prices[i] > prices[minPriceIndex]) {
                dp = Math.max(prices[i] - prices[minPriceIndex], dp);
            } else {
                // 如果今天的股票价格是历史最低的话, 可以认为如果在今天买入, 在日后某天卖出的话, 也许会得到更高的利润
                // 而由于今天的股票价格是历史最低, 那么截至到今天, 今天能赚到的最大利润为前 i 天能卖出的最大值, 也就是 dp 值, 不需要更新了
                // 更新最小价格的索引位置
                minPriceIndex = i;
            }
        }
        return dp;
    }
}
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

##### 动态规划

```java
class P122_Solution {
    // 动态规划
    // 时间复杂度 O(n)
    // 空间复杂度 O(n)
    public int maxProfit1(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }
        int[] dp = new int[n];

        /* 第一种方式, 每天与前几天中的最低历史价格相关, 代码实现上已经有些不像动态规划了 */
//        int minPriceIndex = 0;
//        for (int i = 1; i < n; i++) {
//            if (prices[i] > prices[i - 1]) {
//                dp[i] = dp[minPriceIndex] + (prices[i] - prices[minPriceIndex]);
//            } else {
//                dp[i] = dp[i - 1];
//                minPriceIndex = i;
//            }
//        }
//        return dp[n - 1];

        /* 第二种方式, 每天与前一天的价格相关, 而不是与前几天中的最低历史价格相关 */
        for (int i = 1; i < n; i++) {
            // 如果今天比前一天的价格高, 在答案结果上就等于
            // 昨天以前(包括昨天)总共获得的利润 dp[i - 1] + 昨天买的、今天卖了的差价(prices[i] - prices[i - 1])
            if (prices[i] > prices[i - 1]) {
                dp[i] = dp[i - 1] + (prices[i] - prices[i - 1]);
            } else {
                // 如果今天比前一天低, 那么今天肯定是不卖的, 有可能买,
                // 但是具体买不买要根据后一天的价格是否比今天高来决定,
                // 如果明天的价格比今天的高, 那么当然是今天要买, 明天再卖就能获利了
                // 如果明天的价格比今天的低, 那么今天就不要买, 应该在明天再买
                // 因此, 今天不卖的话, 就意味着今天不获利, 到今天为止转的钱 dp[i] 之就等于昨天赚的钱 dp[i-1]
                dp[i] = dp[i - 1];
            }
        }
        return dp[n - 1];
    }

    // 动态规划(优化 滚动数组思想)
    // 时间复杂度 O(n)
    // 空间复杂度 O(1)
    public int maxProfit(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }

        // 由上一个动态规划实现, 我们知道由于截止到今天的获利 dp[i] 只和截止到前一天的获利 dp [i-1] 有关
        // 于是 dp 数组可以进行压缩滚动, 不必用一个 O(n) 长度的数组记录截至到每天的获利情况, 只需要一个变量即可
        // int[] dp = new int[n]; 改为
        int dp = 0;

        /* 第二种方式, 每天与前一天的价格相关, 而不是与前几天中的最低历史价格相关 */
        for (int i = 1; i < n; i++) {
            // 如果今天比前一天的价格高, 在答案结果上就等于
            // 昨天以前(包括昨天)总共获得的利润 dp[i - 1] + 昨天买的、今天卖了的差价(prices[i] - prices[i - 1])
            if (prices[i] > prices[i - 1]) {
                // dp[i] = dp[i - 1] + (prices[i] - prices[i - 1]); 改为
                dp += prices[i] - prices[i - 1];
            }/* else {
                // 如果今天比前一天低, 那么今天肯定是不卖的, 有可能买,
                // 但是具体买不买要根据后一天的价格是否比今天高来决定,
                // 如果明天的价格比今天的高, 那么当然是今天要买, 明天再卖就能获利了
                // 如果明天的价格比今天的低, 那么今天就不要买, 应该在明天再买
                // 因此, 今天不卖的话, 就意味着今天不获利, 到今天为止转的钱 dp[i] 之就等于昨天赚的钱 dp[i-1]
                // dp[i] = dp[i - 1];
            }*/
        }

        // return dp[n - 1]; 改为
        return dp;
    }
    // 做完看了答案后才知道, 原来官方将我的这种动态规划做法, 认为是贪心算法
    // 并且解释中: 贪心算法只能用于计算最大利润, 计算的过程并不是实际的交易过程。
    // 这个和我的想法一致
}
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

##### 动态规划

我的代码，效率很低，不过做出来就不错了哈哈，更多注释见源文件

```java
// 动态规划
class P123_Solution {
    public int maxProfit(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int n = prices.length;
        if (n == 0 || n == 1) {
            return 0;
        }

        // dp[i][0] 买卖一次的最大利润
        // dp[i][1] 买卖两次的最大利润
        int[][] dp = new int[n][2];
        int index = 0;
        int minPriceIndex = 0;
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 1; i < n; i++) {
            if (prices[i] > prices[i - 1]) {
                dp[i][0] = Math.max(prices[i] - prices[minPriceIndex], dp[i - 1][0]);

                dp[i][1] = Math.max(prices[i] - prices[index] + dp[index][0], dp[i - 1][1]);
                for (Integer ind : hashSet) {
                    dp[i][1] = Math.max(prices[i] - prices[ind] + dp[ind][0], dp[i][1]);
                }
            } else {
                // prices[i] <= prices[i - 1]
                dp[i][0] = dp[i - 1][0];
                dp[i][1] = dp[i - 1][1];

                // 此处 prices[minPriceIndex] <= prices[index] 是恒定的, minPriceIndex 与 index 也可能相等
                // 如果 prices[i] == prices[index], 只需执行 index = i;
                if (prices[i] > prices[index]) {
                    // 将 index 加入 hashSet
                    hashSet.add(index);
                } else if (prices[i] < prices[index]) {
                    if (prices[i] <= prices[minPriceIndex]) {
                        // prices[i] 为最低价格, 更新最低价格下标, set 清空, minPriceIndex 入 set
                        // 最低价格下标
                        minPriceIndex = i;
                        // 清空 hashSet
                        hashSet.clear();
                        // 将 minPriceIndex 加入 hashSet
                        hashSet.add(minPriceIndex);
                    } else {
                        // prices[index] > prices[i] > prices[minPriceIndex]
                        // 需要将 hashSet 中比 prices[i] 大的 prices[ind] 的 ind 移除

                        // 这种方式在 LeetCode 上会报如下错误
                        // java.util.ConcurrentModificationException
                        //  at line 1495, java.base/java.util.HashMap$HashIterator.nextNode
                        //  at line 1518, java.base/java.util.HashMap$KeyIterator.next
//                        for (Integer ind : hashSet) {
//                            if (prices[ind] >= prices[i]) {
//                                hashSet.remove(ind);
//                            }
//                        }
                        // 改为迭代器就可以了, 这是一个新知识点啊哈哈
                        Iterator<Integer> iterator = hashSet.iterator();
                        while (iterator.hasNext()) {
                            if (prices[iterator.next()] >= prices[i]) {
                                iterator.remove();
                            }
                        }
                    }
                }
                index = i;
            }
        }
        return dp[n - 1][1];
    }
}
```



#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class P124_Solution {
    // 此处初始化为小于 -1000 的值
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        /*
        // 题目保证至少一个结点, 即 root != null
        if (root == null) {
            return 0;
        }*/
        postorder(root);
        return maxSum;
    }

    // 后序遍历
    public int postorder1(TreeNode node) {
        int leftSum;
        int rightSum;
        int maxLeftAndRight;
        int nodePathSum;

        if (node.left == null && node.right == null) {
            nodePathSum = node.val;
            maxSum = Math.max(nodePathSum, maxSum);
        } else if (node.left != null && node.right != null) {
            leftSum = postorder(node.left);
            rightSum = postorder(node.right);
            maxLeftAndRight = Math.max(leftSum, rightSum);
            nodePathSum = Math.max(maxLeftAndRight + node.val, node.val);
            maxSum = Math.max(Math.max(nodePathSum, leftSum + node.val + rightSum), maxSum);
        } else if (node.left != null) {
            // 此处 node.left != null && node.right == null
            leftSum = postorder(node.left);
            nodePathSum = Math.max(leftSum + node.val, node.val);
            maxSum = Math.max(nodePathSum, maxSum);
        } else {
            // 此处 node.left == null && node.right != null
            rightSum = postorder(node.right);
            nodePathSum = Math.max(rightSum + node.val, node.val);
            maxSum = Math.max(nodePathSum, maxSum);
        }

        return nodePathSum;
    }

    // 后续遍历
    // 对上一个种代码实现的优化, 解题思想不变
    public int postorder(TreeNode node) {
        int leftSum = 0;
        int rightSum = 0;
        // 返回值, 通过该 node 结点到子结点的路径中的最大路径和
        int nodePathSum;

        if (node.left == null && node.right == null) {
            // node 为叶子结点, 无左右子结点
            nodePathSum = node.val;
            maxSum = Math.max(nodePathSum, maxSum);
        } else {
            if (node.left != null) {
                leftSum = postorder(node.left);
            }
            if (node.right != null) {
                rightSum = postorder(node.right);
            }
            // 此处 nodePathSum 为 以下三种情况中的较大值
            // leftSum + node.val、rightSum + node.val 和 node.val

            // 以下两种方式求 nodePathSum
            // 1.
            // 左、右较大值
            // int maxLeftAndRight = Math.max(leftSum, rightSum);
            // nodePathSum = maxLeftAndRight >= 0 ? maxLeftAndRight + node.val : node.val;
            // 2.
            nodePathSum = Math.max(Math.max(leftSum, rightSum) + node.val, node.val);

            // 此处 maxSum 为 以下三种情况中的较大值
            // nodePathSum、leftSum + node.val + rightSum 和 历史 maxSum 值
            // 总计下来其实 maxSum 为 历史 maxSum 值 与
            // [leftSum + node.val、 rightSum + node.val、 node.val、 leftSum + node.val + rightSum]
            // 这四个值中的最大值
            maxSum = Math.max(Math.max(nodePathSum, leftSum + node.val + rightSum), maxSum);
        }
        return nodePathSum;
    }
}
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

##### 递归

```java
// 递归实现
class P145_Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {
        // 特殊情况提前处理
        // 可删
        if (root == null) {
            return ans;
        }
        postorder(root);
        return ans;
    }

    public void postorder(TreeNode node) {
        if (node == null) {
            return;
        }
        // 遍历左结点
        postorder(node.left);
        // 遍历右节点
        postorder(node.right);
        // 添加该结点入链表
        ans.add(node.val);
    }
}
```

##### 迭代

```java
// 迭代
class P145_Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> ans = new LinkedList<>();
        // 特殊情况提前处理
        if (root == null) {
            return ans;
        }

        Deque<TreeNode> stack = new LinkedList<>();

        while (root != null || !stack.isEmpty()) {
            // 一直遍历右结点
            if (root != null) {
                // 每遇到一个结点, 就把它加入结果集, 并把该节点保存到中间结果中
                // 每次前序遍历时, 都将结点写入结果链表头, 而不是尾
                ans.addFirst(root.val);
                stack.push(root);
                // 每次先遍历右结点, 走到空, 再遍历左结点
                root = root.right;
            } else {
                // 右子树走到空, 就从获取已经遍历过右子树的中间结果, 将它出栈, 并遍历它的左子树
                root = stack.poll();
                root = root.left;
            }
        }
        return ans;
    }
}
```



#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

第一次

```java
// 使用 哈希表 + 双向链表
// 时间复杂度：对于 put 和 get 都是 O(1)O(1)。
// 空间复杂度：O(\text{capacity})O(capacity)，因为哈希表和双向链表最多存储 \text{capacity} + 1capacity+1 个元素。
class LRUCache {

    static class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;

        public DLinkedNode() {
        }

        public DLinkedNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final Map<Integer, DLinkedNode> cache = new HashMap<>();
    private int size;
    private final int capacity;
    private final DLinkedNode head;
    private final DLinkedNode tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 新节点添加到双向链表的头部
            addToHead(newNode);
            size++;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tailNode = tail.prev;
                removeNode(tailNode);
                // 删除哈希表中对应的项
                cache.remove(tailNode.key);
                size--;
            }
        } else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
}
```





#### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class P147_Solution {
    // 从前往后找插入点
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;
        head.next = null;
        // 表示最终找到插入位置时的后一个结点
        ListNode cur;
        ListNode temp;
        // 每次插入一个结点, 都从头遍历到合适位置
        while (node != null) {
            temp = node.next;
            // 表示最终找到插入位置时的前一个结点
            ListNode prev = new ListNode();
            prev.next = head;
            cur = head;
            while (cur != null && cur.val < node.val) {
                prev = cur;
                cur = cur.next;
            }
            // 退出 while 时要么是该 node.val 为已排链表的最大值(cur == null), 添加在末尾
            // 要么 不是最大值, 添加在中间某处(prev 与 cur 之间, cur 不为 null)
            if (cur == null) {
                prev.next = node;
                node.next = null;
            } else {
                node.next = cur;
                prev.next = node;
                // 如果 node.val 的值比头结点的值小, 需要将该 node 结点设为头结点
                if (cur == head) {
                    head = node;
                }
            }
            node = temp;
        }
        return head;
    }

    // 从前往后找插入点, 对上一个方法的代码逻辑简化
    public ListNode insertionSortList1(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;
        head.next = null;
        // 表示最终找到插入位置时的后一个结点
        ListNode cur;
        ListNode temp;
        // 每次插入一个结点, 都从头遍历到合适位置
        while (node != null) {
            temp = node.next;
            // 表示最终找到插入位置时的前一个结点
            ListNode prev = new ListNode();
            prev.next = head;
            cur = head;
            while (cur != null && cur.val < node.val) {
                prev = cur;
                cur = cur.next;
            }
            // 退出 while 时要么是该 node.val 为已排链表的最大值(cur == null), 添加在末尾
            // 要么 不是最大值, 添加在中间某处(prev 与 cur 之间, cur 不为 null)
            node.next = cur;
            prev.next = node;
            // 如果 node.val 的值比头结点的值小, 需要将该 node 结点设为头结点
            if (cur == head) {
                head = node;
            }
            node = temp;
        }
        return head;
    }
}
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

```java
// 模仿着 P123_买卖股票的最佳时机III 做, 一次通过哈哈哈
class P188_Solution {
    // dp 数组定义为 dp[k * 2] 大小
    public int maxProfit1(int k, int[] prices) {
        if (prices == null || k == 0) {
            return 0;
        }
        int n = prices.length;
        if (n <= 1) {
            return 0;
        }

        // 因为 n 天最多只能进行 n/2 笔交易, 因此我们可以将 k 对 n/2 取较小值之后再进行动态规划
        k = Math.min(k, n / 2);
        // count == k * 2;
        // k 为交易次数, count 为总买卖次数, 交易次数的两倍
        final int count = k * 2;
        // dp 数组
        int[] dp = new int[count];
        // 赋初值
        for (int i = 0; i < count; i += 2) {
            dp[i] = -prices[0];
            dp[i + 1] = 0;
        }
        // 动态规划
        // 第 i 天时, 第 j 次买和卖的最大利润
        for (int i = 1; i < n; i++) {
            // 第 i 天第 1 次买获得的最大利润
            dp[0] = Math.max(dp[0], -prices[i]);
            // 第 i 天第 1 次卖获得的最大利润
            dp[1] = Math.max(dp[1], dp[0] + prices[i]);
            for (int j = 2; j < count; j += 2) {
                // 第 i 天第 j 次买获得的最大利润 为
                // (第 i-1 天第 j 次买) 与 (第 j-1 次卖 - 第 i 天第 j 次买的这只股票的价格(prices[i])) 中的较大值
                dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);
                // 第 i 天第 j 次卖获得的最大利润 为
                // (第 i-1 天第 j 次卖) 与 (第 j 次买 + 第 i 天第 j 次卖的这只股票的价格(prices[i])) 中的较大值
                dp[j + 1] = Math.max(dp[j + 1], dp[j] + prices[i]);
            }
        }
        return dp[count - 1];
    }

    // 将 dp 数组定义为 dp[k * 2] 大小, 确实复杂了好多, 改为两个 k 大小的数组要好很多
    // 这效率居然还没有上一个高？就挺意外的。难道是两个数组在赋值寻找索引位置时的查找时间更长？
    // 诶, 貌似今天(第二天)再看, 其实也差不多诶
    public int maxProfit(int k, int[] prices) {
        if (prices == null || k == 0) {
            return 0;
        }
        int n = prices.length;
        if (n <= 1) {
            return 0;
        }

        // 因为 n 天最多只能进行 n/2 笔交易, 因此我们可以将 k 对 n/2 取较小值之后再进行动态规划
        k = Math.min(k, n / 2);
        // dp 数组
        int[] buy = new int[k];
        int[] sell = new int[k];
        // 赋初值
        for (int i = 0; i < k; i++) {
            buy[i] = -prices[0];
            sell[i] = 0;
        }
        // 动态规划
        // 第 i 天时, 第 j 次买和卖的最大利润
        for (int i = 1; i < n; i++) {
            // 第 i 天第 1 次买获得的最大利润
            buy[0] = Math.max(buy[0], -prices[i]);
            // 第 i 天第 1 次卖获得的最大利润
            sell[0] = Math.max(sell[0], buy[0] + prices[i]);
            for (int j = 1; j < k; j++) {
                // 第 i 天第 j 次买获得的最大利润 为
                // (第 i-1 天第 j 次买) 与 (第 j-1 次卖 - 第 i 天第 j 次买的这只股票的价格(prices[i])) 中的较大值
                buy[j] = Math.max(buy[j], sell[j - 1] - prices[i]);
                // 第 i 天第 j 次卖获得的最大利润 为
                // (第 i-1 天第 j 次卖) 与 (第 j 次买 + 第 i 天第 j 次卖的这只股票的价格(prices[i])) 中的较大值
                sell[j] = Math.max(sell[j], buy[j] + prices[i]);
            }
        }
        return sell[k - 1];
    }
}
```



#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

##### 动态规划

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。
>
>
> - 空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。
>

```java
// 动态规划
class P198_Solution {
    // 动态规划
    // 时间复杂度：O(n)
    // 空间复杂度：O(n)
    public int rob1(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        // 此 if 也可删除
        if (n == 1) {
            // 如果只有一间房屋, 则偷窃该房屋, 可以偷窃到最高总金额
            return nums[0];
        } else if (n == 2) {
            // 如果只有两间房屋, 则由于两间房屋相邻, 不能同时偷窃, 只能偷窃其中的一间房屋
            // 因此选择其中金额较高的房屋进行偷窃, 可以偷窃到最高总金额
            return Math.max(nums[0], nums[1]);
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            // 偷窃第 i 间房屋，那么就不能偷窃第 i − 1 间房屋，偷窃总金额为前 i − 2 间房屋的最高总金额与第 i 间房屋的金额之和。
            // 不偷窃第 i 间房屋，偷窃总金额为前 i − 1 间房屋的最高总金额。
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }

    // 动态规划(滚动数组思想), 减小空间复杂度
    // 考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关
    // 因此可以使用滚动数组, 在每个时刻只需要存储前两间房屋的最高总金额
    // 时间复杂度：O(n)
    // 空间复杂度：O(1)
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        // 此 if 也可删除
        if (n == 1) {
            // 如果只有一间房屋, 则偷窃该房屋, 可以偷窃到最高总金额
            return nums[0];
        } else if (n == 2) {
            // 如果只有两间房屋, 则由于两间房屋相邻, 不能同时偷窃, 只能偷窃其中的一间房屋
            // 因此选择其中金额较高的房屋进行偷窃, 可以偷窃到最高总金额
            return Math.max(nums[0], nums[1]);
        }

        int[] dp = new int[3];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            // 偷窃第 i 间房屋, 那么就不能偷窃第 i − 1 间房屋，偷窃总金额为前 i − 2 间房屋的最高总金额与第 i 间房屋的金额之和
            // 不偷窃第 i 间房屋, 偷窃总金额为前 i − 1 间房屋的最高总金额
            dp[2] = Math.max(dp[1], dp[0] + nums[i]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 最后返回 dp[2] dp[1] 均可, 它俩值相等
        return dp[2];
    }
}
```



#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

##### 2021.11.01

###### 深度优先搜索 DFS

```java
// 使用 深度优先搜索
class P200_Solution {
    char[][] grid;

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        // numOfIslands 表示岛屿数量
        int numOfIslands = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                // 每进行一次深度优先搜索, 表示有一个岛屿
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    numOfIslands++;
                }
            }
        }
        return numOfIslands;
    }

    public void dfs(int i, int j) {
        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length) {
            if (grid[i][j] == '1') {
                // 每次遇到 '1' ,就将其改为 '2', 表示已经遍历了该陆地 '1'
                grid[i][j] = '2';
                // 按照"左上右下"的顺序遍历该陆地的相邻区域(方格)
                dfs(i, j - 1);
                dfs(i - 1, j);
                dfs(i, j + 1);
                dfs(i + 1, j);
            }
        }
    }
}
```

###### 广度优先搜索 BFS

```java
// 使用 广度优先搜索
class P200_Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        // numOfIslands 表示岛屿数量
        int numOfIslands = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 每进行一次广度优先搜索, 表示有一个岛屿
                if (grid[i][j] == '1') {
                    numOfIslands++;
                    // 每次遇到 '1' ,就将其改为 '2', 表示已经遍历了该陆地 '1'
                    grid[i][j] = '2';
                    // 创建一个队列用以保存该陆地及其相邻的陆地和相连的区域
                    Queue<Integer> neighbors = new LinkedList<>();
                    // 该陆地入队
                    neighbors.add(i * n + j);
                    int id, row, col;
                    // while 中出队一个已访问的陆地, 入队与其相邻的陆地, 直到队列为空
                    while (!neighbors.isEmpty()) {
                        id = neighbors.remove();
                        row = id / n;
                        col = id % n;
                        // 如果该陆地的周围(上下左右)有陆地, 将其添加进队列中, 标记为已访问 '2'
                        // 按照"左上右下"的顺序遍历该陆地的相邻区域(方格)
                        // 左
                        if (col - 1 >= 0 && grid[row][col - 1] == '1') {
                            // neighbors.add(row * n + col - 1);
                            // 与上等价
                            neighbors.add(id - 1);
                            grid[row][col - 1] = '2';
                        }
                        // 上
                        if (row - 1 >= 0 && grid[row - 1][col] == '1') {
                            // neighbors.add((row - 1) * n + col);
                            // 与上等价
                            neighbors.add(id - n);
                            grid[row - 1][col] = '2';
                        }
                        // 右
                        if (col + 1 < n && grid[row][col + 1] == '1') {
                            // neighbors.add(row * n + col + 1);
                            // 与上等价
                            neighbors.add(id + 1);
                            grid[row][col + 1] = '2';
                        }
                        // 下
                        if (row + 1 < m && grid[row + 1][col] == '1') {
                            // neighbors.add((row + 1) * n + col);
                            // 与上等价
                            neighbors.add(id + n);
                            grid[row + 1][col] = '2';
                        }
                    }
                }
            }
        }
        return numOfIslands;
    }
}
```

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

##### 拓扑排序（深度优先搜索 递归实现）

###### 第一种实现

> DFS 第一种实现，官方实现，使用` List<List<Integer>>` 构建邻接表

```java
// 拓扑排序(Topological sort)(DFS 递归实现)
// DFS 第一种实现, 官方实现, 使用 List<List<Integer>> 构建邻接表
class P207_Solution2 {
    // 使用 List<List<Integer>> adjList = new ArrayList<>(); 构造邻接表
    List<List<Integer>> adjList;
    // 记录遍历情况
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        adjList = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        visited = new int[numCourses];
        // 构建邻接表
        for (int[] edge : prerequisites) {
            adjList.get(edge[1]).add(edge[0]);
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                break;
            }
        }
        return valid;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;
        for (int next : adjList.get(i)) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next] == 0) {
                dfs(next);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
        }
        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
    }
}
```

###### 第二种实现（最优）

> DFS 第二种实现，创建 `CourseNode `节点，使用 `CourseNode[]` 构建邻接表
>
> 效率最高, 耗时最少, 但是消耗的内存更多一点

```java
// 拓扑排序(Topological sort)(DFS 递归实现)
// DFS 第二种实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 效率最高, 耗时最少, 但是消耗的内存更多一点
class P207_Solution {
    // 使用 CourseNode[] 构建邻接表
    CourseNode[] adjList;
    // 记录每个节点的状态: 0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        adjList = new CourseNode[numCourses];
        visited = new int[numCourses];

        // 构建邻接表
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                break;
            }
        }
        return valid;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;

        CourseNode next = adjList[i];
        while (next != null) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next.value] == 0) {
                dfs(next.value);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next.value] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
            next = next.next;
        }

        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
    }
}

class CourseNode {
    // value 为课程编号
    int value;
    CourseNode next;

    public CourseNode(int value) {
        this.value = value;
    }

    public CourseNode(int value, CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

##### 拓扑排序（广度优先搜索 队列实现）

```java
// 拓扑排序(Topological sort)(BFS 队列实现)
// BFS 我的实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 官方实现未做
class P207_Solution1 {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 各个节点的入度
        int[] inDegree = new int[numCourses];
        // 图的邻接表表示
        CourseNode[] adjList = new CourseNode[numCourses];
        // 一条有向边的起始节点与结束节点
        int from, to;
        // 构造图
        for (int[] edge : prerequisites) {
            // from 表示要先学的课程, 学完课程 from, 才能学 to
            from = edge[1];
            // to 表示要先学完课程 from, 才能学 to
            to = edge[0];
            // 更新 to 节点的入度, 一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // BFS
        // 将入度为 0 的所有节点入队, 有可能是非连通图
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 如果 queue 中一个入度为 0 的节点都没有, 表示图存在环, 并且整个图是一个大环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return false;
        }

        // bfsCount 表示 BFS 的次数, 同时也表示经过历次循环后, 入度为 0 的节点的个数, 学习了的课程数
        // 如果无环, 当循环结束时, bfsCount 应该等于节点总数 numCourses
        int bfsCount = 0;
        int cur;
        CourseNode next;
        while (!queue.isEmpty()) {
            // 出队一个入度为 0 的节点(无先修课程或已学完先修课程)
            cur = queue.remove();
            // 次数加 +1
            bfsCount++;
            // adjList[cur] 处存储的是 cur 能够到达的下一个节点 next
            // 即以 cur 为先修课程的每个课程 next
            next = adjList[cur];
            // 遍历所有以 cur 为先修课程的每个课程 next
            while (next != null) {
                // next 的入度 -1, 即学完了一门先修课程
                inDegree[next.value]--;
                // 为 0 时, 表示学完了所有的先修课程
                if (inDegree[next.value] == 0) {
                    // 那么此时就可以将这门课程加入队列
                    queue.add(next.value);
                }
                // 下一门以 cur 为先修课程的课程
                next = next.next;
            }
        }
        // 循环结束时, 如果 bfsCount == numCourses, 说明所有的课程都能学完(先学其先修课程), 也即图中无环
        // 如果不相等, 说明有些课程无法学习, 原因在于这几门课程互相之间以另一门课程为先修课程
        // 以数据结构的角度来看, 说明图中存在环
        return bfsCount == numCourses;
    }
}

class CourseNode {
    // value 为课程编号
    int value;
    CourseNode next;

    public CourseNode(int value) {
        this.value = value;
    }

    public CourseNode(int value, CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

#### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

##### Trie（前缀树、字典树）

```java
// Trie（前缀树、字典树）
class Trie {
    private boolean isEnd;
    private final Trie[] children;

    public Trie() {
        isEnd = false;
        children = new Trie[26];
    }

    public void insert(String word) {
        Trie node = this;
        int index;
        for (int i = 0; i < word.length(); i++) {
            index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        // 退出循环时, node 指向 word 中的最后一个字符, 标记它为结束字符
        // 表示这是一个完整单词
        node.isEnd = true;
    }

    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }

    // 若搜索到了前缀的末尾，就说明字典树中存在该前缀 此外。若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串
    public boolean startsWith(String prefix) {
        // 查找到前缀, 返回前缀最后一个字符结点
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        int index;
        for (int i = 0; i < prefix.length(); i++) {
            index = prefix.charAt(i) - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        // 退出循环时, node 指向 prefix 中的最后一个字符
        return node;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```



#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

##### 拓扑排序（深度优先搜索 递归实现）

###### 第一种实现

> DFS 第一种实现，官方实现，使用` List<List<Integer>> `构建邻接表

```java
// 拓扑排序(DFS 递归实现)
// DFS 第一种实现, 官方实现, 使用 List<List<Integer>> 构建邻接表
class P210_Solution3 {
    // 使用 List<List<Integer>> adjList = new ArrayList<>(); 构造邻接表
    List<List<Integer>> adjList;
    // 记录每个节点的状态: 0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;
    // 用数组来模拟栈, 下标 n-1 为栈底, 0 为栈顶, 遍历结束后栈中元素即为拓扑排序
    int[] ans;
    // 栈下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        adjList = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        visited = new int[numCourses];
        ans = new int[numCourses];
        index = numCourses - 1;
        // 构建邻接表
        for (int[] edge : prerequisites) {
            adjList.get(edge[1]).add(edge[0]);
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                return new int[0];
            }
        }
        return ans;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;
        for (int next : adjList.get(i)) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next] == 0) {
                dfs(next);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
        }
        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
        // 将节点入栈
        ans[index] = i;
        // 下标索引减 1
        index--;
    }
}
```

###### 第二种实现（最优）

> DFS 第二种实现，创建 `CourseNode `节点，使用` CourseNode[] `构建邻接表
> 效率比前三种都高，耗时更少，但是消耗的内存更多

```java
// 拓扑排序(DFS 递归实现)
// DFS 第二种实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 效率比前三种都高, 耗时更少, 但是消耗的内存更多
class P210_Solution {
    // 使用 CourseNode[] 构建邻接表
    P210_CourseNode[] adjList;
    // 记录每个节点的状态: 0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 标记是否是有向无环图
    boolean valid = true;
    // 用数组来模拟栈, 下标 n-1 为栈底, 0 为栈顶, 遍历结束后栈中元素即为拓扑排序
    int[] ans;
    // 栈下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        adjList = new P210_CourseNode[numCourses];
        visited = new int[numCourses];
        ans = new int[numCourses];
        index = numCourses - 1;

        // 构建邻接表
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new P210_CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }
        // 从未遍历过的节点开始遍历
        for (int i = 0; i < numCourses; i++) {
            // 未搜索过
            if (visited[i] == 0) {
                dfs(i);
            }
            if (!valid) {
                return new int[0];
            }
        }
        return ans;
    }

    private void dfs(int i) {
        // 标记为 1, 表示正在搜索中
        visited[i] = 1;

        P210_CourseNode next = adjList[i];
        while (next != null) {
            // 相邻节点未搜索过, 搜索这个节点
            if (visited[next.value] == 0) {
                dfs(next.value);
                // 剪枝判断, 若已知存在环了, 可提前结束循环
                if (!valid) {
                    return;
                }
            } else if (visited[next.value] == 1) {
                // 表示曾经搜索过 next 节点, 并从 next 节点一直搜索到 i, 现在要从 i 再去找 next, 说明存在了环
                valid = false;
                return;
            }/* else {
                // visited[next] == 2 时
                // 不做操作
            }*/
            next = next.next;
        }

        // 标记为 2, 表示已经搜索完毕这个节点及其相邻节点
        visited[i] = 2;
        // 将节点入栈
        ans[index] = i;
        // 下标索引减 1
        index--;
    }
}

// CourseNode
class P210_CourseNode {
    // value 为课程编号
    int value;
    P210_CourseNode next;

    public P210_CourseNode(int value) {
        this.value = value;
    }

    public P210_CourseNode(int value, P210_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

##### 拓扑排序（广度优先搜索 队列实现）

###### 第一种实现

```java
// 拓扑排序(BFS 队列实现)
// BFS 第一种实现, 官方实现, 使用 List<List<Integer>> 构建邻接表
// 效率低, 时间不及 DFS
class P210_Solution1 {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        List<List<Integer>> adjList = new ArrayList<>(numCourses);
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        // 存储每个节点的入度
        int[] inDegree = new int[numCourses];
        // 构建邻接表, 并得到每个节点的入度
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 终止节点的入度加 1
            inDegree[to]++;
            // 将该边添加进邻接表 adjList
            adjList.get(from).add(to);
        }

        // BFS
        // 入度为 0 的节点入队
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 一个入度为 0 的节点都没有, 说明有一个整个图是一个大环, 可直接返回
        // 此判断可删除
        if (queue.isEmpty()) {
            return new int[0];
        }

        // 答案, 每出队一个入度为 0 的节点, 等于确定一门先修课程
        int[] ans = new int[numCourses];
        // 添加的位置, 同时也代表得到答案中的节点个数 index + 1
        int index = 0;
        int cur;
        while (!queue.isEmpty()) {
            // 从队首取出一个入度为 0 的节点
            cur = queue.remove();
            // 将 cur 添加进答案中
            ans[index] = cur;
            // 下一个添加位置
            index++;
            for (Integer next : adjList.get(cur)) {
                // 以 cur 为起始点的有向边的终点的入度减 1
                inDegree[next]--;
                // 入度减小到为 0 时, 说明 next 的所有前修课程均已经学习完毕, 将其加入队列, 后续就可以学习这门课程了
                if (inDegree[next] == 0) {
                    queue.add(next);
                }
            }
        }
        // 循环结束时, 如果 index 等于 numCourses, 说明这个学习顺序能够完成所有课程的学习
        return index == numCourses ? ans : new int[0];
    }
}
```

###### 第二种实现

```java
// 拓扑排序(BFS 队列实现)
// BFS 第二种实现, 创建 CourseNode 节点, 使用 CourseNode[] 构建邻接表
// 效率比第一种高, 耗时更少, 空间也比第一种更少
class P210_Solution2 {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 邻接表存储有向图
        P210_CourseNode[] adjList = new P210_CourseNode[numCourses];
        // 存储每个节点的入度
        int[] inDegree = new int[numCourses];
        // 构建邻接表, 并得到每个节点的入度
        int from, to;
        for (int[] edge : prerequisites) {
            // 有向边的起始节点
            from = edge[1];
            // 有向边的终止节点
            to = edge[0];
            // 终止节点的入度加 1
            inDegree[to]++;
            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new P210_CourseNode(to, adjList[from]);
            /*
            CourseNode toNode = new CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // BFS
        // 入度为 0 的节点入队
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 一个入度为 0 的节点都没有, 说明有一个整个图是一个大环, 可直接返回
        // 此判断可删除
        if (queue.isEmpty()) {
            return new int[0];
        }

        // 答案, 每出队一个入度为 0 的节点, 等于确定一门先修课程
        int[] ans = new int[numCourses];
        // 添加的位置, 同时也代表得到答案中的节点个数 index + 1
        int index = 0;
        int cur;
        P210_CourseNode next;
        while (!queue.isEmpty()) {
            // 从队首取出一个入度为 0 的节点
            cur = queue.remove();
            // 将 cur 添加进答案中
            ans[index] = cur;
            // 下一个添加位置
            index++;
            next = adjList[cur];
            while (next != null) {
                // 以 cur 为起始点的有向边的终点的入度减 1
                inDegree[next.value]--;
                // 入度减小到为 0 时, 说明 next 的所有前修课程均已经学习完毕, 将其加入队列, 后续就可以学习这门课程了
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }
                next = next.next;
            }
        }
        // 循环结束时, 如果 index 等于 numCourses, 说明这个学习顺序能够完成所有课程的学习
        return index == numCourses ? ans : new int[0];
    }
}

// CourseNode
class P210_CourseNode {
    // value 为课程编号
    int value;
    P210_CourseNode next;

    public P210_CourseNode(int value) {
        this.value = value;
    }

    public P210_CourseNode(int value, P210_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```



#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

##### 动态规划

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。
> - 空间复杂度：O(1)。

```java
class P213_Solution {
    // 动态规划(滚动数组思想)
    // 时间复杂度：O(n)
    // 空间复杂度：O(1)
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        } else if (n == 2) {
            return Math.max(nums[0], nums[1]);
        } else if (n == 3) {
            return Math.max(Math.max(nums[0], nums[1]), nums[2]);
        }

        // 如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？
        // 如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；
        // 如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。
        return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }

    public int robRange(int[] nums, int start, int end) {

        int[] dp = new int[3];
        dp[0] = nums[start];
        dp[1] = Math.max(nums[start], nums[start + 1]);
        // dp[2] = dp[1];

        for (int i = start + 2; i <= end; i++) {
            dp[2] = Math.max(dp[0] + nums[i], dp[1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        System.out.println(Arrays.toString(dp));
        // 此处若返回 dp[2], 必须保证原 nums 数组长度大于 3
        // 由于之前咋 rob 中对 n == 3, 进行了特殊处理, 所以此处可以返回 dp[2]
        // 如果不对 n == 3 做特殊处理, 也可以给 dp[2] 赋初值 dp[2] = dp[1];
        // 当然, 如果是返回 dp[1] 就肯定没错
        return dp[2];
    }
}
```
#### [223. 矩形面积](https://leetcode-cn.com/problems/rectangle-area/)

```java
class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        // 解决思路：用两块矩形的面积和减去两块矩形重叠部分的面积,不过为了在运算过程中防止溢出，需要先用其中一块矩形面积减去重叠面积，再加上另一块矩形面积
        
        // 重叠面积初始化为 0
        int coverArea = 0;
        // 如果两块矩形没有重合，则重叠面积 coverArea 为 0，后续 return 直接返回两矩形面积和
        if (bx1 >= ax2 || bx2 <= ax1 || by1 >= ay2 || by2 <= ay1) {
             coverArea = 0;
        } else {

            // 两块矩形重叠部分的面积 = 两矩形重叠部分长（x 轴差） * 两矩形重叠部分宽（y 轴差）
            // 两矩形重叠部分长 = x 轴上两矩形右边条边的较小值 min(ax2, bx2) - x 轴上两矩形左边条边的较大值 max(ax1, bx1)
            // 两矩形重叠部分宽 = y 轴上两矩形上边条边的较小值 min(ay2, by2) - y 轴上两矩形下边条边的较大值 max(ay1, by1)

            int x_right_min = Math.min(ax2, bx2);
            int x_left_max = Math.max(ax1, bx1);
            int y_up_min = Math.min(ay2, by2);
            int y_down_max = Math.max(ay1, by1);

            // 两块矩形重叠部分的面积
            coverArea = (x_right_min - x_left_max) * (y_up_min - y_down_max);
        }
        
        // 一块矩形面积 - 重叠面积 + 另一块矩形面积
        return (ax2 - ax1) * (ay2 - ay1) - coverArea + (bx2 - bx1) * (by2 - by1);
    }
}
```

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

##### 基本操作

```java
// 直接排序返回
// 时间复杂度 O(N log N)
class P215_Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }
}
```

##### 基于堆排序的选择方法（优先队列实现）

```java
// 基于堆排序的选择方法(优先队列实现)
class P215_Solution1 {
    // 小顶堆
    // 时间复杂度 O(N log k) 只记录 k 个
    // 空间复杂度 O(k)
    // 4ms
    public int findKthLargest1(int[] nums, int k) {
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
        for (int num : nums) {
            /* 4ms */
            if (priorityQueue.size() == k) {
                if (priorityQueue.peek() != null && priorityQueue.peek() < num) {
                    priorityQueue.remove();
                    priorityQueue.add(num);
                }
            } else {
                priorityQueue.add(num);
            }
            /* 5ms */
//            priorityQueue.add(num);
//            if(priorityQueue.size() > k) {
//                priorityQueue.remove();
//            }
        }
        return priorityQueue.remove();
    }

    // 大顶堆
    // 时间复杂度 O(N log N)
    // 空间复杂度 O(N)
    // 5ms
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((o1, o2) -> (o2 - o1));
        for (int num : nums) {
            priorityQueue.add(num);
        }
        int ans = 0;
        for (int i = 0; i < k; i++) {
            ans = priorityQueue.remove();
        }
        return ans;
    }
}
```

##### 基于快速排序的选择方法

#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

##### 基本操作（预先排序）

```java
// 排序 O(NlogN) O(logN)
// 19 ms
class P217_Solution1 {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for (int i = 0; i < n - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
        }
        return false;
    }
}
```

##### 哈希表

```java
// 哈希表 O(N) O(N)
// 4 ms
class P217_Solution {
    // 7 ms
    public boolean containsDuplicate1(int[] nums) {
        HashSet<Integer> hashSet = new HashSet<>();
        for (int num : nums) {
            // 如果 hashSet 中已经包含了该 num, 则直接返回 true
            if (hashSet.contains(num)) {
                return true;
            }
            hashSet.add(num);
        }
        return false;
    }

    // 由于是先做了 P219 和看了它的官解, 知道了原来 可以通过 hashSet.add(num) 的返回值来判断原 hashSet 中是否存在 num
    // 故可以不必使用 hashSet.contains(num) 预先判断
    // 4 ms
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> hashSet = new HashSet<>();
        for (int num : nums) {
            if (!hashSet.add(num)) {
                return true;
            }
        }
        return false;
    }
}
```



#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

##### 暴力解法

```java
// 暴力解法 2103 ms
class P219_Solution1 {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        // k 为 0, 不符合题意, 返回 false
        if (k == 0) {
            return false;
        }
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j <= i + k && j <= nums.length - 1; j++) {
                if (nums[i] == nums[j]) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

##### 哈希表

```java
// 哈希表 18 ms 90.50%
class P219_Solution2 {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        // k 为 0, 不符合题意, 返回 false
        if (k == 0) {
            return false;
        }
        // 使用哈希表记录每个元素的最大下标
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            Integer index = hashMap.get(nums[i]);
            // 若 index 不为 null, 则说明 hashMap 中若存在 nums[i]
            if (index != null) {
                // 此时判断两者是否满足其差值 <= k
                if (i - index <= k) {
                    return true;
                }
            }
            // 若 index 为 null, 则新添加 (nums[i], i)
            // 若 index 不为 null, 则更新 (nums[i], i)
            hashMap.put(nums[i], i);
        }
        return false;
    }
}
```

##### 滑动窗口

```java
// 滑动窗口 14 ms 99.05%
class P219_Solution {
    // 官方写法
    public boolean containsNearbyDuplicate1(int[] nums, int k) {
        // k 为 0, 不符合题意, 返回 false
        if (k == 0) {
            return false;
        }
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (i > k) {
                hashSet.remove(nums[i - k - 1]);
            }
            // 今天才知道原来 hashSet 添加一个已经存在于 set 中的值时, 会返回 false,
            // 这样就不用使用 hashSet.contains(num) 来预先判断了
            if (!hashSet.add(nums[i])) {
                return true;
            }
        }
        return false;
    }

    // 我的修改, 先将第一个窗口中的 k 个值添加到 hashSet 中, 有些多此一举
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        // k 为 0, 不符合题意, 返回 false
        if (k == 0) {
            return false;
        }
        HashSet<Integer> hashSet = new HashSet<>();
        // 先把前 k 个加入到 hashSet 中, 其实有些多此一举
        for (int i = 0; i <= k && i < nums.length; i++) {
            if (!hashSet.add(nums[i])) {
                return true;
            }
        }
        for (int i = k + 1; i < nums.length; i++) {
            hashSet.remove(nums[i - k - 1]);
            // 今天才知道原来 hashSet 添加一个已经存在于 set 中的值时, 会返回 false,
            // 这样就不必使用 hashSet.contains(num) 来预先判断了
            if (!hashSet.add(nums[i])) {
                return true;
            }
        }
        return false;
    }
}
```

#### [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)

##### 滑动窗口 + 有序集合

```java
// 滑动窗口 + 有序集合
// O(nlog(min(n,k)))
// O(min(n,k))
// 35 ms
class P220_Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        int n = nums.length;
        if (k == 0 || n <= 1) {
            return false;
        }

        TreeSet<Long> treeSet = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            if (i > k) {
                treeSet.remove((long) nums[i - k - 1]);
            }
            Long ceiling = treeSet.ceiling((long) nums[i] - (long) t);
            // 如果在集合中知道到了第一个大于等于 nums[i] - t 的值 ceiling, 并且该值小于等于 nums[i] + t, 说明找到了一对符合条件的元素
            // 不能使用 (long) (nums[i] + t) , 因为可能会超出 int 类型的表示范围
            if (ceiling != null && ceiling <= (long) nums[i] + (long) t) {
                return true;
            }
            // 将该值添加到集合中
            treeSet.add((long) nums[i]);
        }

        return false;
    }
}
```



#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

##### 递归

###### 第一种实现

```java
/*
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// 第一种实现
class P226_Solution1 {
    public TreeNode invertTree(TreeNode root) {
        // 前序遍历翻转
        // preInvertTree(root);
        // 后序遍历翻转
        postInvertTree(root);
        return root;
    }

    // 前序遍历翻转
    public void preInvertTree(TreeNode node) {
        if (node == null) {
            return;
        }
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        preInvertTree(node.left);
        preInvertTree(node.right);
    }

    // 后序遍历翻转
    public void postInvertTree(TreeNode node) {
        if (node == null) {
            return;
        }
        postInvertTree(node.left);
        postInvertTree(node.right);
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
    }
}
```

###### 第二种实现（简化）

```java
// 第二种实现
class P226_Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root != null) {
            TreeNode tmp = invertTree(root.left);
            root.left = invertTree(root.right);
            root.right = tmp;
        }
        return root;
    }
}
```



#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

##### 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode(int x) { val = x; }
 * }
 */
class P236_Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return preorder(root, p, q);
    }

    // 后序遍历(理论上不及前序遍历)
    public TreeNode postorder(TreeNode node, TreeNode p, TreeNode q) {
        if (node == null) {
            return null;
        }
        TreeNode leftAncestor = postorder(node.left, p, q);
        TreeNode rightAncestor = postorder(node.right, p, q);
        if (leftAncestor != null && rightAncestor != null || (node.val == p.val || node.val == q.val)) {
            return node;
        } else if (leftAncestor != null) {
            return leftAncestor;
        }
        return rightAncestor;
    }

    // 前序遍历
    public TreeNode preorder(TreeNode node, TreeNode p, TreeNode q) {
        if (node == null) {
            return null;
        }
        // 遇到找到 p 或者 q 可直接返回该节点
        if (node.val == p.val || node.val == q.val) {
            // 一个节点也可以是它自己的祖先
            return node;
        }
        TreeNode leftAncestor = preorder(node.left, p, q);
        TreeNode rightAncestor = preorder(node.right, p, q);
        if (leftAncestor != null && rightAncestor != null) {
            // 两个指定节点的最近公共祖先
            return node;
        } else if (leftAncestor != null) {
            return leftAncestor;
        }
        // 此时的 rightAncestor 可能为 pq 之一, 也可能为 null
        return rightAncestor;
    }
}
```



#### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */

class P237_Solution {
    // 我做的, 将 node 结点的值置为后一个结点的值, 直到末尾, 然后再删除最后一个结点(此时值与倒数第二个结点重复了)
    public void deleteNode(ListNode node) {
        ListNode temp = node;
        while (node != null) {
            if (node.next != null) {
                node.val = node.next.val;
                temp = node;
                node = node.next;
            } else {
                temp.next = null;
                node = null;
            }
        }
    }

    // 优化, 只需要将 node 结点的值变为 node.next 的值, 然后删除 node.next 就行了
    public void deleteNode1(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

##### 优先队列

```java
// 优先队列
// 我的 pq 是随时保证队列中只有 k 个元素, 而官方解法是保证在前面已经添加到队列中的若干数中的最大值是在最近nums 中的 k 个数
// 其中有些较小的数仍然可能是滑动窗口左侧边界左边的数, 它并没有被移除, 而我是每次都将不在窗口中的数移除了, 而要移除, 就会涉及到查找, 因此降低了效率
// 而官方的移除只需要移除堆顶, 并不是移除等于多少的具体的那个数（不涉及查找）
// 评论区评论
// 这里应该把主动寻找、及时删除的思维转换为被动检测、延迟处理
class P239_Solution1 {
    // 我的解法, 超时
    public int[] maxSlidingWindow1(int[] nums, int k) {
        if (k == 1) {
            return nums;
        }
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((o1, o2) -> (o2 - o1));
        // 初始化, 先将前 k 个数添加进队列
        for (int i = 0; i < k; i++) {
            priorityQueue.add(nums[i]);
        }
        // 得到第一个滑动窗口的最大值
        ans[0] = priorityQueue.peek();
        for (int i = k; i < n; i++) {
            // 出队列一个  超时就是来源于这一步
            priorityQueue.remove(nums[i - k]);
            // 当前滑动窗口中的最大值
            ans[i - k + 1] = Math.max(priorityQueue.peek(), nums[i]);
            // 入队列一个新的数
            priorityQueue.add(nums[i]);
        }
        return ans;
    }

    // 根据官方解法修改
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (k == 1) {
            return nums;
        }
        int n = nums.length;
        // 此处, 是大顶堆, 先根据 num 值从大到小排序, 再根据位置下标 i 排序(从小到大、从大到小皆可)
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[0] != o2[0] ? o2[0] - o1[0] : o2[1] - o1[1]);
        // 初始化, 先将前 k 个数添加进队列
        for (int i = 0; i < k; i++) {
            pq.add(new int[]{nums[i], i});
        }
        int[] ans = new int[n - k + 1];
        // 得到第一个滑动窗口的最大值
        ans[0] = pq.peek()[0];
        for (int i = k; i < n; i++) {
            // 先将新的数添加进队列, 此时队列中就可能会产生一个新的最大值
            pq.add(new int[]{nums[i], i});
            // 但是这个最大值可能是当前滑动窗口中左侧边界左边的数, 不在滑动窗口中, 因此需要将其从队列中移除
            while (pq.peek()[1] <= i - k) {
                pq.remove();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}
```

##### 单调队列

```java
// 单调队列 (双端队列)
class P239_Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (k == 1) {
            return nums;
        }
        int n = nums.length;
        // 单调队列 (递减)
        Deque<Integer> deque = new LinkedList<>();
        // 初始化, 先将前 k 个数添加进队列
        for (int i = 0; i < k; i++) {
            // 移除队列尾比 nums[i] 小的数的下标
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.removeLast();
            }
            deque.addLast(i);
        }
        
        int[] ans = new int[n - k + 1];
        // 得到第一个滑动窗口的最大值
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i < n; i++) {
            // 移除队列尾比 nums[i] 小的数的下标
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.removeLast();
            }
            // 添加 nums[i] 的下标
            deque.addLast(i);
            // 移除超出滑动窗口左侧边界左边的数的下标
            while (deque.peekFirst() <= i - k) {
                deque.removeFirst();
            }
            // 此时的 nums[deque.peekFirst()] 即为在滑动窗口内部的所有数中的最大值
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```

##### 分块 + 预处理

```java
```



#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

##### 动态规划

> 时间复杂度：O(n^2)
>
> 空间复杂度：O(n)

```java
class P300_Solution {
    // 动态规划
    // 时间复杂度：O(n^2) 空间复杂度：O(n)
    // 内层 for 循环我犯过一次错误, 以为在 nums[i] 前找到第一个比 nums[i] 小的值的 dp 就行了
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 最长递增子序列的长度, 初值为 0 为 1 均可
        int maxLen = 1;
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的长度
        int[] dp = new int[n];
        // 赋初值: 以 nums[0] 结尾的最长子序列的长度为 1
        dp[0] = 1;
        // 从 i == 1 开始
        for (int i = 1; i < n; i++) {
            // 在 [0,i) 之间找到比当前 nums[i] 小的那个数, 假设有 x 个这样的数
            // 那么 dp[i] 也就等于以这 x 个这样的数结尾的最长子序列长度的最大值 + 1
            // 也就是找到一条 i 之前的最长子序列, 并且该最长子序列的结尾值要 nums[j] < nums[i]
            // 那么现在加上 nums[i] 这个数, 就有了一条以 nums[i] 结尾的最长子序列
            // 同时也知道了其长度值, 更新 dp[i]
            // 那么当循环结束时, 就知道了以这 n 个数结尾的最长子序列的长度, 最长长度就很轻松就能得到

            // 以上讨论的是找得到的情况, 如果找不到呢?
            // 找不到不就说明当前 nums[i] 是 [0,i] 之间这 i + 1 个数中的最大值吗?
            // 那么 nums[i] 就成为了一条新的子序列的开头(也即末尾), 当前序列长度就为 1 了
            // 故在查找前, 先令其为 1, 后续如果找到, 肯定值比 1 大
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    // 如果是非严格单调递增, 改为 <= 即可
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            // 每次得到以 nums[i] 结尾的最长子序列长度, 就与之前的 maxLen 比较
            // 得到 [0,i] 之间以这 i + 1 个数结尾的最长子序列长度中的最大值
            maxLen = Math.max(maxLen, dp[i]);
        }
        // System.out.println(Arrays.toString(dp));
        return maxLen;
    }
}
```

##### 贪心 + 二分查找

> 时间复杂度：O(nlogn)
>
> 空间复杂度：O(n)

```java
class P300_Solution {
    // 贪心 + 二分查找
    // 时间复杂度：O(nlogn) 空间复杂度：O(n)
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 贪心
        // 维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，
        // 用 len 记录目前最长上升子序列的长度，
        // 起始时 len 为 1，d[1] = nums[0]
        // d[0] 位置不管
        int[] d = new int[n + 1];
        // 赋初值
        int len = 1;
        d[len] = nums[0];
        for (int i = 1; i < n; i++) {
            // nums[i] 比当前最长子序列的最后一个元素都大, 将其添加在末尾 d[len + 1]
            if (nums[i] > d[len]) {
                d[len + 1] = nums[i];
                len++;
                continue;
            }
            // 二分查找
            int left = 1;
            int right = len;
            int mid = 0;
            while (left <= right) {
                mid = (left + right) / 2;
                if (nums[i] > d[mid]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            // 两种赋值方式选其一
/*
            // 1.
            // 此时, left == mid
            if (right < mid) {
                d[mid] = nums[i];
            } else {
                // 此时, left == mid + 1
                d[mid + 1] = nums[i];
            }
*/
            // 2. 算是第一种的归纳总结
            // 故最终
            // 这个结束赋值极其重要, 到现在其实都不太明白, while 结束后应该在哪一个位置赋值
            // 这个类似插入位置之前在 P35 遇到过
            d[left] = nums[i];
        }
        return len;
    }
}
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```java
// 动态规划
class P322_Solution {
    public int coinChange1(int[] coins, int amount) {
        // 特殊情况处理
        if (amount == 0) {
            return 0;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return -1;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return amount / coins[0];
            } else {
                return -1;
            }
        }

        // 先对 coins 排序, 减少循环次数
        Arrays.sort(coins);

        // 特殊情况处理: 如果金额比最小的一枚硬币还小, 则找不到(前提是 amount > 0)
        if (amount < coins[0]) {
            return -1;
        }

        int[] dp = new int[amount + 1];
        // 由于在循环中比较求得的是最小值, 所以在赋初值时需要将其将 dp 置为尽量大的不可能是结果的数
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        // 依次判断确认, 找出凑成金额为 i 的最少硬币个数
        for (int i = 1; i < amount + 1; i++) {
            for (int j = 0; j < n; j++) {
                // 只有当前硬币小于金额 i 时, 才可能将该硬币添加进组合中
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                } else {
                    break;
                }
            }
        }
        // 如果最终结果中 dp[amount] 还是最初的初值, 说明根本找不到这种硬币组合, 返回 -1
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }

    // 些微优化
    public int coinChange(int[] coins, int amount) {
        // 特殊情况处理
        if (amount == 0) {
            return 0;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return -1;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return amount / coins[0];
            } else {
                return -1;
            }
        }

        // 先对 coins 排序, 减少循环次数
        Arrays.sort(coins);

        // 特殊情况处理: 如果金额比最小的一枚硬币还小, 则找不到(前提是 amount > 0)
        if (amount < coins[0]) {
            return -1;
        }

        int[] dp = new int[amount + 1];
        dp[0] = 0;

        int min;

        // 依次判断确认, 找出凑成金额为 i 的最少硬币个数
        for (int i = 1; i < amount + 1; i++) {
            // 由于在循环中比较求得的是最小值, 所以在赋初值时需要将其将 min 置为尽量大的不可能是结果的数
            min = amount + 1;
            for (int coin : coins) {
                // 只有当前硬币小于金额 i 时, 才可能将该硬币添加进组合中
                if (coin <= i) {
                    min = Math.min(min, dp[i - coin]);
                } else {
                    break;
                }
            }
            dp[i] = min + 1;
        }
        // 如果最终结果中 dp[amount] 还是最初的初值, 说明根本找不到这种硬币组合, 返回 -1
        return dp[amount] >= amount + 1 ? -1 : dp[amount];
    }
}
```



#### [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

##### 动态规划（超时）

```java
// 动态规划 0(N^2) O(N) 超时
class P334_Solution1 {
    public boolean increasingTriplet(int[] nums) {
        int n = nums.length;
        // dp[i] 表示以序列中的第 i 个元素结尾的最长上升子序列的长度
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            if (dp[i] >= 3) {
                return true;
            }
        }
        return false;
    }
}
```

##### 贪心（最优解法）

```java
// 贪心 O(N) O(1)
class P334_Solution {
    public boolean increasingTriplet(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return false;
        }
        // 三元组中的前两个数
        int[] dp = new int[2];
        dp[0] = nums[0];
        // 一定要初始化为一个数组范围最大值
        dp[1] = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            // nums[i] 比最小数小, 更新
            if (nums[i] <= dp[0]) {
                dp[0] = nums[i];
            } else if (nums[i] <= dp[1]) {
                // nums[i] 比第二小数小, 更新
                dp[1] = nums[i];
            } else {
                // 找到 nums[i] 为三元组的第三个数
                return true;
            }
        }
        return false;
    }
}
```



#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

##### 动态规划

> [一个不错的题解](https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/)

```java
class P337_Solution1 {
    // 表示选择 node 节点的情况下, node 节点的子树上被选择的节点的最大权值和
    Map<TreeNode, Integer> selectThisNode = new HashMap<>();
    // 表示不选择 node 节点的情况下, node 节点的子树上被选择的节点的最大权值和
    Map<TreeNode, Integer> notSelectThisNode = new HashMap<>();

    public int rob(TreeNode root) {
        dfs(root);
        return Math.max(selectThisNode.getOrDefault(root, 0), notSelectThisNode.getOrDefault(root, 0));
    }

    // 后序遍历
    public void dfs(TreeNode node) {
        if (node == null) {
            return;
        }
        // 遍历左子树, 得到 node 节点的左子树上 (被选择和不被选择) 的节点的最大权值和
        // 退出 dfs 时, (node.left, 被选择和不被选择的 权值和) 已经添加进了 selectThisNode 和 notSelectThisNode 中
        dfs(node.left);
        // 遍历右子树, 得到 node 节点的右子树上 (被选择和不被选择) 的节点的最大权值和
        dfs(node.right);

        // 当 node 被选中时, node 的左右孩子都不能被选中, 故 node 被选中情况下子树上被选中点的最大权值和为
        // node.left 和 node.right 不被选中的最大权值和相加,
        // 即 sel(node) = node.val + not(node.left) + not(node.right)
        selectThisNode.put(node, node.val
                + notSelectThisNode.getOrDefault(node.left, 0)
                + notSelectThisNode.getOrDefault(node.right, 0)
        );
        // 当 node 不被选中时, node 的左右孩子可以被选中, 也可以不被选中
        // 对于 node 的某个具体的孩子 children, 它对 node 的贡献是 children 被选中和不被选中情况下权值和的较大值
        // 故 not(node) = max{sel(node.left) , not(node.left)} + max{sel(node.right) , not(node.right)}
        notSelectThisNode.put(node,
                Math.max(selectThisNode.getOrDefault(node.left, 0), notSelectThisNode.getOrDefault(node.left, 0))
                        + Math.max(selectThisNode.getOrDefault(node.right, 0), notSelectThisNode.getOrDefault(node.right, 0))
        );
    }
}
```

> 以上的算法对二叉树做了一次后序遍历，时间复杂度是 O(n)；由于递归会使用到栈空间，空间代价是 O(n)，哈希表的空间代价也是 O(n)，故空间复杂度也是 O(n)。
>

简单优化，省去使用哈希表的空间, 但是整体空间复杂度并未改变, 均是O(N)

```java
// 优化, 省去使用哈希表的空间, 但是整体空间复杂度并未改变, 均是O(N)
class P337_Solution {

    public int rob(TreeNode root) {
        int[] rootStatus = dfs(root);
        return Math.max(rootStatus[0], rootStatus[1]);
    }

    // 后序遍历
    public int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        // 遍历左子树, 得到 node 节点的左子树上 (被选择和不被选择) 的节点的最大权值和
        // 退出 dfs 时, 返回 node.left 的 被选择和不被选择的权值和数组 leftNodeStatus
        // leftNodeStatus[0] 表示 选择 node.left 的权值和
        // rightNodeStatus[0] 表示 不选择 node.left 的权值和
        int[] leftNodeStatus = dfs(node.left);
        // 遍历右子树, 得到 node 节点的右子树上 (被选择和不被选择) 的节点的最大权值和
        int[] rightNodeStatus = dfs(node.right);

        // 当 node 被选中时, node 的左右孩子都不能被选中, 故 node 被选中情况下子树上被选中点的最大权值和为
        // node.left 和 node.right 不被选中的最大权值和相加,
        // 即 sel(node) = node.val + not(node.left) + not(node.right)
        int valOfSelectThisNode = node.val + leftNodeStatus[1] + rightNodeStatus[1];

        // 当 node 不被选中时, node 的左右孩子可以被选中, 也可以不被选中
        // 对于 node 的某个具体的孩子 children, 它对 node 的贡献是 children 被选中和不被选中情况下权值和的较大值
        // 故 not(node) = max{sel(node.left) , not(node.left)} + max{sel(node.right) , not(node.right)}
        int valOfNotSelectThisNode = Math.max(leftNodeStatus[0], leftNodeStatus[1]) + Math.max(rightNodeStatus[0], rightNodeStatus[1]);

        return new int[]{valOfSelectThisNode, valOfNotSelectThisNode};
    }

    // 后序遍历, 些微改变
    public int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        // 遍历左子树, 得到 node 节点的左子树上 (被选择和不被选择) 的节点的最大权值和
        // 退出 dfs 时, 返回 node.left 的 被选择和不被选择的权值和数组 leftNodeStatus
        // leftNodeStatus[0] 表示 选择 node.left 的权值和
        // rightNodeStatus[0] 表示 不选择 node.left 的权值和
        int[] leftNodeStatus = dfs(node.left);
        // 遍历右子树, 得到 node 节点的右子树上 (被选择和不被选择) 的节点的最大权值和
        int[] rightNodeStatus = dfs(node.right);

        int[] nodeStatus = new int[2];

        // 当 node 被选中时, node 的左右孩子都不能被选中, 故 node 被选中情况下子树上被选中点的最大权值和为
        // node.left 和 node.right 不被选中的最大权值和相加,
        // 即 sel(node) = node.val + not(node.left) + not(node.right)
        nodeStatus[0] = node.val + leftNodeStatus[1] + rightNodeStatus[1];

        // 当 node 不被选中时, node 的左右孩子可以被选中, 也可以不被选中
        // 对于 node 的某个具体的孩子 children, 它对 node 的贡献是 children 被选中和不被选中情况下权值和的较大值
        // 故 not(node) = max{sel(node.left) , not(node.left)} + max{sel(node.right) , not(node.right)}
        nodeStatus[1] = Math.max(leftNodeStatus[0], leftNodeStatus[1]) + Math.max(rightNodeStatus[0], rightNodeStatus[1]);

        return nodeStatus;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)。上文中已分析。
>
>
> - 空间复杂度：O(n)。虽然优化过的版本省去了哈希表的空间，但是栈空间的使用代价依旧是 O(n)，故空间复杂度不变。
>

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

##### 2021.10.31

```java
class P344_Solution {
    public void reverseString(char[] s) {
        int len = s.length;
        char temp;
        for (int i = 0; i < len / 2; i++) {
            temp = s[i];
            s[i] = s[len - 1 - i];
            s[len - 1 - i] = temp;
        }
    }
}
```

#### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

##### 大小顶堆（优先队列实现）

```java
// 大小顶堆(优先队列实现)
class P347_Solution {
    // 时间复杂度 O(N log N)
    // 11 ms 94.34%
    // 大顶堆
    public int[] topKFrequent2(int[] nums, int k) {
        HashMap<Integer, Integer> countMap = new HashMap<>();
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }
        Set<Map.Entry<Integer, Integer>> entrySet = countMap.entrySet();
        // 小顶堆 只保留 k 个
        PriorityQueue<Map.Entry<Integer, Integer>> priorityQueue = new PriorityQueue<>((o1, o2) -> (o1.getValue() - o2.getValue()));
        // 限制优先队列的大小为 k, 这样的话就是 O(N log k) 的时间复杂度了
        for (Map.Entry<Integer, Integer> entry : entrySet) {
//            /* 1. 每次先添加, 再移除 15 ms 22.64% */
//            priorityQueue.offer(entry);
//            // 移除出现次数较小的, 剩下的就是出现次数较大的了
//            if (priorityQueue.size() > k) {
//                priorityQueue.remove();
//            }

            /* 2. 每次先判断是否添加, 也即先移除, 再添加 13 ms 61.93% */
            if (priorityQueue.size() == k) {
                // 移除出现次数较小的, 剩下的就是出现次数较大的了
                if (priorityQueue.peek().getValue() < entry.getValue()) {
                    priorityQueue.remove();
                    priorityQueue.offer(entry);
                }
            } else {
                priorityQueue.offer(entry);
            }
        }
        int[] ans = new int[k];
        for (int i = 0; i < k; i++) {
            ans[i] = priorityQueue.remove().getKey();
        }
        return ans;
    }

    // 时间复杂度 O(N log k)
    // 13 ms 61.93%
    // 小顶堆
    public int[] topKFrequent1(int[] nums, int k) {
        HashMap<Integer, Integer> countMap = new HashMap<>();
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }
        Set<Map.Entry<Integer, Integer>> entrySet = countMap.entrySet();
        // 大顶堆 保留 n 个
        PriorityQueue<Map.Entry<Integer, Integer>> priorityQueue = new PriorityQueue<>((o1, o2) -> (o2.getValue() - o1.getValue()));
        for (Map.Entry<Integer, Integer> entry : entrySet) {
            priorityQueue.offer(entry);
        }
        int[] ans = new int[k];
        for (int i = 0; i < k; i++) {
            ans[i] = priorityQueue.remove().getKey();
        }
        return ans;
    }

    // 时间复杂度 O(N log k)
    // 12 ms 89.90%
    // 优先队列中保存的元素不是 Map.Entry<Integer, Integer> 类型
    // 而是 int[]{num, count}
    // 小顶堆
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> countMap = new HashMap<>();
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }
        Set<Map.Entry<Integer, Integer>> entrySet = countMap.entrySet();
        // 小顶堆 只保留 k 个
        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((o1, o2) -> (o1[1] - o2[1]));
        // 限制优先队列的大小为 k, 这样的话就是 O(N log k) 的时间复杂度了
        for (Map.Entry<Integer, Integer> entry : entrySet) {
//            /* 1. 每次先添加, 再移除 14 ms 37.32% */
//            priorityQueue.offer(new int[]{entry.getKey(), entry.getValue()});
//            // 移除出现次数较小的, 剩下的就是出现次数较大的了
//            if (priorityQueue.size() > k) {
//                priorityQueue.remove();
//            }

            /* 2. 每次先判断是否添加, 也即先移除, 再添加 12 ms 89.90% */
            if (priorityQueue.size() == k) {
                // 移除出现次数较小的, 剩下的就是出现次数较大的了
                assert priorityQueue.peek() != null;
                if (priorityQueue.peek()[1] < entry.getValue()) {
                    priorityQueue.remove();
                    priorityQueue.offer(new int[]{entry.getKey(), entry.getValue()});
                }
            } else {
                priorityQueue.offer(new int[]{entry.getKey(), entry.getValue()});
            }
        }
        int[] ans = new int[k];
        for (int i = 0; i < k; i++) {
            ans[i] = priorityQueue.remove()[0];
        }
        return ans;
    }
}
```

##### 基于快速排序

#### [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)

##### 哈希表

```java
class P391_Solution {
    public boolean isRectangleCover(int[][] rectangles) {
        int n = rectangles.length;
        if (n == 1) {
            return true;
        }
        // 定义矩形的面积
        long area = 0;

        int minX = rectangles[0][0];
        int minY = rectangles[0][1];
        int maxX = rectangles[0][2];
        int maxY = rectangles[0][3];
        // 保存各个顶点出现的次数
        Map<Point, Integer> cnt = new HashMap<>();
        for (int[] rect : rectangles) {
            // 两个顶点的横纵坐标
            int a = rect[0];
            int b = rect[1];
            int c = rect[2];
            int d = rect[3];

            // 累加各个矩形的面积, 得到总和, 最后与 (maxX - minX) * (maxY - minY) 比较
            area += (long) (c - a) * (d - b);

            minX = Math.min(minX, a);
            minY = Math.min(minY, b);
            maxX = Math.max(maxX, c);
            maxY = Math.max(maxY, d);

            // 将该矩形的四个顶点加入 map 中, 并更新出现次数
            Point point1 = new Point(a, b);
            Point point2 = new Point(a, d);
            Point point3 = new Point(c, b);
            Point point4 = new Point(c, d);

            cnt.put(point1, cnt.getOrDefault(point1, 0) + 1);
            cnt.put(point2, cnt.getOrDefault(point2, 0) + 1);
            cnt.put(point3, cnt.getOrDefault(point3, 0) + 1);
            cnt.put(point4, cnt.getOrDefault(point4, 0) + 1);
        }

        // System.out.println("maxX = " + maxX + ", minX = " + minX + ", maxY = " + maxY + ", minY = " + minY);
        // System.out.println((maxX - minX) * (maxY - minY));
        // 得到最终完美矩形的四个顶点
        Point pointMinMin = new Point(minX, minY);
        Point pointMinMax = new Point(minX, maxY);
        Point pointMaxMin = new Point(maxX, minY);
        Point pointMaxMax = new Point(maxX, maxY);

        // 面积不相等或者四个顶点中并不是每个顶点都只出现一次
        if (area != (long) (maxX - minX) * (maxY - minY) ||
                cnt.getOrDefault(pointMinMin, 0) != 1 ||
                cnt.getOrDefault(pointMinMax, 0) != 1 ||
                cnt.getOrDefault(pointMaxMin, 0) != 1 ||
                cnt.getOrDefault(pointMaxMax, 0) != 1) {
            return false;
        }

        // 移除四个角顶点
        cnt.remove(pointMinMin);
        cnt.remove(pointMinMax);
        cnt.remove(pointMaxMin);
        cnt.remove(pointMaxMax);

        // 判断非矩形区域四角的顶点 出现的次数
        // 如果是完美矩形, 出现次数只能是 2 或者 4 次
        for (Map.Entry<Point, Integer> entry : cnt.entrySet()) {
            int value = entry.getValue();
            if (value != 2 && value != 4) {
                return false;
            }
        }
        return true;
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public int hashCode() {
        // return x + y;
        // 这个太神奇了, 改哈希函数, 太影响性能了
        return x * 512 - y;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Point) {
            Point point2 = (Point) obj;
            return this.x == point2.x && this.y == point2.y;
        }
        return false;
    }
}
```

##### 扫描线

待补充学习

#### [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

##### 哈希表

```java
class P409_Solution {
    // 哈希表, 效率很低
    public int longestPalindrome1(String s) {
        if (s == null || "".equals(s)) {
            return 0;
        }

        // 统计每个字符出现的次数
        HashMap<Character, Integer> hashMap = new HashMap<>();
        char c;
        for (int i = 0; i < s.length(); i++) {
            c = s.charAt(i);
            hashMap.put(c, hashMap.getOrDefault(c, 0) + 1);
        }

        // 最长回文子串的一半的长度
        int maxHalfLen = 0;
        // bl 为 true 时, 表示最终的回文子串的长度为 奇数
        boolean bl = false;
        for (Integer num : hashMap.values()) {
            maxHalfLen += num / 2;
            if (!bl && num % 2 == 1) {
                bl = true;
            }
        }
//        if (bl) {
//            return maxHalfLen * 2 + 1;
//        } else {
//            return maxHalfLen * 2;
//        }
        return maxHalfLen * 2 + (bl ? 1 : 0);
    }

    // 稍稍修改
    public int longestPalindrome(String s) {
        if (s == null || "".equals(s)) {
            return 0;
        }

        // 统计每个字符出现的次数
        HashMap<Character, Integer> hashMap = new HashMap<>();
        char c;
        for (int i = 0; i < s.length(); i++) {
            c = s.charAt(i);
            hashMap.put(c, hashMap.getOrDefault(c, 0) + 1);
        }

        // 最长回文子串的一半的长度
        int maxHalfLen = 0;
        // 发现还可以再稍稍修改一下
        // flag == 1 时, 表示最终的回文子串的长度为 奇数
        int flag = 0;
        for (Integer num : hashMap.values()) {
            maxHalfLen += num / 2;
            if (flag == 0 && num % 2 == 1) {
                flag = 1;
            }
        }

        return maxHalfLen * 2 + flag;
    }
}
```



#### [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

##### 迭代

> 依次遍历每块陆地，判断其上下左右的方格是否为水域，如果是，周长加1。

##### 深度优先搜索(递归实现)

```java
// 深度优先搜索(递归实现)
class P463_Solution {
    int[][] grid;

    public int islandPerimeter(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int Perimeter = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    Perimeter = dfs(i, j);
                    // 本题要求只有一个岛屿
                    break;
                }
            }
            if (Perimeter != 0) {
                // 本题要求只有一个岛屿
                break;
            }
        }
        return Perimeter;
    }

    public int dfs(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return 1;
        }
        // 如果该格子是水, return 1;
        if (grid[i][j] == 0) {
            return 1;
        } else if (grid[i][j] == 2) {
            // 如果该格子是已经访问过的陆地, return 0;
            return 0;
        }

        // 如果该格子是未访问过的陆地
        // 标记为已访问
        grid[i][j] = 2;
        // 返回该陆地相连的其它陆地的总周长
        return dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);
    }
}
```

##### 其它解法

> 一束光从 x 轴正负两个方向分别照到岛上时照到的边的数量是相等的，从 y 轴正负两个方向分别照到岛上时照到的边的数量也是相等的
> 所以每个坐标轴只需计算一个方向，最后把答案乘二即可
> 经评论提醒，之前没有表达清除，这束光可以想象成从斜上方照向岛屿，因为要保证某一方向上所有的边都被照到
> 每个格子如果左边是水说明照的到，否则照不到，上方同理
>
> ```c++
> //C++
> class Solution {
> public:
>     int islandPerimeter(vector<vector<int>>& grid) 
>     {
>         int m = grid.size();
>         int n = grid[0].size();
>         int ans = 0;
>         for (int i = 0; i < m; ++i)
>             for (int j = 0; j < n; ++j)
>             {
>                 if (grid[i][j] == 1)
>                 {
>                     if (i == 0)
>                         ++ans;
>                     else
>                         ans += grid[i - 1][j] == 0;
>                     if (j == 0)
>                         ++ans;
>                     else
>                         ans += grid[i][j - 1] == 0;
>                 }
>             }
>         return ans << 1;
>     }
> };
> ```

#### [472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)

##### 字典树 + 深度优先搜索（递归实现）

```java
// 字典树 + 深度优先搜索（递归实现）
class P472_Solution1 {
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<>();
        P472_Trie trie = new P472_Trie();

        // 注意最终的字典树 Trie 中并不包含连接词, 即不将连接词加入到字典树中
        // 将 words 中的 word 按照长度从小到大排序, 将较短的 word 加入到字典树中, 判断较长的是否由已加入到字典树中的较短字符串组成
        // Arrays.sort(words, (s1, s2) -> (s1.length() - s2.length()));
        Arrays.sort(words, Comparator.comparingInt(String::length));
        for (String word : words) {
            // 跳过空字符串
            if (word.length() == 0) {
                continue;
            }
            // 对于每一个 word, 在 dfs 前, 该 word 并没有被添加到字典树中
            // 如果该 word 可由字典树中的多个较短字符串组成, 即返回为 true, 则说明该 word 为连接词, 连接词不加入到字典树中, 保存到结果链表
            // 如果该 word 不由字典树中的多个较短字符串组成, 即返回为 false, 则说明该 word 不为连接词, 那么则需要将其加入到字典树中(可能后续遍历判断的 word 是由该字符串组成的连接词)
            if (dfs(trie, word, 0)) {
                ans.add(word);
            } else {
                trie.insert(word);
            }
        }
        return ans;
    }

    private boolean dfs(P472_Trie trie, String word, int start) {
        P472_Trie node = trie;
        int index;
        for (int i = start; i < word.length(); i++) {
            index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                return false;
            }
            node = node.children[index];
            if (node.isEnd) {
                if (i == word.length() - 1) {
                    return true;
                }
                // 判断子串是否可由已存在字典树中的较短字符串组成
                if (dfs(trie, word, i + 1)) {
                    return true;
                }
            }
        }

        return false;
    }
}

class P472_Trie {
    P472_Trie[] children;
    boolean isEnd;

    public P472_Trie() {
        children = new P472_Trie[26];
        isEnd = false;
    }

    public void insert(String word) {
        P472_Trie node = this;
        int index;
        for (int i = 0; i < word.length(); i++) {
            index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                node.children[index] = new P472_Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
}
```

##### 字典树 + 深度优先搜索（递归实现） + 记忆化搜索

```java
// 字典树 + 深度优先搜索（递归实现） + 记忆化搜索
class P472_Solution {
    P472_Trie trie = new P472_Trie();

    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<>();

        // 注意最终的字典树 Trie 中并不包含连接词, 即不将连接词加入到字典树中
        // 将 words 中的 word 按照长度从小到大排序, 将较短的 word 加入到字典树中, 判断较长的是否由已加入到字典树中的较短字符串组成
        // Arrays.sort(words, (s1, s2) -> (s1.length() - s2.length()));
        Arrays.sort(words, Comparator.comparingInt(String::length));
        for (String word : words) {
            // 跳过空字符串
            if (word.length() == 0) {
                continue;
            }

            boolean[] visited = new boolean[word.length()];
            // 对于每一个 word, 在 dfs 前, 该 word 并没有被添加到字典树中
            // 如果该 word 可由字典树中的多个较短字符串组成, 即返回为 true, 则说明该 word 为连接词, 连接词不加入到字典树中, 保存到结果链表
            // 如果该 word 不由字典树中的多个较短字符串组成, 即返回为 false, 则说明该 word 不为连接词, 那么则需要将其加入到字典树中(可能后续遍历判断的 word 是由该字符串组成的连接词)
            if (dfs(word, 0, visited)) {
                ans.add(word);
            } else {
                trie.insert(word);
            }
        }
        return ans;
    }

    private boolean dfs(String word, int start, boolean[] visited) {
        if (start == word.length()) {
            return true;
        }
        if (visited[start]) {
            return false;
        }
        visited[start] = true;

        P472_Trie node = trie;
        int index;
        for (int i = start; i < word.length(); i++) {
            index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                return false;
            }
            node = node.children[index];
            if (node.isEnd) {
                // 判断子串是否可由已存在字典树中的较短字符串组成
                if (dfs(word, i + 1, visited)) {
                    return true;
                }
            }
        }

        return false;
    }
}

class P472_Trie {
    P472_Trie[] children;
    boolean isEnd;

    public P472_Trie() {
        children = new P472_Trie[26];
        isEnd = false;
    }

    public void insert(String word) {
        P472_Trie node = this;
        int index;
        for (int i = 0; i < word.length(); i++) {
            index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                node.children[index] = new P472_Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
}
```



#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

##### 回溯

```java
// 回溯
class P494_Solution1 {
    int[] nums;
    int len;
    int count = 0;

    public int findTargetSumWays(int[] nums, int target) {
        // 可删除
        if (nums == null) {
            return 0;
        }
        this.nums = nums;
        this.len = nums.length;
        // 可删除, 特殊情况, nums 长度为 0,
        // target 也为 0, 返回 1; 不为 0, 返回 0
        if (len == 0) {
            if (target == 0) {
                return 1;
            }
            return 0;
        }
        // 特殊情况, nums 长度为 1
        if (len == 1) {
            if (nums[0] == target || nums[0] == -target) {
                return 1;
            }
            return 0;
        }

        dfs(0, 0, target);
        return count;
    }

    public void dfs(int index, int sum, int target) {
        // 结束
        if (index == len) {
            // 相等, 找到一个表达式
            if (sum == target) {
                count++;
            }
            return;
        }

        // 两个分支
        // 前 index 个数组成的表达式子的和 sum
        // 在此处可能加上或者减去 nums[index]
        dfs(index + 1, sum + nums[index], target);
        dfs(index + 1, sum - nums[index], target);
    }
}
```

##### 动态规划

> 此处对dp数组进行了降维(滚动数组思想)

```java
// 动态规划 一维 dp 数组(滚动数组思想)
class P494_Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 可删除
        if (nums == null) {
            return 0;
        }
        int len = nums.length;
        // 可删除, 特殊情况, nums 长度为 0,
        // target 也为 0, 返回 1; 不为 0, 返回 0
        if (len == 0) {
            if (target == 0) {
                return 1;
            }
            return 0;
        }
        // 特殊情况, nums 长度为 1
        if (len == 1) {
            if (nums[0] == target || nums[0] == -target) {
                return 1;
            }
            return 0;
        }

        // 数组和
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }

        // 将问题转换为在 nums 数组中找到几个数的和为 neg 的方案数
        int neg = diff / 2;

        // 动态规划数组
        // 列 j 表示在这 i 个数中找到若干个数的和为 j 的方案数
        int[] dp = new int[neg + 1];

        // 0 <= nums[i] <= 1000
        // 赋初值
        dp[0] = 1;

        // 需要仔细思考, 相比较于正向遍历, 反向遍历的循环次数更少
        // 并且正向遍历会出错, 因为 j 更大时会用到之前一次 i 循环中 j 更小时的一些数据
        // 如果循环是正向从前往后遍历的, 那么在遍历到更大的 j 时, dp[j - nums[i - 1]] 可能已经在此次 i 循环中已经被更改了,
        // 而不是上一次 i - 1 循环结束时保存的值
        for (int num : nums) {
            for (int j = neg; j >= num; j--) {
                // 此次进入循环时 dp[j] 为在前 i - 1 个数中选择若干个数的和为 j 的方案数(dp[j]), 即不选择这第 i 个数 nums[i - 1]
                // 并且此时肯定 j >= nums[i - 1], 说明可以选择这个数了, 就再加上这种情况的方案数 dp[j - nums[i - 1]]
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```



#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```java
class P509_Solution {
    // 动态规划 时间复杂度O(n) 空间复杂度O(n)
    public int fib(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    // 动态规划 对上方法的代码优化
    // 滚动数组思想, 时间复杂度O(n) 空间复杂度O(1)
    public int fib1(int n) {
        if (n < 2) {
            return n;
        }
        int[] dp = new int[3];
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            dp[2] = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
    
    // 递归 消耗最大
    public int fib2(int n) {
        if (n < 2) {
            return n;
        }
        return fib2(n - 1) + fib2(n - 2);
    }
}
```

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

##### 动态规划

```java
class P516_Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // 字符 i 到字符 j 之间的最长回文子序列的长度
        int[][] dp = new int[n][n];
        // 初始化 dp, 得到长度为 1 和 2 的回文子序列(长度为 2 的是连续的)
        for (int i = 0; i <= n - 2; i++) {
            // i 到 i, 为回文子序列, 长度为 1
            dp[i][i] = 1;
            // i 到 i+1,
            // 如果相等, 则是回文子序列, 长度为 2;
            // 如果不相等, 则不是回文子序列, 但最长的回文子序列长度为 1
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = 2;
            } else {
                dp[i][i + 1] = 1;
            }
        }
        dp[n - 1][n - 1] = 1;

        // 长度为 subLen(3 到 n) 的子串的最长回文子序列的长度
        for (int subLen = 3; subLen <= n; subLen++) {
            // 遍历每一个长度为 subLen 的子串(下标 i -> j), 计算其最长回文子序列的长度
            for (int i = 0; i <= n - subLen; i++) {
                int j = i + subLen - 1;
                if (s.charAt(i) == s.charAt(j)) {
                    // 如果 i j 处的字符相等, 那么其最长回文子序列的长度为 (i+1 -> j-1) 之间的子串的最长回文子序列的长度 + 2
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 如果不相等, 那么其最长回文子序列的长度为
                    // (i -> j) 这个长度为 subLen 的子串中的两个长度为 subLen-1 的两个子串中的最长回文子序列的长度中的较大值
                    // 长度为 subLen-1 的两个子串下标为 (i -> j-1) 与 (i+1 -> j),
                    // 其对应的最长回文子序列的长度为 dp[i][j - 1] 与 dp[i + 1][j]
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }

        return dp[0][n - 1];
    }
}
```



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

```java
// 二维动态规划
class P518_Solution1 {
    // 二维动态规划
    public int change1(int amount, int[] coins) {
        // 特殊情况处理
        if (amount == 0) {
            return 1;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return 1;
            } else {
                return 0;
            }
        }
//        // 可有可无
//        // 先对 coins 排序, 减少循环次数
//        Arrays.sort(coins);
//
//        // 特殊情况处理: 如果金额比最小的一枚硬币还小, 则找不到(前提是 amount > 0)
//        if (amount < coins[0]) {
//            return 0;
//        }
        // 二维动态规划
        // 行表示有 0 种, 1 种, 2 种, ..., n 种硬币, 每种硬币的价值保存在 coins[] 数组中, 共 n + 1 行
        // 列表示要凑成的金额为 0, 1, 2, ..., amount, 共 amount + 1 列
        // dp[i][j] 表示当有 i 种硬币时, 需要把这 i 种硬币凑出金额为 j 的组合数
        int[][] dp = new int[n + 1][amount + 1];
        // 对特殊情况下的 dp数组 进行初始化赋值, 一般是 i 或 j 为 0 的初始情况
        // 首先, 考虑 dp[0][0], 0 种硬币凑成金额为 0 的组合数? 是多少呢? 为 1 对吧?
        // 然后, 判断第一行, 第一行表示 0 种硬币凑成金额为 j(j 在 0 到 amount 之间) 的组合数?
        // 好像除了能凑出金额 0 之外, 凑不出其它金额了吧? 故第一行除了 dp[0][0] 为 1, 其余均为 0
        // 最后, 判断第一列, 第一列表示可能有若干种硬币要凑成金额为 0 的组合数? 每种情况都可以吧, 组合数为 1
        // 于是, 第一列全为 1
        // 当然这个赋初值, 可以放到真正循环确定二维dp数组值时赋值也是可以的, 还减少了在此处赋值的循环次数
        for (int i = 0; i < n + 1; i++) {
            dp[i][0] = 1;
        }

        // 依次遍历得到有 i 种硬币时, 凑成金额为 j 的组合数 dp[i][j], 那么这个 dp[i][j] 是多少呢? 分两种情况:
        // 1.在上一次循环中, 当没有第 i 种硬币时, 即当只有前 i - 1 种硬币时, 它凑成金额为 j 的组合数为 dp[i - 1][j], dp[i][j] 肯定是要包含它的对吧?
        // 2.当肯定有第 i 种硬币(至少一枚, 金额为 coins[i - 1])时, 这种情况的组合数值就等价于
        // 要从这 i 种硬币中 凑成金额为 j - coins[i - 1] 的组合数, 其值为 dp[i][j - coins[i - 1]]
        // 但是在此处, 应该要特别注意当前要凑成的金额数 j 与 第 i 种硬币的价值大小(coins[i - 1])
        // 如果 j < coins[i - 1], 那么这种情况根本不能存在啊
        // 就比如: 第 i 种硬币的价值是 5, 现在拿它和前面的 i - 1 种硬币去凑出金额为 4 或者比 4 小的一定要包含 5 这种硬币的组合, 这显然不可能嘛
        // 于是乎, 在这种情况下的 dp[i][j] 值就为 dp[i - 1][j], 第二种情况的值为 0
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < amount + 1; j++) {
                if (j >= coins[i - 1]) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        // 最终 dp[n][amount] 就为 n 种硬币凑成金额为 amount 的组合数
        return dp[n][amount];
    }

    // 二维动态规划 代码简化
    public int change(int amount, int[] coins) {
        // 特殊情况处理
        if (amount == 0) {
            return 1;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return 1;
            } else {
                return 0;
            }
        }
        // 二维动态规划
        // 行表示有 0 种, 1 种, 2 种, ..., n 种硬币, 每种硬币的价值保存在 coins[] 数组中, 共 n + 1 行
        // 列表示要凑成的金额为 0, 1, 2, ..., amount, 共 amount + 1 列
        // dp[i][j] 表示当有 i 种硬币时, 需要把这 i 种硬币凑出金额为 j 的组合数
        int[][] dp = new int[n + 1][amount + 1];
        // 对特殊情况下的 dp数组 进行初始化赋值, 一般是 i 或 j 为 0 的初始情况
        // 首先, 考虑 dp[0][0], 0 种硬币凑成金额为 0 的组合数? 是多少呢? 为 1 对吧?
        // 然后, 判断第一行, 第一行表示 0 种硬币凑成金额为 j(j 在 0 到 amount 之间) 的组合数?
        // 好像除了能凑出金额 0 之外, 凑不出其它金额了吧? 故第一行除了 dp[0][0] 为 1, 其余均为 0
        // 最后, 判断第一列, 第一列表示可能有若干种硬币要凑成金额为 0 的组合数? 每种情况都可以吧, 组合数为 1
        // 于是, 第一列全为 1
        // 当然这个赋初值, 可以放到真正循环确定二维dp数组值时赋值也是可以的, 还减少了在此处赋值的循环次数
//        for (int i = 0; i < n + 1; i++) {
//            dp[i][0] = 1;
//        }

        // 依次遍历得到有 i 种硬币时, 凑成金额为 j 的组合数 dp[i][j], 那么这个 dp[i][j] 是多少呢? 分两种情况:
        // 1.在上一次循环中, 当没有第 i 种硬币时, 即当只有前 i - 1 种硬币时, 它凑成金额为 j 的组合数为 dp[i - 1][j], dp[i][j] 肯定是要包含它的对吧?
        // 2.当肯定有第 i 种硬币(至少一枚, 金额为 coins[i - 1])时, 这种情况的组合数值就等价于
        // 要从这 i 种硬币中 凑成金额为 j - coins[i - 1] 的组合数, 其值为 dp[i][j - coins[i - 1]]
        // 但是在此处, 应该要特别注意当前要凑成的金额数 j 与 第 i 种硬币的价值大小(coins[i - 1])
        // 如果 j < coins[i - 1], 那么这种情况根本不能存在啊
        // 就比如: 第 i 种硬币的价值是 5, 现在拿它和前面的 i - 1 种硬币去凑出金额为 4 或者比 4 小的一定要包含 5 这种硬币的组合, 这显然不可能嘛
        // 于是乎, 在这种情况下的 dp[i][j] 值就为 dp[i - 1][j], 第二种情况的值为 0
        for (int i = 1; i < n + 1; i++) {
            dp[i][0] = 1;
            for (int j = 1; j < amount + 1; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= coins[i - 1]) {
                    dp[i][j] += dp[i][j - coins[i - 1]];
                }
            }
        }
        // 最终 dp[n][amount] 就为 n 种硬币凑成金额为 amount 的组合数
        return dp[n][amount];
    }
}

// 一维动态规划(滚动数组思想)
class P518_Solution {
    public int change(int amount, int[] coins) {
        // 特殊情况处理
        if (amount == 0) {
            return 1;
        }
        int n = coins.length;
        // 特殊情况处理
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            if (amount % coins[0] == 0) {
                return 1;
            } else {
                return 0;
            }
        }

        // 一维动态规划
        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int i = 1; i < n + 1; i++) {
            for (int j = coins[i - 1]; j < amount + 1; j++) {
                dp[j] += dp[j - coins[i - 1]];
            }
        }

        // 最终 dp[amount] 就为 n 种硬币凑成金额为 amount 的组合数
        return dp[amount];
    }
}
```

#### [539. 最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

##### 基本操作（排序、鸽笼原理）

```java
// 排序
class P539_Solution {
    // 4 ms 额外使用 O(N) 空间
    public int findMinDifference1(List<String> timePoints) {
        int n = timePoints.size();
        int[] timeArr = new int[n];
        // 将字符格式 "HH:MM" 的时间映射为整形保存
        for (int i = 0; i < n; i++) {
            timeArr[i] = Integer.parseInt(timePoints.get(i).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(i).substring(3, 5));
        }
        // 对所有时间排序
        Arrays.sort(timeArr);
        // 最小时间差
        int minTimeDiff = Integer.MAX_VALUE;
        // 当前时间与前一个时间的差值与历史最小时间差比较, 得到当前最小时间差
        for (int i = 1; i < n; i++) {
            int timeDiff = timeArr[i] - timeArr[i - 1];
            if (timeDiff == 0) {
                return 0;
            }
            minTimeDiff = Math.min(minTimeDiff, timeDiff);
        }
        // 对于最后的这个最大的时间, 它与第一个时间的差值可能比与前一个时间的差值更小
        minTimeDiff = Math.min(minTimeDiff, timeArr[0] + 24 * 60 - timeArr[n - 1]);
        return minTimeDiff;
    }

    // 本想着对上一个代码进行空间优化, 不用自己再创建一个整形时间集合
    // 虽然空间节省了一些, 但是由于是对字符串排序, 因此在时间消耗上比上者多
    // 9 ms
    public int findMinDifference2(List<String> timePoints) {
        // 对所有时间排序
        Collections.sort(timePoints);
        int n = timePoints.size();
        // 第一个时间
        final int firstTime = Integer.parseInt(timePoints.get(0).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(0).substring(3, 5));
        // preTime 保存前一个时间, 初始化为第一个时间
        int preTime = firstTime;
        int curTime, timeDiff;
        // 最小时间差
        int minTimeDiff = Integer.MAX_VALUE;
        // 当前时间与前一个时间的差值与历史最小时间差比较, 得到当前最小时间差
        for (int i = 1; i < n; i++) {
            curTime = Integer.parseInt(timePoints.get(i).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(i).substring(3, 5));
            timeDiff = curTime - preTime;
            if (timeDiff == 0) {
                return 0;
            }
            minTimeDiff = Math.min(minTimeDiff, timeDiff);
            preTime = curTime;
        }
        // 对于最后的这个最大的时间, 它与第一个时间的差值可能比与前一个时间的差值更小
        minTimeDiff = Math.min(minTimeDiff, firstTime + 24 * 60 - preTime);
        return minTimeDiff;
    }

    // 上面两个方法和代码实现和官方很相似, 结合官方的计算时间整形值的方式, 对上两个方法进行修改
    // 经过测试 1 和 2, 使用 getMinutes() 方法将字符格式 "HH:MM" 的时间转变为整形, 更快
    // 测试 1 :  2 ms 减小时间和空间
    public int findMinDifference1_1(List<String> timePoints) {
        int n = timePoints.size();
        int[] timeArr = new int[n];
        // 将字符格式 "HH:MM" 的时间映射为整形保存
        for (int i = 0; i < n; i++) {
            timeArr[i] = getMinutes(timePoints.get(i));
        }
        // 对所有时间排序
        Arrays.sort(timeArr);
        // 最小时间差
        int minTimeDiff = Integer.MAX_VALUE;
        // 当前时间与前一个时间的差值与历史最小时间差比较, 得到当前最小时间差
        for (int i = 1; i < n; i++) {
            int timeDiff = timeArr[i] - timeArr[i - 1];
            if (timeDiff == 0) {
                return 0;
            }
            minTimeDiff = Math.min(minTimeDiff, timeDiff);
        }
        // 对于最后的这个最大的时间, 它与第一个时间的差值可能比与前一个时间的差值更小
        minTimeDiff = Math.min(minTimeDiff, timeArr[0] + 24 * 60 - timeArr[n - 1]);
        return minTimeDiff;
    }

    // 测试 2 : 9 ms 只减小空间
    public int findMinDifference1_2(List<String> timePoints) {
        // 对所有时间排序
        Collections.sort(timePoints);
        int n = timePoints.size();
        // 第一个时间
        final int firstTime = getMinutes(timePoints.get(0));
        // preTime 保存前一个时间, 初始化为第一个时间
        int preTime = firstTime;
        int curTime, timeDiff;
        // 最小时间差
        int minTimeDiff = Integer.MAX_VALUE;
        // 当前时间与前一个时间的差值与历史最小时间差比较, 得到当前最小时间差
        for (int i = 1; i < n; i++) {
            curTime = getMinutes(timePoints.get(i));
            timeDiff = curTime - preTime;
            if (timeDiff == 0) {
                return 0;
            }
            minTimeDiff = Math.min(minTimeDiff, timeDiff);
            preTime = curTime;
        }
        // 对于最后的这个最大的时间, 它与第一个时间的差值可能比与前一个时间的差值更小
        minTimeDiff = Math.min(minTimeDiff, firstTime + 24 * 60 - preTime);
        return minTimeDiff;
    }

    // 鸽笼原理(我真是服了这个)
    // 1 : 2 ms -> 1 ms 37.6 MB
    // 理论上的时间复杂度 O(min(n,C)log min(n,C)) C=24×60=1440
    // 空间复杂度 O(min(n,C)), 注意, 不是 O(log min(n,C))
    public int findMinDifference3(List<String> timePoints) {
        int n = timePoints.size();
        // 一共有 24×60=1440 种不同的时间
        // 由鸽巢原理可知, 如果 timePoints 的长度超过 1440, 那么必然会有两个相同的时间, 此时可以直接返回 0
        if (n > 1440) {
            return 0;
        }
        int[] timeArr = new int[n];
        // 将字符格式 "HH:MM" 的时间映射为整形保存
        for (int i = 0; i < n; i++) {
            timeArr[i] = getMinutes(timePoints.get(i));
        }
        // 对所有时间排序
        Arrays.sort(timeArr);
        // 最小时间差
        int minTimeDiff = Integer.MAX_VALUE;
        // 当前时间与前一个时间的差值与历史最小时间差比较, 得到当前最小时间差
        for (int i = 1; i < n; i++) {
            // 相邻时间的时间差
            int timeDiff = timeArr[i] - timeArr[i - 1];
            if (timeDiff == 0) {
                return 0;
            }
            minTimeDiff = Math.min(minTimeDiff, timeDiff);
        }
        // 首尾时间的时间差
        // 对于最后的这个最大的时间, 它与第一个时间的差值可能比与前一个时间的差值更小
        minTimeDiff = Math.min(minTimeDiff, timeArr[0] + 24 * 60 - timeArr[n - 1]);
        return minTimeDiff;
    }

    // 2 : 9 ms -> 2 ms 37.4 MB
    // 理论上的时间复杂度 O(min(n,C)log min(n,C)) C=24×60=1440
    // 空间复杂度 这次是 O(log min(n,C))
    public int findMinDifference(List<String> timePoints) {
        int n = timePoints.size();
        // 一共有 24×60=1440 种不同的时间
        // 由鸽巢原理可知, 如果 timePoints 的长度超过 1440, 那么必然会有两个相同的时间, 此时可以直接返回 0
        if (n > 1440) {
            return 0;
        }
        // 对所有时间排序
        Collections.sort(timePoints);
        // 第一个时间
        final int firstTime = getMinutes(timePoints.get(0));
        // preTime 保存前一个时间, 初始化为第一个时间
        int preTime = firstTime;
        int curTime, timeDiff;
        // 最小时间差
        int minTimeDiff = Integer.MAX_VALUE;
        // 当前时间与前一个时间的差值与历史最小时间差比较, 得到当前最小时间差
        for (int i = 1; i < n; i++) {
            curTime = getMinutes(timePoints.get(i));
            // 相邻时间的时间差
            timeDiff = curTime - preTime;
            if (timeDiff == 0) {
                return 0;
            }
            minTimeDiff = Math.min(minTimeDiff, timeDiff);
            preTime = curTime;
        }
        // 首尾时间的时间差
        // 对于最后的这个最大的时间, 它与第一个时间的差值可能比与前一个时间的差值更小
        minTimeDiff = Math.min(minTimeDiff, firstTime + 24 * 60 - preTime);
        return minTimeDiff;
    }

    public int getMinutes(String t) {
        return ((t.charAt(0) - '0') * 10 + (t.charAt(1) - '0')) * 60 + (t.charAt(3) - '0') * 10 + (t.charAt(4) - '0');
    }
}
```

#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

##### 二分查找

###### 我的实现

```java
// 二分查找 0ms
// 官方解法很神奇, 代码量也少了很多, 暂时不看了
class P540_Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        int left = 0;
        int mid;
        int right = n - 1;
        while (left <= right) {
            // 首先可以保证每次循环时子数组长度 right - left + 1 是奇数
            mid = left + (right - left) / 2;
            // 只有一个数时直接返回, 此时的 left mid right 相等
            if (right - left == 0) {
                return nums[mid];
            }
            // 由于总长度是奇数, mid 肯定位于最中间位置, 当它与它两边的数都不想等时, 它就是这个 singleNumber
            if (nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1]) {
                return nums[mid];
            }
            // 然后根据当前 mid 是奇数还是偶数, 也就是两边的数字的个数以及与其左边还是右边的数相等来判断
            if (mid % 2 == 0) {
                if (nums[mid] == nums[mid - 1]) {
                    right = mid - 2;
                } else if (nums[mid] == nums[mid + 1]) {
                    left = mid + 2;
                }
            } else {
                if (nums[mid] == nums[mid - 1]) {
                    left = mid + 1;
                } else if (nums[mid] == nums[mid + 1]) {
                    right = mid - 1;
                }
            }
        }
        // System.out.println("永不会执行到这里");
        return 0;
    }
}
```

###### 官方实现

#### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

##### 深度优先搜索（递归实现）

> **复杂度分析**
>
> - 时间复杂度：O(n)，其中 n 为二叉树中结点总数。我们需要遍历每一个结点。
>
>
> - 空间复杂度：O(n)。在最坏情况下， 当树为线性二叉树（即所有结点都只有左子结点或没有结点）时，树的高度为 n - 1，在递归时我们需要存储 n 个结点。
>

```java
class P563_Solution {

    int tilt = 0;

    public int findTilt(TreeNode root) {
        if (root == null) {
            return 0;
        }

        getTreeSum(root);

        return tilt;
    }

    public int getTreeSum1(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int leftTreeSum = 0;
        int rightTreeSum = 0;

        if (node.left != null) {
            // 左子树的和
            leftTreeSum = getTreeSum(node.left);

        }
        if (node.right != null) {
            // 右子树的和
            rightTreeSum = getTreeSum(node.right);

        }
        // tilt 加上 node 结点的坡度, 遍历完所有结点, tilt 就是整棵树的坡度
        tilt += Math.abs(leftTreeSum - rightTreeSum);

        // 返回值是 node 这棵树的所有结点值的和
        return leftTreeSum + rightTreeSum + node.val;
    }

    // 代码简化
    public int getTreeSum(TreeNode node) {
        if (node == null) {
            return 0;
        }
        // 左子树的和
        int leftTreeSum = getTreeSum(node.left);

        // 右子树的和
        int rightTreeSum = getTreeSum(node.right);

        // tilt 加上 node 结点的坡度, 遍历完所有结点, tilt 就是整棵树的坡度
        tilt += Math.abs(leftTreeSum - rightTreeSum);

        // 返回值是 node 这棵树的所有结点值的和
        return leftTreeSum + rightTreeSum + node.val;
    }
}
```

#### [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)

##### 枚举

```java
// 枚举
// 时间复杂度 O(NLogN) 空间复杂度 O(N)
class P594_Solution {
    public int findLHS(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return 0;
        }
        Arrays.sort(nums);
        // begin 第一个子序列的头
        // next 第二个子序列的头
        int begin = 0, next = 0;
        boolean bl = false;
        int ans = 0;
        // end 第二个子序列的尾
        for (int end = 1; end < n; end++) {
            if (nums[end] == nums[begin]) {
                continue;
            }
            if (nums[end] - nums[begin] > 1) {
                if (nums[end] - nums[next] == 1) {
                    begin = next;
                    next = end;
                } else {
                    begin = end;
                    next = end;
                    bl = false;
                }
            }
            if (nums[end] - nums[begin] == 1) {
                ans = Math.max(ans, end - begin + 1);
                if (!bl) {
                    next = end;
                    bl = true;
                }
            }
        }
        return ans;
    }
}
```

##### 哈希表

```java
// 哈希表
// 理论上的时间复杂度 O(N) 空间复杂度 O(N), 但是效率却不及枚举的 O(NLogN)
class P594_Solution1 {
    public int findLHS(int[] nums) {
        // 记录各个数字出现的次数
        HashMap<Integer, Integer> cnt = new HashMap<>();
        int res = 0;
        for (int num : nums) {
            cnt.put(num, cnt.getOrDefault(num, 0) + 1);
        }
        for (int key : cnt.keySet()) {
            if (cnt.containsKey(key + 1)) {
                res = Math.max(res, cnt.get(key) + cnt.get(key + 1));
            }
        }
        return res;
    }
}
```



#### [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)

##### 贪心算法

```java
// 堆(优先队列) + 贪心算法
class P630_Solution {
    public int scheduleCourse(int[][] courses) {
        // 以截止时间 lastDay 排序
        // Arrays.sort(courses, (a, b) -> a[1] - b[1]);
        Arrays.sort(courses, Comparator.comparingInt(a -> a[1]));

        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a);
        // 优先队列中所有课程的总时间
        int total = 0;
        // duration, lastDay;
        int ti, di;
        for (int[] course : courses) {
            ti = course[0];
            di = course[1];
            // 假设此时队列中已有 k 门课程, 这 k 门课程总学习时间为 total
            if (total + ti <= di) {
                // 如果要将课程 i 添加进队列, 那么这 k+1 门课程的总学习时间(total + ti)则不能超过课程 i 的截止时间
                // 如果满足此条件, 说明可以将课程 i 添加进队列
                // 更新这总学习时间 total = total + ti;
                total += ti;
                queue.offer(ti);
            } else if (!queue.isEmpty() && queue.peek() > ti) {
                // 如果要将课程 i 添加进队列, 而总学习时间(total + ti)超过了课程 i 的截止时间
                // 说明课程 i 不能这样直接添加进队列, 使得队列中有 k+1 门课程
                // 此时需要判断如果队列中(k 门课程中)需要耗时学习时间最多的课程(设为 x)的学习时间比课程 i 学习时间多
                // 那么我们可以贪心地将这两门课程交换, 也就是将这课程 x 从队列中取出, 将课程 i 添加队列, 形成新的 k 门课程组合
                // 此时这新的 k 门课程组合的总的学习时间(total - tx + ti) 肯定小于 d(i-1) , 也小于等于 di
                // 即此时的新的 k 门课程组合比之上一次的 k 门课程组合, 不仅总学习时间减少, 连截至时间也延长了, 也就更有可能学习更多的课程
                total -= queue.poll() - ti;
                queue.offer(ti);
            }
        }
        // 最后队列的大小, 即为最多可以修读的课程数目
        return queue.size();
    }
}
```



#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

##### 动态规划

> **复杂度分析**
>
> - 时间复杂度：O(n^2)，其中 *n* 是数组 *nums* 的长度。
> - 空间复杂度：O(n)。

```java
// 动态规划
class P673_Solution1 {
    // 动态规划
    public int findNumberOfLIS0(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 最长递增子序列的长度
        int maxLen = 1;
        // 最长递增子序列的个数
        int maxNum = 1;
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的长度
        int[] dp = new int[n];
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的个数
        int[] cnt = new int[n];
        // 赋初值: 以 nums[0] 结尾的最长子序列的长度为 1
        dp[0] = 1;
        // 赋初值: 以 nums[0] 结尾的最长子序列的个数为 1
        cnt[0] = 1;
        // 从 i == 1 开始
        for (int i = 1; i < n; i++) {
            // 在 [0,i) 之间找到比当前 nums[i] 小的那个数, 假设有 x 个这样的数
            // 那么 dp[i] 也就等于以这 x 个这样的数结尾的最长子序列长度的最大值 + 1
            // 也就是找到一条 i 之前的最长子序列, 并且该最长子序列的结尾值要 nums[j] < nums[i]
            // 那么现在加上 nums[i] 这个数, 就有了一条以 nums[i] 结尾的最长子序列
            // 同时也知道了其长度值, 更新 dp[i]
            // 那么当循环结束时, 就知道了以这 n 个数结尾的最长子序列的长度, 最长长度就很轻松就能得到

            // 而这最长长度的子序列有多少个呢?
            // 不就是遍历 dp数组, 找到 dp[i] 等于 maxLen 的个数吗?
            // 以上这两行的想法是错误的

            // 以上讨论的是找得到的情况, 如果找不到呢?
            // 找不到不就说明当前 nums[i] 是 [0,i] 之间这 i + 1 个数中的最大值吗?
            // 那么 nums[i] 就成为了一条新的子序列的开头(也即末尾), 当前序列长度就为 1 了
            // 故在查找前, 先令其为 1, 后续如果找到, 肯定值比 1 大

            // 以 nums[i] 结尾的最长子序列的长度为 1
            dp[i] = 1;
            // 以 nums[i] 结尾的最长子序列的个数为 1
            cnt[i] = 1;
            for (int j = 0; j < i; j++) {
                // 如果是非严格单调递增, 改为 <= 即可
                if (nums[j] < nums[i]) {
                    // dp[i] = Math.max(dp[i], dp[j] + 1);
                    // 如果 dp[j] + 1 > dp[i], 说明以 nums[j] 结尾的这条序列的长度更长
                    // 更新此可最大长度 dp[i] 为 dp[j] + 1;
                    // 以 nums[i] 结尾的最长子序列的个数 cnt[i] 也就是 以 nums[j] 结尾的最长子序列的个数 cnt[j];
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        cnt[i] = cnt[j];
                    } else if (dp[j] + 1 == dp[i]) {
                        // 如果又遇到 cnt[j] 条长度为 dp[j](dp[j] == dp[i] - 1) 的最长子序列
                        // 那么说明现在又多了 cnt[j] 条以 nums[j] 结尾的不同序列 加上 nums[i] 能得到
                        // 长度为 dp[i] == dp[j] + 1 的以 nums[i] 结尾的子序列
                        // 更新 cnt[i] 值
                        cnt[i] += cnt[j];
                    }
                }
            }

            // 每次得到以 nums[i] 结尾的最长子序列长度及其序列条数, 就与之前的 maxLen 比较
            // 得到 [0,i] 之间以这 i + 1 个数结尾的最长子序列长度中的最大值以及有当前最长长度 maxLen 的子序列的条数
            // 以 nums[i] 结尾的子序列的长度比曾经的 maxLen 大, 更新 maxLen 为 dp[i]
            // 更新 maxNum 为 cnt[i], 表示当前有最长长度 maxLen 的子序列的条数
            // maxLen = Math.max(maxLen, dp[i]);
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                maxNum = cnt[i];
            } else if (dp[i] == maxLen) {
                // 如果刚好相等, 说明又多了 cnt[j] 种不同方式(不同条序列), 也能得到长度为 maxLen 的子序列
                maxNum += cnt[i];
            }
        }

        // System.out.println(Arrays.toString(dp));
        return maxNum;
    }

    // 动态规划
    // 循环遍历从 0 开始, 有些初值就不需要特殊赋值了
    // 也是 官方写法
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // 最长递增子序列的长度
        int maxLen = 0;
        // 最长递增子序列的个数
        int maxNum = 0;
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的长度
        int[] dp = new int[n];
        // 以当前第 i 个数 nums[i] 结尾的最长子序列的个数
        int[] cnt = new int[n];
        // 从 i == 0 开始
        for (int i = 0; i < n; i++) {
            // 在 [0,i) 之间找到比当前 nums[i] 小的那个数, 假设有 x 个这样的数
            // 那么 dp[i] 也就等于以这 x 个这样的数结尾的最长子序列长度的最大值 + 1
            // 也就是找到一条 i 之前的最长子序列, 并且该最长子序列的结尾值要 nums[j] < nums[i]
            // 那么现在加上 nums[i] 这个数, 就有了一条以 nums[i] 结尾的最长子序列
            // 同时也知道了其长度值, 更新 dp[i]
            // 那么当循环结束时, 就知道了以这 n 个数结尾的最长子序列的长度, 最长长度就很轻松就能得到

            // 而这最长长度的子序列有多少个呢?
            // 不就是遍历 dp数组, 找到 dp[i] 等于 maxLen 的个数吗?
            // 以上这两行的想法是错误的

            // 以上讨论的是找得到的情况, 如果找不到呢?
            // 找不到不就说明当前 nums[i] 是 [0,i] 之间这 i + 1 个数中的最大值吗?
            // 那么 nums[i] 就成为了一条新的子序列的开头(也即末尾), 当前序列长度就为 1 了
            // 故在查找前, 先令其为 1, 后续如果找到, 肯定值比 1 大

            // 以 nums[i] 结尾的最长子序列的长度为 1
            dp[i] = 1;
            // 以 nums[i] 结尾的最长子序列的个数为 1
            cnt[i] = 1;
            for (int j = 0; j < i; j++) {
                // 如果是非严格单调递增, 改为 <= 即可
                if (nums[j] < nums[i]) {
                    // dp[i] = Math.max(dp[i], dp[j] + 1);
                    // 如果 dp[j] + 1 > dp[i], 说明以 nums[j] 结尾的这条序列的长度更长
                    // 更新此可最大长度 dp[i] 为 dp[j] + 1;
                    // 以 nums[i] 结尾的最长子序列的个数 cnt[i] 也就是 以 nums[j] 结尾的最长子序列的个数 cnt[j];
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        cnt[i] = cnt[j];
                    } else if (dp[j] + 1 == dp[i]) {
                        // 如果又遇到 cnt[j] 条长度为 dp[j](dp[j] == dp[i] - 1) 的最长子序列
                        // 那么说明现在又多了 cnt[j] 条以 nums[j] 结尾的不同序列 加上 nums[i] 能得到
                        // 长度为 dp[i] == dp[j] + 1 的以 nums[i] 结尾的子序列
                        // 更新 cnt[i] 值
                        cnt[i] += cnt[j];
                    }
                }
            }

            // 每次得到以 nums[i] 结尾的最长子序列长度及其序列条数, 就与之前的 maxLen 比较
            // 得到 [0,i] 之间以这 i + 1 个数结尾的最长子序列长度中的最大值以及有当前最长长度 maxLen 的子序列的条数
            // 以 nums[i] 结尾的子序列的长度比曾经的 maxLen 大, 更新 maxLen 为 dp[i]
            // 更新 maxNum 为 cnt[i], 表示当前有最长长度 maxLen 的子序列的条数
            // maxLen = Math.max(maxLen, dp[i]);
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                maxNum = cnt[i];
            } else if (dp[i] == maxLen) {
                // 如果刚好相等, 说明又多了 cnt[j] 种不同方式(不同条序列), 也能得到长度为 maxLen 的子序列
                maxNum += cnt[i];
            }
        }

        // System.out.println(Arrays.toString(dp));
        return maxNum;
    }
}
```

##### 贪心 + 前缀和 + 二分查找

> 待后续

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> 求所有岛屿中的最大内接矩形面积 怎么做？

##### 深度优先搜索（递归实现）

> 应该被叫做递归实现？

```java
// 深度优先搜索
class P695_Solution {
    int[][] grid;

    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int maxArea = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    maxArea = Math.max(maxArea, dfs(i, j));
                }
            }
        }
        return maxArea;
    }

    public int dfs(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return 0;
        }
        // 如果该格子不是土地或者已经访问过, return 0;
        if (grid[i][j] != 1) {
            return 0;
        }
        // 标记为已访问
        grid[i][j] = 2;
        // 当前土地的面积为 1
        int area = 1;
        // 返回上下左右相邻的土地的面积
        area += dfs(i - 1, j);
        area += dfs(i + 1, j);
        area += dfs(i, j - 1);
        area += dfs(i, j + 1);
        return area;
    }
}
```

##### 深度优先搜索（栈实现）

> 参考官方

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索
class P695_Solution1 {
    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int maxArea = 0;
        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    Queue<Integer> queue = new LinkedList<>();
                    queue.add(i * n + j);
                    // 标记为已访问
                    grid[i][j] = 2;
                    // 当前面积为 1
                    area = 1;
                    int id, row, col;
                    while (!queue.isEmpty()) {
                        id = queue.poll();
                        row = id / n;
                        col = id % n;
                        // 上
                        if (row - 1 >= 0 && grid[row - 1][col] == 1) {
                            queue.add(id - n);
                            grid[row - 1][col] = 2;
                            area++;
                        }
                        // 下
                        if (row + 1 < m && grid[row + 1][col] == 1) {
                            queue.add(id + n);
                            grid[row + 1][col] = 2;
                            area++;
                        }
                        // 左
                        if (col - 1 >= 0 && grid[row][col - 1] == 1) {
                            queue.add(id - 1);
                            grid[row][col - 1] = 2;
                            area++;
                        }
                        // 右
                        if (col + 1 < n && grid[row][col + 1] == 1) {
                            queue.add(id + 1);
                            grid[row][col + 1] = 2;
                            area++;
                        }
                    }
                    // 当前遍历到的岛屿的最大面积
                    maxArea = Math.max(maxArea, area);
                }
            }
        }
        return maxArea;
    }
}
```

#### [729. 我的日程安排表 I](https://leetcode-cn.com/problems/my-calendar-i/)

##### 暴力解法

```java
// 暴力解法
class MyCalendar1 {
    List<int[]> calendar;

    public MyCalendar1() {
        calendar = new ArrayList<>();
    }

    public boolean book(int start, int end) {
        for (int[] plan : calendar) {
            // 如果新加入日程的开始时间 start 小于已在日程中的安排的结束时间
            // 并且结束时间大于已在日程中的安排的开始时间
            // 则不能添加该日程安排
            if (start < plan[1] && end > plan[0]) {
                return false;
            }
        }
        calendar.add(new int[]{start, end});
        return true;
    }
}
```

> 复杂度分析
>
> 时间复杂度：O(N^2)，*N* 指的是日常安排的数量，对于每个新的日常安排，我们检查新的日常安排是否发生冲突来决定是否可以预订新的日常安排
>
> 空间复杂度：O(n)，calendar 所使用的空间大小

##### 平衡二叉树

```java
// 平衡二叉树
class MyCalendar {
    TreeMap<Integer, Integer> calendar;

    public MyCalendar() {
        calendar = new TreeMap<>();
    }

    public boolean book(int start, int end) {
        // 返回所有开始时间小于等于 start 的日程中, 开始时间最大的那个日程的开始时间
        Integer prev = calendar.floorKey(start);
        // 返回所有开始时间大于等于 start 的日程中, 开始时间最小的那个日程的开始时间
        Integer next = calendar.ceilingKey(start);
        // 添加第一个日程时 prev == null && next == null, 直接添加, 后续的情况中两者最多只能有一个是 null
        // prev == null 时, 就要要求 end <= next
        // next == null 时, 就要要求 calendar.get(prev) <= start
        // calendar.get(prev) <= start 时, 就必须保证 next == null || end <= next
        // end <= next 时, 就必须保证 prev == null || calendar.get(prev) <= start
        if ((prev == null || calendar.get(prev) <= start) && (next == null || end <= next)) {
            calendar.put(start, end);
            return true;
        }
        return false;
    }
}
```

> 复杂度分析
>
> 时间复杂度 (Java)：O(N log N)。其中 N 是预订的日程安排数。对于每个新日程安排，我们用 O(logN) 的时间搜索该日程安排是否合法，若合法则将其插入日常安排中需要 O(1) 的时间。
>
> 时间复杂度 (Python)：最坏的情况 O(N^2)，其他情况是 O(NlogN)。对于每个新日程安排，若新日程安排合法则将新日程安排插入到二叉树中。由于此树可能不平衡，因此可能需要线性步骤来遍历每个日常安排。
>
> 空间复杂度：O(N)，数据结构所使用的空间。

#### [731. 我的日程安排表 II](https://leetcode-cn.com/problems/my-calendar-ii/)

##### 暴力解法（效率比下者高）

```java
// 暴力解法
class MyCalendarTwo1 {
    // 一重预定列表 保存所有(不会引起三重预定冲突的)日程安排
    List<int[]> calendar;
    // 二重预定列表 将当前添加到 calendar 中的重合时间段单独保存
    List<int[]> overlaps;

    public MyCalendarTwo1() {
        calendar = new ArrayList<>();
        overlaps = new ArrayList<>();
    }

    public boolean book(int start, int end) {
        // 将 start, end 与 重合的时间段 比较, 如果再次重合, 说明发生了三重预定冲突, 返回 false, 该日程不加入
        for (int[] plan : overlaps) {
            if (start < plan[1] && end > plan[0]) {
                return false;
            }
        }
        // 上一个循环中确定了该日程添加进 calendar 后不会产生三重预定冲突, 但是有可能产生二重预定冲突
        // 如果产生了, 需要将冲突片段(重合片段)加入到 overlaps 中, 因此需要遍历一次 calendar
        for (int[] plan : calendar) {
            if (start < plan[1] && end > plan[0]) {
                overlaps.add(new int[]{Math.max(start, plan[0]), Math.min(end, plan[1])});
            }
        }
        // 最后添加该日程到 calendar 中
        calendar.add(new int[]{start, end});
        return true;
    }
}
```

##### 平衡二叉树（效率不及暴力解法）

```java
// 边界计数(效率不及暴力解法)
class MyCalendarTwo {
    TreeMap<Integer, Integer> delta;

    public MyCalendarTwo() {
        delta = new TreeMap<>();
    }

    public boolean book(int start, int end) {
        // 当前欲添加的以 start 为开始时间的日程是否已存在 calendar 中, 返回以 start 为开始时间的日程的个数 startVal
        int startVal = delta.getOrDefault(start, 0);
        // 如果 startVal 等于 2, 说明现在 calendar 中已经有了两个以 start 为开始时间的日程安排,
        // 现在这个欲添加的以 start 为开始时间的日程就不能再添加进去了, 否则肯定会造成三重预定冲突
        if (startVal == 2) {
            return false;
        }
        // 当前欲添加的以 end 为结束时间的日程是否已存在 calendar 中, 返回以 end 为结束时间的日程的个数
        int endVal = delta.getOrDefault(end, 0);
        // 如果 endVal 等于 -2, 说明现在 calendar 中已经有了两个以 end 为结束时间的日程安排,
        // 现在这个欲添加的以 end 为结束时间的日程就不能再添加进去了, 否则肯定会造成三重预定冲突
        if (endVal == -2) {
            return false;
        }

        // 1 <= startVal <= 2, -2 <= endVal <= -1
        // 将这两个点添加进 delta 中, 表示将该日程添加进 calendar 中
        delta.put(start, startVal + 1);
        delta.put(end, endVal - 1);

        // 依次累计从前往后的 各个开始时间结点和结束时间结点处的值
        int active = 0;
        for (int val : delta.values()) {
            active += val;
            // 当 active 的值大于等于 3 时, 说明刚才添加进 calendar 中的日程产生了三重预定冲突, 应当将其移除, 最后返回 false
            if (active >= 3) {
                // 对于 TreeMap, 直接 put 曾经未添加前的历史值即可
                delta.put(start, startVal);
                delta.put(end, endVal);
                // 添加这两个移除代码, 一个减少 34 ms, 两个总计 68 ms
                // 如果不添加该日程, 之前添加的所有日程中, 没有以 start 为开始时间的日程或以 end 为结束时间的日程,
                // 需要在 delta 中将其移除, 减少后续添加日程时的查找和排序次数?(应该是吧)
                if (startVal == 0) {
                    delta.remove(start);
                }
                if (endVal == 0) {
                    delta.remove(end);
                }
                return false;
            }
        }
        // 循环结束, 执行到此处, 说明新添加的日程并未引起三重预定冲突, 返回 true
        return true;
    }
}
```

#### [732. 我的日程安排表 III](https://leetcode-cn.com/problems/my-calendar-iii/)

##### 平衡二叉树

```java
// 边界计数
// 没想到这么几步就做出来了? 但是这个官解的效率是真的低
// 今天不在状态, 感觉脑子笨笨的
// 摘抄的他人的思路描述
// 思路：一个日程，从 start 开始，end 结束，想象一条时间线，我们将所有日程的 start 和 end 标记到时间线上，
// 然后从起始开始遍历时间线，每遇到一个 start，我们将进行中的日程计数 加1，每遇到一个 end，将进行中的日程计数 减1.
// 这里会有个地方产生一个最大值，这个最大值就是同时进行的日程数，也就是所求的答案。
class MyCalendarThree {
    TreeMap<Integer, Integer> delta;

    public MyCalendarThree() {
        delta = new TreeMap<>();
    }

    public int book(int start, int end) {
        delta.put(start, delta.getOrDefault(start, 0) + 1);
        delta.put(end, delta.getOrDefault(end, 0) - 1);

        int active = 0, ans = 0;
        // |val| 为以某个值为 key 的开始时间或者结束时间的日程个数
        for (int val : delta.values()) {
            // active 为假设添加了这前几个较早的开始时间的日程出现的重复预订次数
            active += val;
            if (active > ans) {
                ans = active;
            }
        }
        return ans;
    }
}

/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */
```



#### [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/)

##### 栈的基本操作

```java
class P735_Solution {
    public int[] asteroidCollision(int[] asteroids) {
        // 栈
        Deque<Integer> stack = new LinkedList<>();
        for (int asteroid : asteroids) {
            twoAsteroidCollision(stack, asteroid);
        }

        // 结果数组
        int[] ans = new int[stack.size()];
        int i = 0;
        while (!stack.isEmpty()) {
            ans[i] = stack.remove();
            i++;
        }
        return ans;
    }

    // 可删, 在 while 中条件判断后发现可以不需要用 while 循环, 更改后的方法见下一个
    private void twoAsteroidCollision1(Deque<Integer> stack, int asteroid) {
        if (stack.isEmpty()) {
            stack.add(asteroid);
            return;
        }
        while (!stack.isEmpty()) {
            // 题目保证 asteroids[i] != 0
            int top = stack.peekLast();
            if (top < 0 || (top > 0 && asteroid > 0)) {
                stack.add(asteroid);
                return;
            } else if (top + asteroid == 0) {
                // stack.peek() > 0 && asteroids[i] < 0
                stack.removeLast();
                return;
            } else if (top + asteroid < 0) {
                // stack.peek() > 0 && asteroids[i] < 0
                // 正数 top 小于负数 asteroids[i] 的绝对值, 移除栈顶 top, 继续判断下一个栈顶
                stack.removeLast();
                twoAsteroidCollision1(stack, asteroid);
                return;
            } else {
                // asteroids[i] 爆炸, asteroids[i] 不入栈顶
                return;
            }
        }
    }

    // 上一个方法的逻辑和代码简化
    private void twoAsteroidCollision(Deque<Integer> stack, int asteroid) {
        if (stack.isEmpty()) {
            stack.add(asteroid);
            return;
        }

        // 题目保证 asteroids[i] != 0
        int top = stack.peekLast();
        // 栈顶小于 0 时, 不管 asteroid 大于 0 还是小于 0, 直接入栈
        // 栈顶大于 0 时, 如果 asteroid 大于 0, 说明两颗行星同向右, 直接入栈
        if (top < 0 || asteroid > 0) {
            stack.add(asteroid);
        } else if (top + asteroid == 0) {
            // 此处 top > 0 && asteroids[i] < 0
            // 两颗行星爆炸, 移除栈顶 top
            stack.removeLast();
        } else if (top + asteroid < 0) {
            // 此处 top > 0 && asteroids[i] < 0
            // 正数 top 小于负数 asteroids[i] 的绝对值, top 行星爆炸, 移除栈顶 top
            stack.removeLast();
            // 继续判断下一个栈顶与 asteroid 谁爆炸还是 asteroid 入栈
            twoAsteroidCollision(stack, asteroid);
        }/* else {
            // 正数 top 大于负数 asteroids[i] 的绝对值, asteroid 行星爆炸, asteroid 不入栈顶
            return;
        }*/
    }
}
```



#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

##### 2021.10.24

```java
class P739_Solution {
    // (1)我的暴力解法 时间复杂度 O(n^2) 空间复杂度 O(1)
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        for (int i = 0; i < len - 1; i++) {
            for (int j = i; j < len; j++) {
                // 找到一个比 temperatures[i] 大的值, 令 temperatures[i] 为距离
                if (temperatures[i] < temperatures[j]) {
                    temperatures[i] = j - i;
                    break;
                }
                // 当比较到最后一个值都比 temperatures[i] 值小, 用 0 代替
                if (j == len - 1) {
                    temperatures[i] = 0;
                }
            }
        }
        // 最后一个值最后肯定为 0
        temperatures[len - 1] = 0;
        return temperatures;
    }

    // (2)官方答案的暴力解法 时间复杂度 O(n^m) 空间复杂度 O(1), m 是数组 next 的长度
    public int[] dailyTemperatures1(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        int[] next = new int[101];
        Arrays.fill(next, Integer.MAX_VALUE);
        // 从最后一个元素往前遍历
        for (int i = len - 1; i >= 0; i--) {
            int index = Integer.MAX_VALUE;
            // 每次遍历都要遍历完所有比该温度值更大的温度可能第一次出现的位置, 取其中的最小值为 index
            for (int j = temperatures[i] + 1; j < next.length; j++) {
                if (next[j] < index) {
                    index = next[j];
                }
            }
            // 当 index < Integer.MAX_VALUE 时, 说明有比 temperatures[i] 更大的温度值, 且此时距离 temperatures[i] 最近
            if (index < Integer.MAX_VALUE) {
                ans[i] = index - i;
            } else {
                ans[i] = 0;
            }
            // 更新 i 为此温度值为第一次出现的下标
            next[temperatures[i]] = i;
        }
        return ans;
    }

    // (3)官方答案的单调栈解法(最优解法) 时间复杂度 O(n) 空间复杂度 O(n)
    public int[] dailyTemperatures2(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        // stack 栈中保存的是当前尚未找到更大的温度值的该温度值的下标
        // stack 中栈底到栈顶的各个下标对应的温度是递减的
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            int temperature = temperatures[i];
            // 当当前温度大于了栈顶的温度, 就说明之前的小的温度找到了一个离它最近的比它大的温度
            while (!stack.isEmpty() && temperature > temperatures[stack.peek()]) {
                int prevIndex = stack.poll();
                ans[prevIndex] = i - prevIndex;
            }
            // 当前温度的下标进栈
            stack.push(i);
        }
        return ans;
    }
}
```

#### [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

##### 动态规划

```java
// 动态规划
// 时间复杂度：O(N+M), 其中 N 是数组 nums 的长度, M 是 nums 中元素的最大值
// 空间复杂度：O(M)
class P740_Solution1 {
    public int deleteAndEarn(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        } else if (nums.length == 1) {
            return nums[0];
        }
        // 得到整个 nums 数组中的最大值
        int maxVal = 0;
        for (int num : nums) {
            maxVal = Math.max(maxVal, num);
        }
        // 创建 maxVal + 1 大小的数组, 保存 nums 中值等于 num 的所有数据的总和到 sum[num] 中
        int[] sum = new int[maxVal + 1];
        for (int num : nums) {
            sum[num] += num;
        }

        // 原问题就等价于 P198 打家劫舍 问题
        return rob(sum);
    }

    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[3];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[2] = Math.max(dp[0] + nums[i], dp[1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 若 return dp[2];
        // [1,1,1]、[1,1,1,1] 此测试用例不能通过
        // 即要保证 nums 的长度大于 3 或者给 dp[2] 赋初值等于 dp[1] 时, 才能 return dp[2];
        return dp[1];
    }
}

// 排序 + 动态规划 (先不做)
```



#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

##### 动态规划

```java
class P746_Solution {
    // 我的解法, 感觉还是我的好理解些
    public int minCostClimbingStairs(int[] cost) {
        // 初始化 dp[2] 为 0 或者 Math.min(cost[0], cost[1]) 均可,
        // 若初始化为 后者, 则 return 语句返回的是 Math.min(dp[0], dp[2]);
        int[] dp = new int[]{cost[0], cost[1], 0};
        // 达到第 i 个阶梯最低花费
        for (int i = 2; i < cost.length; i++) {
            // dp[2] 表示要达到第 i 个阶梯的最低花费(i 是下标), 它等于
            // 达到(第 i - 2 个阶梯的最低花费(dp[0]) 与 第 i - 1 个阶梯的最低花费(dp[1])中的较小值) + 达到第 i 个阶梯的花费(cost[i])
            dp[2] = Math.min(dp[0], dp[1]) + cost[i];
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        // 最后结束时, dp[1] 与 dp[2] 为达到最后一个(n - 1)阶梯的最低花费,
        // dp[0] 为达到第 n - 2 个阶梯的最低花费
        // 故最后返回 dp[0] 与 dp[1] 的较小值
        return Math.min(dp[0], dp[1]);
    }

    // 思维方式有些变化, 等同于官方答案
    public int minCostClimbingStairs1(int[] cost) {
        // dp[] 不需要初始化
        int[] dp = new int[]{0, 0, 0};
        for (int i = 2; i <= cost.length; i++) {
            dp[2] = Math.min(dp[0] + cost[i - 2], dp[1] + cost[i - 1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }
        return dp[2];
    }
}
```

#### [747. 至少是其他数字两倍的最大数](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/)

##### 基本操作

```java
class P747_Solution {
    public int dominantIndex1(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        } else if (n == 1) {
            return 0;
        }
        // 整个数组中最大值的索引
        int maxIndex = 0;
        // 整个数组中的第二大值的索引
        int minorMaxIndex = 0;
        // 初始化
        if (nums[1] > nums[0]) {
            maxIndex = 1;
        } else {
            minorMaxIndex = 1;
        }
        for (int i = 2; i < n; i++) {
            if (nums[i] > nums[maxIndex]) {
                minorMaxIndex = maxIndex;
                maxIndex = i;
            } else {
                // 当前 nums[i] 小于 nums[maxIndex], 但是可能是大于之前的 nums[minorMaxIndex] 的, 于是 minorMaxIndex 需要比较保存的
                if (nums[i] > nums[minorMaxIndex]) {
                    minorMaxIndex = i;
                }
            }
        }
        return nums[maxIndex] >= nums[minorMaxIndex] * 2 ? maxIndex : -1;
    }

    // 判断 minorMaxIndex == -1, 可减少开始的初始化, 但是其实每次循环都会判断这个, 是否就影响效率了?
    public int dominantIndex(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        } else if (n == 1) {
            return 0;
        }
        // 整个数组中最大值的索引
        int maxIndex = 0;
        // 整个数组中的第二大值的索引
        int minorMaxIndex = -1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[maxIndex]) {
                minorMaxIndex = maxIndex;
                maxIndex = i;
            } else {
                // 当前 nums[i] 小于 nums[maxIndex], 但是可能是大于之前的 nums[minorMaxIndex] 的, 于是 minorMaxIndex 需要比较保存的
                if (minorMaxIndex == -1 || nums[i] > nums[minorMaxIndex]) {
                    minorMaxIndex = i;
                }
            }
        }
        return nums[maxIndex] >= nums[minorMaxIndex] * 2 ? maxIndex : -1;
    }
}
```



#### [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)

##### 暴力解法

```java
// 我的暴力解法, 效率极低 O(n^2)
class P825_Solution1 {
    public int numFriendRequests(int[] ages) {
        Arrays.sort(ages);
        double condition;
        int numRequests = 0;
        // 0.5 × ages[x] + 7 < ages[y] ≤ ages[x]
        for (int i = ages.length - 1; i >= 0; i--) {
            if (ages[i] <= 14) {
                break;
            }
            condition = ages[i] * 0.5 + 7;
            for (int j = i - 1; j >= 0; j--) {
                // 由于已经排序了, 三个条件中的第二三两个条件不必考虑了
                // 如果 ages[j] <= condition, i 不能向 j 发
                if (ages[j] <= condition) {
                    // 起初是 continue; 会超时
                    // continue;
                    // 根据题意, 改为 break; 就不超时了, 但是效率很低下
                    break;
                }
                numRequests++;
                // 如果 ages[i] == ages[j], j 也可以向 i 发
                if (ages[i] == ages[j]) {
                    numRequests++;
                }
            }
        }
        return numRequests;
    }
}
```

##### 排序 + 双指针

```java
// 官方解法一
// 排序 + 双指针
// 时间复杂度: O(nlogn) 排序需要的时间为 O(nlogn)，遍历所有的 ages[x] 以及使用双指针维护答案区间的时间复杂度为 O(n)
// 空间复杂度: O(logn)  即为排序需要使用的栈空间
class P825_Solution2 {
    public int numFriendRequests(int[] ages) {
        int n = ages.length;
        Arrays.sort(ages);
        double condition;
        int left = 0, right = 0;
        int numRequest = 0;
        // 0.5 × ages[x] + 7 < ages[y] ≤ ages[x]
        for (int age : ages) {
            if (age <= 14) {
                continue;
            }
            condition = age * 0.5 + 7;
            while (ages[left] <= condition) {
                left++;
            }
            while (right + 1 < n && ages[right + 1] <= age) {
                right++;
            }
            numRequest += right - left;
        }
        return numRequest;
    }
}
```

##### 计数排序 + 前缀和（最优解法）

```java
// 官方解法二
// 计数排序 + 前缀和
// 时间复杂度: O(n+C) 其中 C 是用户年龄的范围，本题中 C = 120。计数排序需要 O(n) 的时间，
// 计算前缀和以及统计答案需要 O(C) 的时间
// 空间复杂度: O(C) 即为计数排序以及前缀和数组需要使用的空间
class P825_Solution {
    public int numFriendRequests(int[] ages) {
        // 题目条件范围 1 <= ages[i] <= 120
        // 各个年龄的人数
        int[] cnt = new int[121];
        for (int age : ages) {
            cnt[age]++;
        }
        // 年龄小于等于 i 的总人数(前缀和)
        int[] pre = new int[121];
        for (int i = 1; i <= 120; i++) {
            pre[i] = pre[i - 1] + cnt[i];
        }
        
        int numRequest = 0;
        for (int age = 15; age <= 120; age++) {
            if (cnt[age] > 0) {
                // 0.5 × ages[x] + 7 < ages[y] ≤ ages[x]
                // 某个年龄 age 的用户能够向年龄满足这个不等式的用户发送好友请求
                numRequest += cnt[age] * (pre[age] - pre[(int) (age * 0.5 + 7)] - 1);
            }
        }
        return numRequest;
    }
}
```



#### [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/)

##### 暴力解法

> 见官方，会超时

##### 深度优先搜索（递归实现）

###### 第一种实现

```java
// 深度优先搜索(递归实现)
class P827_Solution {
    int[][] grid;
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    // 保存 grid 中各岛屿的编号 id 及其对应面积 area
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 保存当前(i, j)坐标水域上下左右相邻的陆地的编号
    Set<Integer> hashSet = new HashSet<>();

    public int largestIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int m = grid.length;
        int n = grid[0].length;
        // 最终结果, 最大岛屿面积
        int maxArea = 0;
        // 一个岛屿的面积
        int area;
        // 所有水域的面积和, 不影响最终结果, 只为减少循环次数
        int waterArea = m * n;
        // 岛屿编号, 从 2 号开始
        int id = 2;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 得到编号为 id 的岛屿的面积
                    // dfs 过程中会将属于这个岛屿的陆地("1")全部变为岛屿的 id
                    area = dfs(i, j, id);
                    // 将 (id, area) 加入到 map 中
                    hashmap.put(id, area);
                    maxArea = Math.max(maxArea, area);
                    // System.out.println("area : " + area + ", id : " + id + ", maxArea : " + maxArea);
                    waterArea -= area;
                    id++;
                }
            }
        }
        if (maxArea == 0) {
            return 1;
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    // 将当前(i, j)坐标水域变为陆地
                    mergeIsland(i, j);
                    // 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
                    area = getMergedArea();
                    // 比较得到当前所有合并后的岛屿的最大面积
                    maxArea = Math.max(maxArea, area);
                    waterArea--;
                    if (waterArea == 0) {
                        break;
                    }
                }
            }
            if (waterArea == 0) {
                break;
            }
        }
        return maxArea;
    }

    /**
     * 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
     *
     * @return area
     */
    public int getMergedArea() {
        // 表示转变这个水域为陆地, 其面积为 1
        int area = 1;
        // 取出相邻的陆地编号, hashMap 中得到编号为 idNum 的岛屿的面积, 并累加
        for (Integer idNum : hashSet) {
            area += hashmap.get(idNum);
        }
        hashSet.clear();
        return area;
    }

    /**
     * 将当前(i, j)坐标水域上下左右相邻的陆地的编号(大于0)加入到 hashSet 中
     * 如果相邻为水域则不加入, 不做任何操作
     *
     * @param i 当前水域的横坐标
     * @param j 当前水域的纵坐标
     */
    public void mergeIsland(int i, int j) {
        int x, y;
        for (int k = 0; k < 4; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (inGrid(x, y) && grid[x][y] > 0) {
                hashSet.add(grid[x][y]);
            }
        }
    }

    /**
     * 得到得到编号为 id 的岛屿的面积, 并将相应值改为 id
     *
     * @param i  格子的横坐标
     * @param j  格子的纵坐标
     * @param id 岛屿的编号
     * @return area 该 id 岛屿的面积
     */
    public int dfs(int i, int j, int id) {
        if (inGrid(i, j) && grid[i][j] == 1) {
            grid[i][j] = id;
            int x, y;
            int area = 1;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                area += dfs(x, y, id);
            }
            return area;
        }
        return 0;
    }

    /**
     * 判断坐标 (x, y) 是否在网格中
     *
     * @param x 格子的横坐标
     * @param y 格子的纵坐标
     * @return true 在网格中; false 不在网格中, 超出边界
     */
    public boolean inGrid(int x, int y) {
        return inGridX(x) && inGridY(y);
    }

    public boolean inGridX(int x) {
        return x >= 0 && x < grid.length;
    }

    public boolean inGridY(int y) {
        return y >= 0 && y < grid[0].length;
    }
}
```

###### 第二种实现

> 本以为在第一种实现的基础上减少了循环次数，但是在LeetCode上执行的效率却没有第一种的高

```java
// 深度优先搜索(递归实现)
// 本想着优化上方式的循环次数, 但是在 LeetCode 上执行的效率却不及前者
class P827_Solution1 {
    int[][] grid;
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    // 保存 grid 中各岛屿的编号 id 及其对应面积 area
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 保存当前(i, j)坐标水域上下左右相邻的陆地的编号
    Set<Integer> hashSet = new HashSet<>();
    // 保存格子为水域的横纵坐标, 以 waterId(waterId = i * n + j) 的单个整数的方式保存为一个集合
    Set<Integer> waterSet = new HashSet<>();

    public int largestIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        this.grid = grid;
        int m = grid.length;
        int n = grid[0].length;
        // 最终结果, 最大岛屿面积
        int maxArea = 0;
        // 一个岛屿的面积
        int area;
        // 岛屿编号, 从 2 号开始
        int id = 2;
        // 1.遍历 grid[][], 得到所有岛屿及其面积并编号
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 得到编号为 id 的岛屿的面积
                    // dfs 过程中会将属于这个岛屿的陆地("1")全部变为岛屿的 id
                    area = dfs(i, j, id);
                    // 将 (id, area) 加入到 map 中
                    hashmap.put(id, area);
                    // maxArea = Math.max(maxArea, area);
                    // System.out.println("area : " + area + ", id : " + id + ", maxArea : " + maxArea);
                    id++;
                } else if (grid[i][j] == 0) {
                    // 将水域加入 waterSet
                    waterSet.add(i * n + j);
                }
            }
        }

        // 可提前结束执行的一些特殊情况, 可删除, 删除后不影响最终结果
        // 全为陆地, 或者只有一块水域, return m * n
        int size = waterSet.size();
        if (size == 0 || size == 1) {
            return m * n;
        } else if (size == m * n) {
            // 全为水域, return 1
            return 1;
        }
        // 存在水域, 但只有一个岛屿, 返回 2 号岛屿的面积 + 1
        if (hashmap.size() == 1) {
            return hashmap.get(2) + 1;
        }

        // 2.遍历每个水域, 得到各个水域变为陆地后, 将多个岛屿连接后形成的整块大岛屿的面积
        for (Integer waterId : waterSet) {
            // 如果当前(i, j)坐标水域变为陆地
            mergeIsland(waterId / n, waterId % n);
            // 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
            area = getMergedArea();
            // 比较得到当前所有合并后的岛屿的最大面积
            maxArea = Math.max(maxArea, area);
        }
        return maxArea;
    }

    /**
     * 得到当前(i, j)坐标水域变为陆地后, 可能将多块岛屿连接后形成的整块大岛屿的面积
     *
     * @return area
     */
    public int getMergedArea() {
        // 表示转变这个水域为陆地, 其面积为 1
        int area = 1;
        // 取出相邻的陆地编号, hashMap 中得到编号为 idNum 的岛屿的面积, 并累加
        for (Integer idNum : hashSet) {
            area += hashmap.get(idNum);
        }
        hashSet.clear();
        return area;
    }

    /**
     * 将当前(i, j)坐标水域上下左右相邻的陆地的编号(大于0)加入到 hashSet 中
     * 如果相邻为水域则不加入, 不做任何操作
     *
     * @param i 当前水域的横坐标
     * @param j 当前水域的纵坐标
     */
    public void mergeIsland(int i, int j) {
        int x, y;
        for (int k = 0; k < 4; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (inGrid(x, y) && grid[x][y] > 0) {
                hashSet.add(grid[x][y]);
            }
        }
    }

    /**
     * 得到得到编号为 id 的岛屿的面积, 并将相应值改为 id
     *
     * @param i  格子的横坐标
     * @param j  格子的纵坐标
     * @param id 岛屿的编号
     * @return area 该 id 岛屿的面积
     */
    public int dfs(int i, int j, int id) {
        if (inGrid(i, j) && grid[i][j] == 1) {
            grid[i][j] = id;
            int x, y;
            int area = 1;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                area += dfs(x, y, id);
            }
            return area;
        }
        return 0;
    }

    /**
     * 判断坐标 (x, y) 是否在网格中
     *
     * @param x 格子的横坐标
     * @param y 格子的纵坐标
     * @return true 在网格中; false 不在网格中, 超出边界
     */
    public boolean inGrid(int x, int y) {
        return inGridX(x) && inGridY(y);
    }

    public boolean inGridX(int x) {
        return x >= 0 && x < grid.length;
    }

    public boolean inGridY(int y) {
        return y >= 0 && y < grid[0].length;
    }
}
```

##### 并查集

> 见评论区

#### [864. 获取所有钥匙的最短路径](https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/)

##### 广度优先搜索（队列实现） + 状态压缩（即带状态的 BFS）

```java
// BFS + 状态压缩
// 与 P864_Solution2_2 代码几乎一致, 只是简化了 node 节点的定义，及其相关属性的获取
// 效果一致
class P864_Solution {
    // 上下左右
    final static int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public int shortestPathAllKeys(String[] grid) {
        int m = grid.length, n = grid[0].length();
        // 利用状态压缩钥匙表示获取钥匙的状态, 记录最终获取全部钥匙为 target, 并在 BFS 遍历过程中进行更新状态
        int target = 0;
        int startX = 0;
        int startY = 0;
        for (int i = 0; i < m; i++) {
            String s = grid[i];
            for (int j = 0; j < n; j++) {
                char ch = s.charAt(j);
                if (ch >= 'a' && ch <= 'f') {
                    // 1 左移对应 ch 偏移 a 的位数 即为 第几位 有钥匙, 最终为有哪些钥匙
                    target |= (1 << (ch - 'a'));
                } else if (ch == '@') {
                    startX = i;
                    startY = j;
                }
            }
        }

        // 用 LinkedList 比用 ArrayDeque 快
        Queue<Node> queue = new LinkedList<>();
        // 记录该状态是否已经访问过
        boolean[][][] visited = new boolean[m][n][1 << Integer.bitCount(target)];

        // 初始化: 初始起点没有任何钥匙
        queue.offer(new Node(startX * n + startY, 0));
        visited[startX][startY][0] = true;

        int count = 0;
        // 带状态的 BFS
        Node curNode;
        int x, y, state;
        while (!queue.isEmpty()) {
            count++;
            System.out.println("+++++" + count);
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                curNode = queue.remove();
                x = curNode.id / n;
                y = curNode.id % n;
                // 走到该节点(方格)处时的状态(拥有哪些钥匙)
                state = curNode.state;

                int nx, ny;
                for (int[] dir : dirs) {
                    nx = x + dir[0];
                    ny = y + dir[1];
                    if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                        // 已经访问过当前状态
                        // 此处不再像常规 BFS 那样, 只判断曾经是否经过该节点(方格), 就可以确定是否访问过,
                        // 而是还要判断曾经经过该节点(方格)时的状态, 而这个状态指的每次到达该节点(方格)时, 拥有哪些钥匙(理论上是 2^k 种)
                        if (visited[nx][ny][state]) {
                            continue;
                        }
                        char ch = grid[nx].charAt(ny);
                        // 如果是障碍物, 说明不能从 (x,y) 走到 (nx,ny), 判断下一个
                        if (ch == '#') {
                            continue;
                        }
                        int newState = state;
                        // 如果是锁, 查看现在是否拥有对应钥匙
                        // 如果没有对应钥匙, 说明暂时还不能走这个格子去找其它钥匙, 得先走其它路径找到这把锁对应的钥匙
                        if (ch >= 'A' && ch <= 'F') {
                            // 两种方法
                            // (state >> (ch - 'A')) & 1) == 0
                            // (state & (1 << (ch - 'A'))) == 1 表示拥有这把锁对应钥匙
                            if ((state & (1 << (ch - 'A'))) == 0) {
                                continue;
                            }
                        } else if (ch >= 'a' && ch <= 'f') {
                            // 走到 (nx,ny) , 会新找到一把钥匙, 更新当前 state
                            newState |= (1 << (ch - 'a'));
                            // 相等说明找到了所有的钥匙
                            if (newState == target) {
                                return count;
                            }
                        }
                        queue.offer(new Node(nx * n + ny, newState));
                        visited[nx][ny][newState] = true;
                    }
                }
            }
        }
        return -1;
    }

    static class Node {
        int id, state;

        Node(int id, int state) {
            this.id = id;
            this.state = state;
        }
    }
}
```

#### [884. 两句话中的不常见单词](https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/)

##### 哈希表

###### 我的解法

```java
// 我的解法
// 2ms 99.60%
// 40.2MB 5.06%
class P884_Solution1 {
    public String[] uncommonFromSentences(String s1, String s2) {
        // 获得这两个句子中的各单词及其出现次数
        HashMap<String, Integer> wordAndCount1 = getWordAndCountHashMap(s1);
        HashMap<String, Integer> wordAndCount2 = getWordAndCountHashMap(s2);

        List<String> list = new ArrayList<>();

        // 遍历得到 WordAndCount1 中的独有的不常见的单词
        Set<Map.Entry<String, Integer>> entrySet1 = wordAndCount1.entrySet();
        // 遍历过程中, 句子 1 中的各单词及其出现次数 WordAndCount1 不会有删除或者更改操作
        for (Map.Entry<String, Integer> entry : entrySet1) {
            // 句子 1 中出现次数大于 1 的单词, 在句子 2 中将其删除(不管是否存在, 或者出现多少次)
            if (entry.getValue() > 1) {
                wordAndCount2.remove(entry.getKey());
            } else {
                // 句子 1 中出现次数为 1 的单词, 如果在句子 2 中也存在, 在句子 2 中将其删除
                // 如果在句子 2 中不存在, 则将其添加到 list
                // 换个思路想, 为了提升效率, 不管句子 2 中有没有这个单词, 都执行删除语句,
                // 如果有自然就删除了, 如果没有, 也就不会删除了
                // 根据 remove 的返回值判断是否删除了, 进一步确定是否添加该单词进 list 中
                /*if (WordAndCount2.containsKey(entry.getKey())) {
                    WordAndCount2.remove(entry.getKey());
                } else {
                    list.add(entry.getKey());
                }*/
                // 为 null, 表示句子 2 中不存在, 当然也就不用删除, 并且是不常见单词, 将其添加到 list 中
                if (wordAndCount2.remove(entry.getKey()) == null) {
                    list.add(entry.getKey());
                }
            }
        }

        // 遍历得到 WordAndCount2 中的独有的不常见的单词
        Set<Map.Entry<String, Integer>> entrySet2 = wordAndCount2.entrySet();
        for (Map.Entry<String, Integer> entry : entrySet2) {
            // 可省略 && !WordAndCount1.containsKey(entry.getKey())
            if (entry.getValue() == 1) {
                list.add(entry.getKey());
            }
        }

        // 结果输出
        String[] ans = new String[list.size()];
        int i = 0;
        for (String word : list) {
            ans[i] = word;
            i++;
        }
        return ans;
    }

    // 一个句子中各单词及其出现次数
    private HashMap<String, Integer> getWordAndCountHashMap(String s) {
        String[] str = s.split(" ");
        HashMap<String, Integer> wordAndCountHashMap = new HashMap<>();
        for (String word : str) {
            wordAndCountHashMap.put(word, wordAndCountHashMap.getOrDefault(word, 0) + 1);
        }
        return wordAndCountHashMap;
    }
}
```

###### 官方解法

```java
// 官方解法, 更简单的思路, 效果差不多
//「在句子 1 中恰好出现一次，但在句子 2 中没有出现的单词」或者「在句子 2 中恰好出现一次，但在句子 1 中没有出现的单词」。
// 这其实等价于找出：在两个句子中一共只出现一次的单词。
class P884_Solution {
    public String[] uncommonFromSentences(String s1, String s2) {
        // 获得这两个句子中的各单词及其出现次数
        HashMap<String, Integer> wordAndCount = new HashMap<>();
        getWordAndCountHashMap(s1, wordAndCount);
        getWordAndCountHashMap(s2, wordAndCount);

        List<String> ans = new ArrayList<>();

        // 遍历只出现一次的单词即为所求
        Set<Map.Entry<String, Integer>> entrySet = wordAndCount.entrySet();
        for (Map.Entry<String, Integer> entry : entrySet) {
            if (entry.getValue() == 1) {
                ans.add(entry.getKey());
            }
        }

        return ans.toArray(new String[0]);
    }

    // 一个句子中各单词及其出现次数
    private void getWordAndCountHashMap(String s, HashMap<String, Integer> wordAndCountHashMap) {
        String[] str = s.split(" ");
        for (String word : str) {
            wordAndCountHashMap.put(word, wordAndCountHashMap.getOrDefault(word, 0) + 1);
        }
    }
}
```



#### [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

##### 回溯（最优解法）

```java
// 回溯(最优解法)
class P980_Solution {
    private int[][] grid;

    public int uniquePathsIII(int[][] grid) {
        this.grid = grid;
        // 开始位置
        int startX = 0, startY = 0;
        // stepNum 表示 grid 中 0 的个数 + 找到 2 时这最后一步, 每经过一个 0 自减, 找到 2 时, stepNum 为 0
        int stepNum = 1;
        // 遍历 grid 得到起始位置 和 总步数
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 0) {
                    stepNum++;
                } else if (grid[i][j] == 1) {
                    startX = i;
                    startY = j;
                }
            }
        }
        return dfs(startX, startY, stepNum);
    }

    public int dfs(int x, int y, int step) {
        // 遍历到边界, 返回 0
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {
            return 0;
        }
        // grid[x][y] 是障碍(为 -1 时)或者已经访问过(为 3 时), 返回 0
        if (grid[x][y] == -1 || grid[x][y] == 3) {
            return 0;
        }
        // 找到结束方格, 但是如果此时(此路径)并没有访问完所有的 0 方格, 则还是认为没有找到满足题意的一条路径
        if (grid[x][y] == 2) {
            return step == 0 ? 1 : 0;
        }
        // 能执行到这里表示 grid[x][y] == 0, 将其置为 3, 表示正在访问或者已经访问过该方格, 在回溯时再将其置为 0
        grid[x][y] = 3;
        // path 表示之前已经访问过若干个 0 方格, 现从此方格开始能访问完所有剩余 0 方格, 并且最终能访问到结束方格的路径数
        // 任何一个从当前方格能够访问到结束方格的路径数等于该方格"上下左右"这四个方格访问到结束方格的路径数的总和
        int path = 0;
        // 按照左上右下的顺序遍历
        path += dfs(x, y - 1, step - 1);
        path += dfs(x - 1, y, step - 1);
        path += dfs(x, y + 1, step - 1);
        path += dfs(x + 1, y, step - 1);
        // 回溯时将其置为 0
        grid[x][y] = 0;
        return path;
    }
}
```

##### 深度优先搜索（递归实现） + 动态规划（状态压缩 DP）

```java
// 2021.12.21
// DFS + 动态规划(状态压缩 DP)
// 由于此题范围为 1 <= grid.length * grid[0].length <= 20
// 可以使用 DFS 结合 状态压缩 DP 来解答此题
// 将在某点处还要走多少个无防碍方格(步数)改为在某点处的状态(id, state)来记录
// 无论时间还是空间, 效率均远远不及上面的回溯方法
class P980_Solution1 {
    int[][] grid;
    int m;
    int n;
    // 右上左下
    int[] dx = new int[]{0, -1, 0, 1};
    int[] dy = new int[]{1, 0, -1, 0};
    // 记录状态
    // int[][] dp; // 220ms, 这种方式涉及到给 dp 数组全体赋值 -1 效率降低 for (int[] row : dp) { Arrays.fill(row, -1); }
    Integer[][] dp; // 82ms 两者空间消耗差不多, 但是是上一种方法的 6 倍左右

    public int uniquePathsIII(int[][] grid) {
        this.grid = grid;
        this.m = this.grid.length;
        this.n = this.grid[0].length;
        // 开始位置
        int startX = 0, startY = 0;

        // 上个方法中的 stepNum 等于 target 的二进制表示中 1 的个数
        int target = 0;
        // 遍历 grid 得到起始位置 和 总步数
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 要走的格子
                if (grid[i][j] % 2 == 0) {
                    target |= code(i, j);
                } else if (grid[i][j] == 1) {
                    // 起点
                    startX = i;
                    startY = j;
                }
            }
        }
        dp = new Integer[m * n][1 << m * n];
        return dfs(startX, startY, target);
    }

    public Integer dfs(int x, int y, int togo) {
        // 如果走到该空格时的这种状态曾经遍历过, 那么直接返回其值
        // 可以将这个判断改变一下放在 for 中
        int id = x * n + y;
        if (dp[id][togo] != null) {
            return dp[id][togo];
        }

        // 找到结束方格, 但是如果此时(此路径)并没有访问完所有的 0 方格, 则还是认为没有找到满足题意的一条路径
        if (grid[x][y] == 2) {
            return togo == 0 ? 1 : 0;
        }

        // path 表示之前已经访问过若干个 0 方格, 现从此方格开始能访问完所有剩余 0 方格, 并且最终能访问到结束方格的路径数
        // 任何一个从当前方格能够访问到结束方格的路径数等于该方格"上下左右"这四个方格访问到结束方格的路径数的总和
        int path = 0;

        // 按照右上左下的顺序遍历
        for (int k = 0; k < 4; k++) {
            int newX = x + dx[k];
            int newY = y + dy[k];
            // 这两个条件也可以放在 dfs 执行开始处
            // 边界条件: 要走的格子在区域内才能走
            if (newX >= 0 && newX < m && newY >= 0 && newY < n) {
                int possibleTogo = code(newX, newY);
                // togo 是还未走过的(剩下要走的)所有空格的一个二进制集合表示, possibleTogo 是 (newX, newY) 方格的一种二进制表示
                // (newX, newY) 可能走, 可能不走
                // 如果 (newX, newY) 处是起始点或者是障碍物点则不走它, 此时 togo & possibleTogo == 0
                // 如果 (newX, newY) 处是空格, 但是该空格曾经走过了, 也就是点 (newX, newY) 在从起点到点 (x,y) 的路径中了
                // 现在不能再从该点 (x,y) 走到点 (newX, newY) 了, 这样就重复走点 (newX, newY)了
                // 此时 togo & possibleTogo == 0

                // 假设 togo == 1010 1010 表示从(x, y)还要走这四个空格
                // 1.起点情况——起点的二进制表示是 0000 0001, 刚好 (newX, newY) 也是起点, togo & possibleTogo == 0, 起点不能走
                // 2.障碍物情况——如果 (newX, newY) 的二进制表示是 0000 0100, 说明该点是已经走过的空格, togo 中已经不包含这个空格了
                // 此时 togo & possibleTogo 也等于 0
                // 3.空格情况——如果 (newX, newY) 的二进制表示是 0000 1000, togo & possibleTogo == 0000 1000 != 0
                // 表示该空格在 togo 要走的空格集合中, 那么下一次就尝试走这个空格
                // 并将这个空格 (newX, newY) 从 togo 从删除, 表示从空格 (newX, newY) 出发去走新 togo 中的空格集合
                // 新的 togo 为 原togo ^ possibleTogo, 此例中则为 1010 1010 ^ 0000 1000 == 1010 0010, 即将相应位置变为 0

                // 返回能通过 (newX, newY) 走 新todo 走到终点的路径数
                if ((togo & possibleTogo) != 0) {
                    path += dfs(newX, newY, togo ^ possibleTogo);
                }
                // 其实吧, 这里就等于是把曾经的 dfs 中的判断 grid[x][y] 为 -1 3 0 等影响是否继续遍历的情况放在了此处, 用状态来代替了
            }
        }

        // 从该点走到终点的所有情况已经得到了, 记录其值
        dp[id][togo] = path;
        return path;
    }

    public int code(int x, int y) {
        return 1 << (x * n + y);
    }
}
```

#### [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索(队列实现)
// 哈哈, 好久没写网格类的 DFS/BFS 了, 这次几乎算是一两次就通过了
class P994_Solution {
    public int orangesRotting(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 上左下右
        int[] dx = new int[]{-1, 0, 1, 0};
        int[] dy = new int[]{0, -1, 0, 1};

        // 总新鲜橘子数
        int freshOranges = 0;
        // 烂橘子入队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 总新鲜橘子数加一
                    freshOranges++;
                } else if (grid[i][j] == 2) {
                    // 烂橘子入队列
                    queue.add(i * n + j);
                }
            }
        }
        // 总新鲜橘子数为 0, 需要 0 分钟
        if (freshOranges == 0) {
            return 0;
        }
        // 存在新鲜橘子, 但是没有烂橘子, 返回 -1
        if (queue.isEmpty()) {
            return -1;
        }

        // 最小分钟数初始化为 -1,
        // 当然也可以初始化为 0, 在最终返回时返回 minMinute - 1 即可
        // 还可以在自加时判断当时的 freshOranges 是否为 0, 当不为 0 时才自加
        // 还可以将 while 判断改为 while (freshOranges > 0 && !queue.isEmpty())
        int minMinute = -1;
        // 临时变量
        int size, id, x, y;
        while (!queue.isEmpty()) {
            // 当前队列中的所有烂橘子的相邻新鲜橘子都要在这一分钟中腐烂, 这一分钟中腐烂的橘子入队, 下一分钟中继续腐烂相邻新鲜橘子
            size = queue.size();
            minMinute++;
            for (int i = 0; i < size; i++) {
                // 该烂橘子所在方格
                id = queue.remove();
                x = id / n;
                y = id % n;
                int newX, newY;
                // 按照 上左下右 的顺序遍历相邻方格
                for (int j = 0; j < 4; j++) {
                    newX = x + dx[j];
                    newY = y + dy[j];
                    // 不要超出边界
                    if (newX >= 0 && newX < m && newY >= 0 && newY < n) {
                        // 如果是新鲜橘子, 将其腐烂, 并将其入队, 更新此时总新鲜橘子个数
                        // 如果是空格或者烂橘子就不管, 跳过
                        if (grid[newX][newY] == 1) {
                            // 新鲜橘子变烂
                            grid[newX][newY] = 2;
                            // 烂橘子加入队列
                            queue.add(newX * n + newY);
                            // 总新鲜橘子数减一
                            freshOranges--;
                        }
                    }
                }
//                // 这个判断可提前结束循环
//                if (freshOranges == 0) {
//                    return minMinute + 1;
//                }
            }
        }
        return freshOranges == 0 ? minMinute : -1;
    }
}
```

#### [1001. 网格照明](https://leetcode-cn.com/problems/grid-illumination/)

##### 超出内存限制代码见源文件

##### 哈希表

```java
// 执行用时：61 ms, 在所有 Java 提交中击败了 98.36% 的用户
// 内存消耗：48.9 MB, 在所有 Java 提交中击败了 100.00% 的用户
// 通过测试用例：45 / 45
class P1001_Solution3 {
    int n;
    HashSet<Integer> lampsRecorder;
    HashMap<Integer, Integer> rowRecorder;
    HashMap<Integer, Integer> colRecorder;
    HashMap<Integer, Integer> positiveRecorder;
    HashMap<Integer, Integer> negativeRecorder;
    final int[] dx = new int[]{-1, -1, -1, 0, 0, 0, 1, 1, 1};
    final int[] dy = new int[]{-1, 0, 1, -1, 0, 1, -1, 0, 1};

    public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {
        int ln = lamps.length;
        int qn = queries.length;
        if (qn == 0 || ln == 0) {
            return new int[qn];
        }
        this.n = n;
        // 记录 lamp 光源
        lampsRecorder = new HashSet<>();
        rowRecorder = new HashMap<>();
        colRecorder = new HashMap<>();
        positiveRecorder = new HashMap<>();
        negativeRecorder = new HashMap<>();
        int row, col;
        // 照亮开灯
        for (int[] lamp : lamps) {
            row = lamp[0];
            col = lamp[1];
            // 已添加过的光源不再添加
            if (!lampsRecorder.contains(row * n + col)) {
                // flag == 1, 记录光源四个方向的灯泡都亮
                turnOnOrTurnOff(row, col, 1);
                // 记录光源
                lampsRecorder.add(row * n + col);
            }
        }
        // 照亮开灯后
        myPrint("照亮开灯后的 lampsRecorder 和四个 hashMap : ");

        int[] ans = new int[qn];

        // 查询关灯
        for (int i = 0; i < qn; i++) {
            row = queries[i][0];
            col = queries[i][1];
            // 是亮着的, ans[i] = 1;
            if (queryLamp(row, col)) {
                ans[i] = 1;
            }
            // 消除九宫格中的光源, 非光源不能消除
            for (int j = 0; j < 9; j++) {
                int x = row + dx[j];
                int y = col + dy[j];
                if (x >= 0 && x < n && y >= 0 && y < n && lampsRecorder.contains(x * n + y)) {
                    // flag == -1, 将该光源四个方向的灯泡都熄灭
                    turnOnOrTurnOff(x, y, -1);
                    // 将该光源从记录中移除
                    lampsRecorder.remove(x * n + y);
                }
            }
            // 查询关灯后
            myPrint("查询(" + row + ", " + col + ")关灯后的 lampsRecorder 和四个 hashMap : ");
        }
        return ans;
    }

    private void turnOnOrTurnOff(int row, int col, int flag) {
        if (flag < -1 || flag > 1 || flag == 0) {
            throw new IllegalArgumentException("flag must be 1 or -1");
        }
        rowRecorder.put(row, rowRecorder.getOrDefault(row, 0) + flag);
        colRecorder.put(col, colRecorder.getOrDefault(col, 0) + flag);
        positiveRecorder.put(row + col, positiveRecorder.getOrDefault(row + col, 0) + flag);
        negativeRecorder.put(n - 1 - (row - col), negativeRecorder.getOrDefault(n - 1 - (row - col), 0) + flag);
    }

    private boolean queryLamp(int row, int col) {
        // 只判断是否包含 key 会出现错误, 因为可能以下四个 key 的对应值为 0, 本身 (row, col) 是不亮的, 但由于存在 key, 返回为 true
        // 只判断 key 对应的值是否大于 0 会出现空指针错误, 因为 key 可能根本就不存在
//        return rowRecorder.containsKey(row)
//                || colRecorder.containsKey(col)
//                || positiveRecorder.containsKey(row + col)
//                || negativeRecorder.containsKey(n - 1 - (row - col));

        // 故首先要判断 key 是否存在, 再判断 key 对应处的 value 值是否大于 0
        return (rowRecorder.containsKey(row) && rowRecorder.get(row) > 0)
                || (colRecorder.containsKey(col) && colRecorder.get(col) > 0)
                || (positiveRecorder.containsKey(row + col) && positiveRecorder.get(row + col) > 0)
                || (negativeRecorder.containsKey(n - 1 - (row - col)) && negativeRecorder.get(n - 1 - (row - col)) > 0);
    }

    private void myPrint(String str) {
        System.out.println(str);
        System.out.println(lampsRecorder);
        System.out.println(rowRecorder);
        System.out.println(colRecorder);
        System.out.println(positiveRecorder);
        System.out.println(negativeRecorder);
    }
}

// 尝试一下效率能否更快, 发现并不
class P1001_Solution {
    int n;
    // 记录 lamp 光源
    HashSet<Integer> lampsRecorder;
    // 记录 lamp 光源所在 行 亮, key 为光源行下标 row(0, n-1), value 为该行光源数
    HashMap<Integer, Integer> rowRecorder;
    // 记录 lamp 光源所在 列 亮, key 为光源列下标 col(0, n-1), value 为该列光源数
    HashMap<Integer, Integer> colRecorder;
    // 记录 lamp 光源所在 正对角线 亮, key 为光源正对角线下标 (row + col)(0, 2n-1), value 为该正对角线光源数
    HashMap<Integer, Integer> positiveRecorder;
    // 记录 lamp 光源所在 反对角线 亮, key 为光源反对角线下标 (col - row)(-(n-1), n-1), value 为该反对角线光源数
    HashMap<Integer, Integer> negativeRecorder;
    // 九宫格各坐标与 (row, col) 的关系
    final int[] dx = new int[]{-1, -1, -1, 0, 0, 0, 1, 1, 1};
    final int[] dy = new int[]{-1, 0, 1, -1, 0, 1, -1, 0, 1};

    public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {
        int ln = lamps.length;
        int qn = queries.length;
        if (qn == 0 || ln == 0) {
            return new int[qn];
        }
        this.n = n;
        lampsRecorder = new HashSet<>();
        rowRecorder = new HashMap<>();
        colRecorder = new HashMap<>();
        positiveRecorder = new HashMap<>();
        negativeRecorder = new HashMap<>();
        // 结果数组
        int[] ans = new int[qn];
        // 行, 列下标
        int row, col;
        // 1.照亮开灯
        for (int[] lamp : lamps) {
            row = lamp[0];
            col = lamp[1];
            // 已添加过的光源不再添加, 只添加未添加过的光源
            if (!lampsRecorder.contains(row * n + col)) {
                // 记录光源四个方向的灯泡都亮
                turnOn(row, col);
                // 记录光源
                lampsRecorder.add(row * n + col);
            }
        }
        // 照亮开灯后
        // myPrint("照亮开灯后的 lampsRecorder 和四个 hashMap : ");

        // 2.查询关灯
        for (int i = 0; i < qn; i++) {
            row = queries[i][0];
            col = queries[i][1];
            // 如果返回为 true, 说明 (row, col) 是亮着的, ans[i] = 1
            if (queryLamp(row, col)) {
                ans[i] = 1;
            }
            // 消除九宫格中的光源, 非光源不能消除, 跳过
            for (int j = 0; j < 9; j++) {
                int x = row + dx[j];
                int y = col + dy[j];
                // 在网格内, 且 (x, y) 处是光源
                if (x >= 0 && x < n && y >= 0 && y < n && lampsRecorder.contains(x * n + y)) {
                    // 将该光源四个方向的灯泡都熄灭
                    turnOff(x, y);
                    // 将该光源从记录中移除
                    lampsRecorder.remove(x * n + y);
                }
            }
            // 查询关灯后
            // myPrint("查询(" + row + ", " + col + ")关灯后的 lampsRecorder 和四个 hashMap : ");
        }
        return ans;
    }

    // 开灯
    private void turnOn(int row, int col) {
        rowRecorder.put(row, rowRecorder.getOrDefault(row, 0) + 1);
        colRecorder.put(col, colRecorder.getOrDefault(col, 0) + 1);
        positiveRecorder.put(row + col, positiveRecorder.getOrDefault(row + col, 0) + 1);
        negativeRecorder.put(col - row, negativeRecorder.getOrDefault(col - row, 0) + 1);
    }

    // 关灯
    private void turnOff(int row, int col) {
        int rVal = rowRecorder.getOrDefault(row, 0);
        int cVal = colRecorder.getOrDefault(col, 0);
        int pVal = positiveRecorder.getOrDefault(row + col, 0);
        int nVal = negativeRecorder.getOrDefault(col - row, 0);
        // 当是在移除最后一个光源时, 可以直接移除该 key, 而不是 put(key,0)
        if (rVal == 1) {
            rowRecorder.remove(row);
        } else {
            rowRecorder.put(row, rVal - 1);
        }
        if (cVal == 1) {
            colRecorder.remove(col);
        } else {
            colRecorder.put(col, cVal - 1);
        }
        if (pVal == 1) {
            positiveRecorder.remove(row + col);
        } else {
            positiveRecorder.put(row + col, pVal - 1);
        }
        if (nVal == 1) {
            negativeRecorder.remove(col - row);
        } else {
            negativeRecorder.put(col - row, nVal - 1);
        }
    }

    // 此处就只需要判断 key 是否存在就可以了, 不需要判断 key 对应的 value 值是否大于 0, 来确定 (row, col) 是否亮
    // 因为在 关灯后, 如果某个方向无光源了, 该方向的下标 key 就从相应的 hashMap 中移除了, 而不是将其值变成了 0
    private boolean queryLamp(int row, int col) {
        return rowRecorder.containsKey(row)
                || colRecorder.containsKey(col)
                || positiveRecorder.containsKey(row + col)
                || negativeRecorder.containsKey(col - row);
    }

    // 打印
    private void myPrint(String str) {
        System.out.println(str);
        System.out.println(lampsRecorder);
        System.out.println(rowRecorder);
        System.out.println(colRecorder);
        System.out.println(positiveRecorder);
        System.out.println(negativeRecorder);
    }
}
```



#### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

##### 深度优先搜索（递归实现）

###### 第一种实现

> 曾经的常规思路

```java
// 深度优先搜索（递归实现）
class P1020_Solution {
    int[][] grid;
    int m;
    int n;
    int numOfEnclaves;
    boolean flag;

    public int numEnclaves(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        if (m == 0) {
            return 0;
        }
        this.n = grid[0].length;
        this.numOfEnclaves = 0;

        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 默认是一个封闭岛屿(无法走出)
                    flag = true;
                    // 该岛屿的面积
                    area = dfs(i, j);
                    if (flag) {
                        // 如果是, 加上这些格子的数量(岛屿面积)
                        numOfEnclaves += area;
                    }
                }
            }
        }

        return numOfEnclaves;
    }

    public int dfs(int i, int j) {
        // 边界条件
        if (i < 0 || i >= m || j < 0 || j >= n) {
            flag = false;
            return 0;
        }

        // 是水域或者曾经遍历过, 跳过遍历
        if (grid[i][j] == 0 || grid[i][j] == 2) {
            return 0;
        }

        grid[i][j] = 2;

        // 上左下右
        return 1 + dfs(i - 1, j)
                + dfs(i, j - 1)
                + dfs(i + 1, j)
                + dfs(i, j + 1);
    }
}
```

###### 第二种实现

> 针对本地，可以换种思考方式，先将与四周边界相连的陆地遍历后，最后grid中还为1的陆地总数即为答案
>
> 三种实现中效率最高

```java
// 深度优先搜索（递归实现）
// 换一种思考方式的解题思路
// 三种实现中效率最高
class P1020_Solution {
    int[][] grid;
    int m;
    int n;

    public int numEnclaves(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        if (m == 0) {
            return 0;
        }
        this.n = grid[0].length;
        int numOfEnclaves = 0;

        // 1.将与左右两边界相连的陆地去掉
        for (int i = 0; i < m; i++) {
            if (grid[i][0] == 1) {
                dfs(i, 0);
            }
            if (grid[i][n - 1] == 1) {
                dfs(i, n - 1);
            }
        }

        // 2.将与上下两边界相连的陆地去掉
        for (int j = 0; j < n; j++) {
            if (grid[0][j] == 1) {
                dfs(0, j);
            }
            if (grid[m - 1][j] == 1) {
                dfs(m - 1, j);
            }
        }

        // 3.最后遍历 grid 中为 1 的格子的数量, 即为答案
        for (int i = 1; i < m - 1; i++) {
            for (int j = 1; j < n - 1; j++) {
                if (grid[i][j] == 1) {
                    numOfEnclaves++;
                }
            }
        }

        return numOfEnclaves;
    }

    public void dfs(int i, int j) {
        // 边界条件
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return;
        }

        // 是水域或者曾经遍历过, 跳过遍历
        if (grid[i][j] == 0 || grid[i][j] == 2) {
            return;
        }

        grid[i][j] = 2;

        // 上左下右
        dfs(i - 1, j);
        dfs(i, j - 1);
        dfs(i + 1, j);
        dfs(i, j + 1);
    }
}
```

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索（队列实现）
// 效率不及 DFS
class P1020_Solution1 {
    int[] dx = new int[]{-1, 0, 1, 0};
    int[] dy = new int[]{0, -1, 0, 1};

    public int numEnclaves(int[][] grid) {
        int m = grid.length;
        if (m == 0) {
            return 0;
        }
        int n = grid[0].length;
        int numOfEnclaves = 0;

        boolean flag;
        // 每块岛屿的面积
        int area;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 默认是一个封闭岛屿(无法走出)
                    flag = true;
                    Queue<Integer> queue = new LinkedList<>();
                    // 该个岛屿第一块陆地入队
                    queue.add(i * n + j);
                    // 标记为已访问
                    grid[i][j] = 2;
                    // 初始为 1
                    area = 1;
                    int id, x, y;
                    while (!queue.isEmpty()) {
                        id = queue.remove();
                        x = id / n;
                        y = id % n;
                        int newX, newY;
                        // 上左下右四块陆地入队
                        for (int k = 0; k < 4; k++) {
                            newX = x + dx[k];
                            newY = y + dy[k];
                            // 如果该块陆地与边界相连, 则 flag 置为 false, 表示该岛屿与边界是相连的
                            // 遍历完后, 该岛屿的面积 area 不加入 numOfEnclaves 中
                            if (newX < 0 || newX >= m || newY < 0 || newY >= n) {
                                flag = false;
                                continue;
                            }
                            // 跳过周围的四块陆地中 是水域或者已经遍历过的陆地
                            if (grid[newX][newY] == 0 || grid[newX][newY] == 2) {
                                continue;
                            }
                            // 此处 grid[newX][newY] 肯定为 1, 表示从未遍历过的陆地
                            // 将其入队, 并置为已访问 2, 面积 area 加 1
                            queue.add(newX * n + newY);
                            grid[newX][newY] = 2;
                            area++;
                        }
                    }
                    // flag 为 false 时, 表示该岛屿与边界相连, 不加上该块岛屿面积
                    if (flag) {
                        numOfEnclaves += area;
                    }
                }
            }
        }
        return numOfEnclaves;
    }
}
```

##### 并查集

#### [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

##### 动态规划、递归

> 2021.11.03

```java
class P1137_Solution {
    // 动态规划
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        int[] dp = new int[]{0, 1, 1, 0};
        for (int i = 3; i < n + 1; i++) {
            dp[3] = dp[2] + dp[1] + dp[0];
            dp[0] = dp[1];
            dp[1] = dp[2];
            dp[2] = dp[3];
        }
        return dp[3];
    }

    // 递归
    public int tribonacci1(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        return tribonacci1(n - 1) + tribonacci1(n - 2) + tribonacci1(n - 3);
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(1)

##### 矩阵快速幂

> 2021.11.03

```java
class P1137_Solution1 {
    // 快速矩阵幂
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n <= 2) {
            return 1;
        }
        int[][] q = {{1, 1, 1}, {1, 0, 0}, {0, 1, 0}};
        int[][] res = pow(q, n);
        // 此处为何返回 res[0][2], 而不是 res[2][0] + res[2][1] ?
        return res[0][2];
    }

    // n 个矩阵 a 相乘
    public int[][] pow(int[][] a, int n) {
        int[][] ret = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    // 矩阵 a 与矩阵 b 相乘
    public int[][] multiply(int[][] a, int[][] b) {
        int[][] c = new int[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
            }
        }
        return c;
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(log n)
> - 空间复杂度：O(1)

> **为何返回的是 `return res[0][2]` ？**
>
> 按照方法二的公式
>
> ```reasonml
> 列矩阵【T(n+2),T(n+1),T(n)】 = n 个 M 矩阵相乘，再与列矩阵 【T(2),T(1),T(0)】(1,1,0) 相乘
> ```
>
> 最后得到的是三行一列的矩阵，T(n) 应该等于   `res[2][0]*T(2) + res[2][1]*T(1) +  res[2][2]*T(0) ` 
>
> 带入 T(2), T(1), T(0) 的值 (1,1,0)，最后  `T(n) = res[2][0] + res[2][1]`
>
> 而方法二答案最终返回的是 `res[0][2]`，是因为方法二的代码实现与文字解答不一致，`return res[0][2]` 是将公式看成了
>
> ```reasonml
> 列矩阵【T(n),T(n-1),T(n-2)】 = n 个 M 矩阵相乘，再与列矩阵 【T(0),T(-1),T(-2)】(0,0,1) 相乘
> ```
>
> 于是乎，T(n) 等于   `res[0][0]*T(0) + res[0][1]*T(-1) +  res[0][2]*T(-2) ` 
>
> 带入 T(0), T(-1), T(-2) 的值 (0,0,1)，最后   `T(n) = res[0][2]`
>
> 至于 T(-1), T(-2) 为何为 0 和 1，是因为
>
> `T(-1) = T(2) - T(1) - T(0) = 1 - 1 - 0 = 0` 
>
> `T(-2) = T(1) - T(0) - T(-1) = 1 - 0 - 0 = 1` 

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

##### 动态规划

###### 2021.11.30

```java
class P1143_Solution {
    // 二维动态规划
    public int longestCommonSubsequence1(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        int m = text1.length();
        int n = text2.length();

        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 两字符串的最后一个字符一样
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 为何 text1.charAt(i - 1) != text2.charAt(j - 1) 时
                    // dp[i][j] 为 (dp[i][j - 1], dp[i - 1][j]) 中的较大值?

                    // 分为两种情况

                    // 1.dp[i][j] 可以看作是以下两字符串的状态变换过来的
                    // (1) text1的前(i-1)个字符组成的字符串(记为str1{i-1}) 加上 第 i 个字符('text1.charAt(i-1)',记为 ci), 也就是text1的前 i 个字符组成的字符串
                    // (2) text2的前(j-1)个字符组成的字符串(记为str2{j-1})
                    // 而现在str2{j-1}末尾加上了这第 j 个字符('text2.charAt(j-1)',记为 cj), 这个字符与(ci)不相等, 加上后记为 str2{j}
                    // 由于多了 cj 这个字符, 那么这个最长公共子序列【可能】就变成包含这个 cj 字符(并且这个字符是最长公共子序列最后一个字符)的序列了
                    // 那么这个序列在 str1{i} 中就肯定不是以 ci 结尾的, 或者说是这个最长公共子序列是在 str1{i-1} 中找到的
                    // 也就是将【求 str1{i} 与 str2{j} 中的最长公共子序列的长度问题】变成了【求 str1{i-1} 与 str2{j} 中的最长公共子序列的长度问题】
                    // cj 可能是最长公共子序列的最后一个字符, ci 与 cj 不相等, str1 中存不存在 ci, 与 str2{j} 比较的结果都是一样的
                    // 故此时这种情况下的 dp[i][j] 其实就为 dp[i-1][j]
                    // 那如果这个最长公共子序列不包含 cj 这个尾字符呢?
                    // 那 dp[i][j] 其实就直接为 dp[i][j-1]

                    // 2.dp[i][j] 可以看作是以下两字符串的状态变换过来的
                    // (1) text1的前(i-1)个字符组成的字符串(记为str1{i-1})
                    // (2) text2的前(j-1)个字符组成的字符串(记为str2{j-1}) 加上 第 j 个字符('text2.charAt(j-1)',记为 cj), 也就是text2的前 j 个字符组成的字符串
                    // 而现在str1{i-1}末尾加上了这第 i 个字符('text1.charAt(i-1)',记为 ci), 这个字符与(cj)不相等, 加上后记为 str1{i}
                    // 由于多了 ci 这个字符, 那么这个最长公共子序列【可能】就变成包含这个 ci 字符(并且这个字符是最长公共子序列最后一个字符)的序列了
                    // 那么这个序列在 str2{j} 中就肯定不是以 cj 结尾的, 或者说是这个最长公共子序列是在 str2{j-1} 中找到的
                    // 也就是将【求 str1{i} 与 str2{j} 中的最长公共子序列的长度问题】变成了【求 str1{i} 与 str2{j-1} 中的最长公共子序列的长度问题】
                    // ci 可能是最长公共子序列的最后一个字符, cj 与 ci 不相等, str2 中存不存在 cj, 与 str1{i} 比较的结果都是一样的
                    // 故此时这种情况下的 dp[i][j] 其实就为 dp[i][j-1]
                    // 那如果这个最长公共子序列不包含 ci 这个尾字符呢?
                    // 那 dp[i][j] 其实就直接为 dp[i-1][j]

                    // 综上, 故最终得两者最大值为 dp[i][j]
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }

    // 一维动态规划(滚动数组思想)
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        int m = text1.length();
        int n = text2.length();

        if (m >= n) {
            return lengthOfLongestCommonSubsequence(text1, text2);
        } else {
            return lengthOfLongestCommonSubsequence(text2, text1);
        }
    }

    private int lengthOfLongestCommonSubsequence(String longStr, String shortStr) {
        if (longStr == null || shortStr == null) {
            return 0;
        }
        int m = longStr.length();
        int n = shortStr.length();

        int[] dp = new int[n + 1];

        int pre, temp;
        for (int i = 1; i < m + 1; i++) {
            pre = dp[0];
            for (int j = 1; j < n + 1; j++) {
                temp = dp[j];
                // 两字符串的最后一个字符一样
                if (longStr.charAt(i - 1) == shortStr.charAt(j - 1)) {
                    dp[j] = pre + 1;
                } else {
                    dp[j] = Math.max(dp[j - 1], dp[j]);
                }
                pre = temp;
            }
        }

        return dp[n];
    }
}
```

> **复杂度分析**
>
> - 时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text 1 和 text 2 的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算。
>
> - 空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text 1和 text 2 的长度。创建了 m+1 行 n+1 列的二维数组 dp。
> - 优化过后的空间复杂度为 O(min(m,n))

###### 2022.01.03

```java
// 动态规划
class Second_P1143_Solution {
    public int longestCommonSubsequence1(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        // 可定义成dp[m+1][n+1], 减少初始化过程, 就如同第一次做的那样
        int[][] dp = new int[m][n];
        // 初始化
        if (text1.charAt(0) == text2.charAt(0)) {
            dp[0][0] = 1;
        }
        // 第一列
        for (int i = 1; i < m; i++) {
            if (text1.charAt(i) == text2.charAt(0) || dp[i - 1][0] == 1) {
                dp[i][0] = 1;
            }
        }
        // 第一行
        for (int j = 1; j < n; j++) {
            if (text1.charAt(0) == text2.charAt(j) || dp[0][j - 1] == 1) {
                dp[0][j] = 1;
            }
        }

        // 动态规划 其余行列
        for (int i = 1; i < m; i++) {
            char ch = text1.charAt(i);
            for (int j = 1; j < n; j++) {
                if (ch == text2.charAt(j)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m - 1][n - 1];
    }

    // 可通过使用滚动数组减小空间复杂度
    // 第一种实现
    // pre 为 dp[i][j-1]
    public int longestCommonSubsequence2(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[] dp = new int[n];
        // 初始化
        if (text1.charAt(0) == text2.charAt(0)) {
            dp[0] = 1;
        }
        // 第一行
        for (int j = 1; j < n; j++) {
            if (text1.charAt(0) == text2.charAt(j) || dp[j - 1] == 1) {
                dp[j] = 1;
            }
        }

        System.out.println(Arrays.toString(dp));
        // 动态规划 其余行列
        char ch;
        // pre 为 当前 dp[i][j-1]
        int pre, temp;
        for (int i = 1; i < m; i++) {
            ch = text1.charAt(i);
            if (ch == text2.charAt(0) || dp[0] == 1) {
                pre = 1;
            } else {
                pre = 0;
            }
            for (int j = 1; j < n; j++) {
                temp = pre;
                if (ch == text2.charAt(j)) {
                    pre = dp[j - 1] + 1;
                } else {
                    pre = Math.max(pre, dp[j]);
                }
                dp[j - 1] = temp;
            }
            dp[n - 1] = pre;
            System.out.println(Arrays.toString(dp));
        }

        return dp[n - 1];
    }

    // 可通过使用滚动数组减小空间复杂度
    // 第二种实现(细节上不同)
    // pre 为 dp[i-1][j-1]
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[] dp = new int[n];
        // 初始化
        if (text1.charAt(0) == text2.charAt(0)) {
            dp[0] = 1;
        }
        // 第一行
        for (int j = 1; j < n; j++) {
            if (text1.charAt(0) == text2.charAt(j) || dp[j - 1] == 1) {
                dp[j] = 1;
            }
        }

        System.out.println(Arrays.toString(dp));
        // 动态规划 其余行列
        char ch;
        int pre, temp;
        for (int i = 1; i < m; i++) {
            ch = text1.charAt(i);
            pre = dp[0];
            if (ch == text2.charAt(0)) {
                dp[0] = 1;
            }
            for (int j = 1; j < n; j++) {
                temp = dp[j];
                if (ch == text2.charAt(j)) {
                    dp[j] = pre + 1;
                } else {
                    dp[j] = Math.max(dp[j - 1], dp[j]);
                }
                pre = temp;
            }
            System.out.println(Arrays.toString(dp));
        }

        return dp[n - 1];
    }
}
```

#### [1189. “气球” 的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balloons/)

##### 基本操作

```java
// 基本操作
// 3 ms 69.44%
class P1189_Solution {
    public int maxNumberOfBalloons(String text) {
        int b = 0;
        int a = 0;
        int l = 0;
        int o = 0;
        int n = 0;
        for (int i = 0; i < text.length(); i++) {
            // balloon
            char ch = text.charAt(i);
            if (ch == 'b') {
                b++;
            } else if (ch == 'a') {
                a++;
            } else if (ch == 'l') {
                l++;
            } else if (ch == 'o') {
                o++;
            } else if (ch == 'n') {
                n++;
            }
        }
        return Math.min(Math.min(Math.min(b, a), n), Math.min(l / 2, o / 2));
    }
}
```



#### [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

##### 回溯

```java
// 回溯
// 18 ms 49.51%
class P1219_Solution {
    int[][] grid;
    int m;
    int n;
    private final int[] dx = new int[]{-1, 0, 1, 0};
    private final int[] dy = new int[]{0, -1, 0, 1};

    public int getMaximumGold(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        int maximumGold = 0;
        // 以每个可挖矿的格子为出发点开始遍历
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] != 0) {
                    maximumGold = Math.max(maximumGold, dfs(i, j));
                }
            }
        }
        return maximumGold;
    }

    private int dfs(int i, int j) {
        // 保证在边界内
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return 0;
        }
        // 保证可开采或者未开采过(可访问或未访问)
        if (grid[i][j] == 0 || grid[i][j] == -1) {
            return 0;
        }
        // 当前格子处的黄金数量 curGold
        int curGold = grid[i][j];
        // 标记为已访问
        grid[i][j] = -1;
        // 从当前格子开始往其它方向开采的路径中, 能开采到的最多的黄金数量(此处不包括当前格子处的黄金数量 curGold, 最后返回时再加上即可)
        int curMaxPathGold = 0;
        for (int k = 0; k < 4; k++) {
            curMaxPathGold = Math.max(curMaxPathGold, dfs(i + dx[k], j + dy[k]));
        }
        // 回溯还原为未访问(未开采)
        grid[i][j] = curGold;
        return curMaxPathGold + curGold;
    }
}
```



#### [1220. 统计元音字母序列的数目](https://leetcode-cn.com/problems/count-vowels-permutation/)

##### 动态规划

```java
// 动态规划(同官方解法一), 有些像 P1411 以及我的那道笔试题
class P1220_Solution {
    // 二维动态规划
    // 18 ms (8.49%), 38.4 M (37.74%)
    public int countVowelPermutation1(int n) {
        final int mod = 1000000007;
        long[][] dp = new long[n][5];
        dp[0][0] = 1; // a
        dp[0][1] = 1; // e
        dp[0][2] = 1; // i
        dp[0][3] = 1; // o
        dp[0][4] = 1; // u
        /*
         每行的 a e i o u 表示它的前面可以是那些字母
           a  e  i  o  u
        a  0  1  1  0  1  124
        e  1  0  1  0  0  02
        i  0  1  0  1  0  13
        o  0  0  1  0  0  2
        u  0  0  1  1  0  23
         */
        for (int i = 1; i < n; i++) {
//            // 这里最后没必要再 % mod 了
//            dp[i][0] = (dp[i - 1][1] % mod + dp[i - 1][2] % mod + dp[i - 1][4] % mod) % mod;
//            dp[i][1] = (dp[i - 1][0] % mod + dp[i - 1][2] % mod) % mod;
//            dp[i][2] = (dp[i - 1][1] % mod + dp[i - 1][3] % mod) % mod;
//            dp[i][3] = dp[i - 1][2] % mod;
//            dp[i][4] = (dp[i - 1][2] % mod + dp[i - 1][3] % mod) % mod;

            dp[i][0] = dp[i - 1][1] % mod + dp[i - 1][2] % mod + dp[i - 1][4] % mod;
            dp[i][1] = dp[i - 1][0] % mod + dp[i - 1][2] % mod;
            dp[i][2] = dp[i - 1][1] % mod + dp[i - 1][3] % mod;
            dp[i][3] = dp[i - 1][2] % mod;
            dp[i][4] = dp[i - 1][2] % mod + dp[i - 1][3] % mod;
        }
        long ans = 0;
        for (int i = 0; i < 5; i++) {
            // 第一个 % mod 可以省略, 第二个 % mod 不能省略
            ans = (ans + dp[n - 1][i] % mod) % mod;
            // System.out.println(dp[n - 2][i]);
            // System.out.println(dp[n - 1][i]);
            // System.out.println("ans = " + ans);
        }
        return (int) ans;
    }

    // 第一次修改优化
    // 13 ms (45.28%), 37.6 M (61.32%)
    // 果然是不用提前创建完整个二维数组更快些
    public int countVowelPermutation1_1(int n) {
        final int mod = 1000000007;
        long[] dp = new long[5];
        dp[0] = 1; // a
        dp[1] = 1; // e
        dp[2] = 1; // i
        dp[3] = 1; // o
        dp[4] = 1; // u
        /*
         每行的 a e i o u 表示它的前面可以是那些字母
           a  e  i  o  u
        a  0  1  1  0  1  124
        e  1  0  1  0  0  02
        i  0  1  0  1  0  13
        o  0  0  1  0  0  2
        u  0  0  1  1  0  23
         */
        long[] temp;
        for (int i = 1; i < n; i++) {
            temp = Arrays.copyOf(dp, 5);
            dp[0] = temp[1] % mod + temp[2] % mod + temp[4] % mod;
            dp[1] = temp[0] % mod + temp[2] % mod;
            dp[2] = temp[1] % mod + temp[3] % mod;
            dp[3] = temp[2] % mod;
            dp[4] = temp[2] % mod + temp[3] % mod;
        }
        long ans = 0;
        for (int i = 0; i < 5; i++) {
            // 第一个 % mod 可以省略, 第二个 % mod 不能省略
            ans = (ans + dp[i] % mod) % mod;
        }
        return (int) ans;
    }

    // 第二次修改优化
    // 12 ms (53.77%), 35 M (96.23%)
    // 不使用 Arrays.copyOf(dp, 5) , 而是手动赋值
    public int countVowelPermutation1_2(int n) {
        final int mod = 1000000007;
        long[] dp = new long[5];
        dp[0] = 1; // a
        dp[1] = 1; // e
        dp[2] = 1; // i
        dp[3] = 1; // o
        dp[4] = 1; // u
        /*
         每行的 a e i o u 表示它的前面可以是那些字母
           a  e  i  o  u
        a  0  1  1  0  1  124
        e  1  0  1  0  0  02
        i  0  1  0  1  0  13
        o  0  0  1  0  0  2
        u  0  0  1  1  0  23
         */
        long[] temp = new long[5];
        for (int i = 1; i < n; i++) {
            temp[0] = dp[0];
            temp[1] = dp[1];
            temp[2] = dp[2];
            temp[3] = dp[3];
            temp[4] = dp[4];
            dp[0] = temp[1] % mod + temp[2] % mod + temp[4] % mod;
            dp[1] = temp[0] % mod + temp[2] % mod;
            dp[2] = temp[1] % mod + temp[3] % mod;
            dp[3] = temp[2] % mod;
            dp[4] = temp[2] % mod + temp[3] % mod;
        }
        long ans = 0;
        for (int i = 0; i < 5; i++) {
            // 第一个 % mod 可以省略, 第二个 % mod 不能省略
            ans = (ans + dp[i] % mod) % mod;
        }
        return (int) ans;
    }

    // 第三次修改优化(使用动态规划做, 这种应该是最优的了)
    // 7 ms (74.53%), 35.1 M (89.62%)
    // 使用 5 个变量保存前一次的结果
    public int countVowelPermutation(int n) {
        final int mod = 1000000007;
        long[] dp = new long[5];
        dp[0] = 1; // a
        dp[1] = 1; // e
        dp[2] = 1; // i
        dp[3] = 1; // o
        dp[4] = 1; // u
        /*
         每行的 a e i o u 表示它的前面可以是那些字母
           a  e  i  o  u
        a  0  1  1  0  1  124
        e  1  0  1  0  0  02
        i  0  1  0  1  0  13
        o  0  0  1  0  0  2
        u  0  0  1  1  0  23
         */
        long a, e, i, o, u;
        for (int j = 1; j < n; j++) {
            a = dp[0];
            e = dp[1];
            i = dp[2];
            o = dp[3];
            u = dp[4];
            // a 前面可以为 e  i  u
            dp[0] = (e + i + u) % mod;
            // e 前面可以为 a  i
            dp[1] = (a + i) % mod;
            // i 前面可以为 e  o
            dp[2] = (e + o) % mod;
            // o 前面可以为 i
            dp[3] = i % mod;
            // u 前面可以为 i  o
            dp[4] = (i + o) % mod;
        }
        long ans = 0;
        for (int j = 0; j < 5; j++) {
            // 第一个 % mod 可以省略, 第二个 % mod 不能省略
            // ans = (ans + dp[j] % mod) % mod;
            ans = (ans + dp[j]) % mod;
        }
        return (int) ans;
    }
}
```

##### 矩阵快速幂



#### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

##### 深度优先搜索（递归实现）

```java
// 深度优先遍历(递归实现)
class P1254_Solution {
    int m, n;

    public int closedIsland(int[][] grid) {
        if (grid == null) {
            return 0;
        }
        this.m = grid.length;
        this.n = grid[0].length;
        if (m == 2 || n == 2) {
            return 0;
        }
        
        int numOfClosedIsland = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    if (dfs(grid, i, j)) {
                        numOfClosedIsland++;
                    }
                }
            }
        }
        return numOfClosedIsland;
    }

    public boolean dfs(int[][] grid, int i, int j) {
        // 超出边界, 说明该岛屿不是封闭的, 返回 false
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return false;
        }
        // 该方格可能是水域(为 1 的情况), 或者是曾经访问过的陆地(为 2 的情况), 返回 true
        if (grid[i][j] != 0) {
            return true;
        }
        grid[i][j] = 2;
        // 上左下右遍历
        // 注意 bl 放在 && 后, 即要先 dfs 得到结果后再与 bl 进行 ‘与’ 操作
        // 当然更不能直接将这四个 dfs && 连接起来
        boolean bl = dfs(grid, i - 1, j);
        bl = dfs(grid, i, j - 1) && bl;
        bl = dfs(grid, i + 1, j) && bl;
        bl = dfs(grid, i, j + 1) && bl;
        return bl;
    }
}
```

##### 广度优先搜索（队列实现）

> 待后续补充

##### 并查集

#### [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

##### 广度优先搜索（队列实现） + 贪心算法

> [参考链接](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution/wang-ge-zhong-de-zui-duan-lu-jing-bfssuan-fa-shi-x/)
>
> 他人评论——
>
> 传统BFS：如果点A已经在visited里，那我们就不会第二次加入点A
>
> 本题：如果点A已经在visited里，但是这次我们到点A的路径上碰到的障碍物比上次少，那我们要把点A加入queue

```java
// 广度优先搜索(队列实现) + 贪心算法
class P1293_Solution {
    public int shortestPath(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        // 只有一个方格, 由于 k 是大于等于 1 的, 不管该方格是不是障碍物, 都能通过
        if (m == 1 && n == 1) {
            return 0;
        }
        // 最后一个(右下角)为障碍物, 先将其消除, k 要减 1
        if (grid[m - 1][n - 1] == 1) {
            grid[m - 1][n - 1] = 0;
            k--;
        }
        // 三维标记数组
        // visited[i][j][0] 该方格历史最优剩余能消除障碍物的次数 剩余次数越多, 越有价值(此处贪心, 记录局部最优)
        // visited[i][j][1] 该方格当前此次剩余能消除障碍物的次数
        int[][][] visited = new int[m][n][2];
        // visited[i][j][0] 初始状态为 -1, 不需要初始化 visited[i][j][1]
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited[i][j][0] = -1;
            }
        }

        // 初始化起始点(0, 0)处的 visited[0][0][0] 和 visited[0][0][1] 值为 k , 表示起始点处的
        // (历史最大消除次数 visited[0][0][0]) 和 (从当前该方格出发能够消除的次数 visited[0][0][1])
        visited[0][0][0] = k;
        visited[0][0][1] = k;
        // 构造队列
        Queue<Integer> queue = new LinkedList<>();
        // 初始化队列, 将起始点(0, 0)入队, 0 = 行号 * n + 列号
        queue.add(0);
        // 初始化最短路径步数为 0
        int minSteps = 0;
        // 四个方向
        final int[] dx = new int[]{-1, 1, 0, 0};
        final int[] dy = new int[]{0, 0, -1, 1};
        // BFS 的队列实现 + 贪心
        while (!queue.isEmpty()) {
            // 等于遍历的层数, 每进入一次 while, 表示走了一步
            minSteps++;
            // 提前获取该层需要出队多少个的个数
            // 遍历相同层级下所有节点
            int size = queue.size();
            // 当前方格的 id、横坐标、纵坐标、从该方格出发能够消除障碍的次数
            int id, curX, curY, obsNum;
            for (int i = 0; i < size; i++) {
                // 出队
                id = queue.remove();
                curX = id / n;
                curY = id % n;
                // 从该方格出发能够消除障碍的次数
                obsNum = visited[curX][curY][1];
                // 当前 id 方格相邻的四个方格的 横纵坐标
                int x, y;
                for (int j = 0; j < 4; j++) {
                    x = curX + dx[j];
                    y = curY + dy[j];
                    // 在 grid 内, 不要越界
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        // id 方格的下一步就是终点(右下角), 返回 minSteps, 此为最短路径(步数)
                        if (x == m - 1 && y == n - 1) {
                            return minSteps;
                        }
                        // 如果当该方格为障碍物, 并且到达 id 方格时还能穿越障碍物的次数已经为 0, 则不能再穿越此方格(障碍物)了
                        if (grid[x][y] == 1 && obsNum == 0) {
                            continue;
                        }
                        // 如果该方格是障碍物, 则将其变成可以通过的方格, 并更新其还能消除障碍物的次数
                        // visited[x][y][1] = grid[x][y] == 1 ? obsNum - 1 : obsNum; // 貌似不需要 newObsNum 也可以
                        int newObsNum = grid[x][y] == 1 ? obsNum - 1 : obsNum;
                        // 以下三段代码取其一, 都是正确的, 逻辑不同而已
/*                        // 1. 是第 2 段代码的简化
                        // 如果该方格已被访问过(可能该方格是障碍物, 但是可能曾经通过将其转变为可以通过的方格被访问过)
                        // 并且当前 visited 记录的历史访问该方格时剩余消除障碍物最大次数 > 当前搜索节点层级的剩余消除次数
                        // 如果将其加入队列, 也很有可能得不到更优解了
                        // 因此不更新该方格的 visited 历史值, 此方格也不加入队列, 直接进行下次循环
                        // 反之, 则更新 visited[x][y][0] 和 visited[x][y][1] 为 newObsNum, 并将该方格加入队列
                        // hi, 真是奇怪, 如果将 ">=" 改为 ">", 会出现问题
                        if (visited[x][y][0] != -1 && visited[x][y][0] >= newObsNum) {
                            continue;
                        } else {
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                        }
                        // 此处, 该方格可能曾经从未被访问过, 也可能被访问过
                        // 但是不管何种情况, visited[x][y][0] 和 visited[x][y][0] 均已在上一个 if 判断中更新
                        // 现在只需入队即可
                        //queue.add(x * n + y);*/

/*                        // 2. 比第 1 段好理解的, 但是也比第 1 段多了些重复代码
                        // 上一个 if - else 也可理解为 :
                        // 如果被访问过, 贪心一下, 看通过该方格是否有可能得到更优解, 判断方式是
                        if (visited[x][y][0] != -1) {
                            // 如果此次剩余消除次数没有以前保存的历史消除次数值大, 则认为以更小的消除次数从这个方格出发到达终点
                            // 得到的结果(最短路径步数)
                            // 也不会比以 [已经保存在 visited[x][y][0] 中的这个历史的更大消除次数值的] 这种状态的这个方格出发
                            // 到达终点得到的结果更优
                            // 于是, 不更新, 不入队, 直接下次循环
                            // 这个是大于等于还是等于差别这么大吗?
                            if (visited[x][y][0] >= newObsNum) {
                                continue;
                            } else {
                                // 反之, 如果此次的还能消除障碍的次数更大, 则可能通过该方格去尝试, 能够得到更优解
                                // 于是, 更新 visited 数组值, 并入队
                                visited[x][y][1] = newObsNum;
                                visited[x][y][0] = newObsNum;
                            }
                        } else {
                            // 如果没被访问过, 直接给 visited 数组赋值, 然后入队
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                        }
                        // 此处, 该方格可能曾经从未被访问过, 也可能被访问过
                        // 但是不管何种情况, visited[x][y][0] 和 visited[x][y][0] 均已在上一个 if 判断中更新
                        // 现在只需入队即可
                        //queue.add(x * n + y);*/

                        // 3. 这种也是对的
                        // 由于除了起始方格处的 visited[x][y][0] 值为 k, 其余各方格处的该值初始值都为 -1,
                        // 而 newObsNum 肯定是大于等于 0 的, 肯定比初始值 -1 大,
                        // 又由于需要贪心保证 visited[x][y][0] 能够成为更大值时, 才有可能得到更优解, 才更新其值以及入队
                        // 所以当遇到比 历史保存值(消除障碍数)更大的值时, 就更新该方格的 visited 值, 以及入队
                        // 如果没有, 就什么都不做
                        if (visited[x][y][0] < newObsNum) {
                            visited[x][y][1] = newObsNum;
                            visited[x][y][0] = newObsNum;
                            queue.add(x * n + y);
                        }
                    }
                }
            }
        }
        // 未找到路径, 返回 -1
        return -1;
    }
}
```

##### 深度优先搜索 + 记忆化

> 原因在于第二列,在回溯后， 从(6,1)本该拆除(7,1)的障碍物, 但是实际执行时
> 由于 memo[9][1]\memo[8][1]\memo[7][1] 这三个位置在回溯(9,0)(8,0)(7,0)方格时记录值由3变为了4，
> 而当真正回溯到(6,1)时，它不会往下走(7,1)了，虽然此时的 k == 4
>
> 于是有了 if (k >= memo[i][j] || (j == n - 1 && d == 2 && memo[i - dx[d]][j - dy[d]] == memo[i][j])) {}
>
> 此行判断条件的多种情况
>

#### [1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)

##### 基本操作、有些脑筋急转弯

```java
// 直接判断, 有些脑筋急转弯了, 本以为很麻烦的
class P1332_Solution {
    // 官方写法
    public int removePalindromeSub1(String s) {
        int n = s.length();
        for (int i = 0; i < n / 2; i++) {
            // 如果该字符串本身不是回文串, 此时只需删除 2 次即可,
            // 比如可以先删除所有的 ‘a’, 再删除所有的 ‘b’, 删除次数为 2
            if (s.charAt(i) != s.charAt(n - i - 1)) {
                return 2;
            }
        }
        // 如果整个字符串是回文串, 此时只需删除 1 次即可，删除次数为 1
        return 1;
    }

    // 他人 (时间复杂度差不多O(N), 空间复杂度O(N))
    public int removePalindromeSub(String s) {
        int n = s.length();
        // 如果该字符串本身不是回文串, 此时只需删除 2 次即可,
        // 比如可以先删除所有的 ‘a’, 再删除所有的 ‘b’, 删除次数为 2
        // 如果整个字符串是回文串, 此时只需删除 1 次即可，删除次数为 1
        return new StringBuilder(s).reverse().toString().equals(s) ? 1 : 2;
    }
}
```

#### [1342. 将数字变成 0 的操作次数](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/)

##### 基本操作

```java
class P1342_Solution {
    // 使用余除运算
    public int numberOfSteps1(int num) {
        int ans = 0;
        while (num > 0) {
            if (num % 2 == 0) {
                num /= 2;
            } else {
                num--;
            }
            ans++;
        }
        return ans;
    }

    // 使用位运算
    public int numberOfSteps(int num) {
        int ans = 0;
        while (num > 0) {
            if ((num & 1) == 0) {
                num >>= 1;
            } else {
                num ^= 1;
            }
            ans++;
        }
        return ans;
    }
}
```



#### [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)

##### 深度优先搜索（递归实现）（超时未完成）

> 此题相当于求最短路径，使用DFS会超时

```java
// DFS, 超时, 未通过 LeetCode 所有测试
class P1368_Solution1 {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除, 已包含在 dfs 中
        if (m == 1 && n == 1) {
            return 0;
        }

        return dfs(0, 0);
    }

    private int dfs(int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return maxCost;
        }
        if (i == m - 1 && j == n - 1) {
            return 0;
        }
        if (grid[i][j] > 4) {
            return maxCost;
        }

        // 保存该方格的值, 走的方向
        int direction = grid[i][j];
        // +4, 代表已访问
        grid[i][j] += 4;
        // 初始化为最大花费
        int minCost = maxCost;

        for (int k = 0; k < 4; k++) {
            if (k == direction - 1) {
                minCost = Math.min(minCost, dfs(i + dx[k], j + dy[k]));
                if (minCost == 0) {
                    break;
                }
            } else {
                minCost = Math.min(minCost, dfs(i + dx[k], j + dy[k]) + 1);
            }
        }
        // 回溯
        grid[i][j] -= 4;
        return minCost;
    }
}
```

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索（队列实现）
class P1368_Solution3 {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost1(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        // int[][] num = new int[m][n];
        int count = 0;
        int[][] dp = new int[m][n];
        for (int[] row : dp) {
            Arrays.fill(row, maxCost);
        }
        dp[0][0] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(0);

        int id, i, j;
        while (!queue.isEmpty()) {
            id = queue.remove();
            i = id / n;
            j = id % n;
            // num[i][j]++;
            count++;
            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    minCost = dp[i][j] + (grid[i][j] == k + 1 ? 0 : 1);
                    // System.out.println(Arrays.deepToString(dp));
                    if (minCost < dp[x][y]) {
                        queue.add(x * n + y);
                        dp[x][y] = minCost;
                    }
                }
            }
        }

        // System.out.println(Arrays.deepToString(dp));
        // System.out.println(Arrays.deepToString(num));
        System.out.println(count);
        return dp[m - 1][n - 1];
    }

    // 优化-SPFA, 但是貌似效果并不明显
    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        int[][] cost = new int[m][n];
        for (int[] row : cost) {
            Arrays.fill(row, maxCost);
        }
        cost[0][0] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(0);
        // 需要记录当前(i,j)是否在队列中, 可以新建一个数组来记录, 亦或者通过改变 grid[i][j] 处的值来标记是否访问(是否在队列中)
        // 表示在队列中
        grid[0][0] += 4;

        int id, i, j;
        while (!queue.isEmpty()) {
            id = queue.remove();
            i = id / n;
            j = id % n;

            // 表示不在队列中
            grid[i][j] -= 4;

            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    // 是顺方向的没有代价(不加 1)
                    if (grid[i][j] == k + 1 || grid[i][j] == k + 5) {
                        minCost = cost[i][j];
                    } else {
                        minCost = cost[i][j] + 1;
                    }

                    // 如果要此次从 (i,j) 到 (x,y), 更新, 那么应当比曾经到 (x,y) 的代价要更小
                    // 即 minCost < cost[x][y] 时, 找到新的一条到 (x,y) 的代价更小的路径, 则需要更新其代价值
                    // 如果当前方格 (x,y) 已经在队列中, 即随后就会遍历它时, 可以不将它入队, 只需要更新其代价值
                    // 而如果不在队列中, 由于此次又更新了它的代价值(更小了), 那么就有可能通过方格(x,y) 而找到距离终点代价值更小的路径
                    // 故需要将其加入队列中

                    // 其实正常的思路是, 四个方向都应该加入队列, 但是有代价值更小以及当前队列中不需要重复遍历同一个方格
                    // 当队列中没有该方格(后续不会遍历该方格)时, 才将其加入队列
                    if (minCost < cost[x][y]) {
                        cost[x][y] = minCost;
                        if (grid[x][y] <= 4) {
                            queue.add(x * n + y);
                            // 表示在队列中
                            grid[x][y] += 4;
                        }
                    }
                }
            }
        }

        return cost[m - 1][n - 1];
    }

    private boolean inArea(int i, int j) {
        return i >= 0 && i < m && j >= 0 && j < n;
    }
}
```

##### Dijkstra 算法（优先级队列实现）（次优解法）

```java
// Dijkstra 算法(优先级队列实现)(次优解法)
class P1368_Solution4 {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        int[][] cost = new int[m][n];
        for (int[] row : cost) {
            Arrays.fill(row, maxCost);
        }
        cost[0][0] = 0;

        // 优先队列(小顶堆)
        // PriorityQueue<Node> queue = new PriorityQueue<>((n1, n2) -> n1.cost - n2.cost);
        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(n -> n.cost));
        queue.add(new Node(0, 0));

        int id, i, j;
        while (!queue.isEmpty()) {
            // 每次出队都是选择距离起点最短的节点, 遍历该节点的四个方向的节点, 更新这四个方向的节点到通过该节点到起点的距离
            // 如果找到距离起点更近的节点, 则将其添加进队列
            // 由于此队列是优先级队列, 下次出队时会自动选择能够构建最短路径的节点, 继续遍历
            id = queue.remove().id;
            i = id / n;
            j = id % n;

            // 需要记录当前(i,j)距离起点的距离最小值是否得到, 可以新建一个数组来记录, 亦或者通过改变 grid[i][j] 处的值来标记是否访问过(是否得到)
            // 如果已经访问过, 不再访问
            if (grid[i][j] > 4) {
                continue;
            }
            // 置为已经访问过, 起点(0,0)到当前节点(i,j)的距离已经在节点(i,j)添加到队列中时确定, 并且该路径是到目前为止的最短路径
            grid[i][j] += 4;

            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    // 是顺方向的没有代价(不加 1)
                    minCost = cost[i][j] + (grid[i][j] == k + 5 ? 0 : 1);

                    // 如果要此次从 (i,j) 到 (x,y), 更新, 那么应当比曾经到 (x,y) 的代价要更小
                    // 即 minCost < cost[x][y] 时, 找到新的一条到 (x,y) 的代价更小的路径, 则需要更新其代价值
                    // 并将其加入到队列中

                    if (minCost < cost[x][y]) {
                        cost[x][y] = minCost;
                        // 此处肯定 grid[x][y] <= 4
                        queue.add(new Node(x * n + y, cost[x][y]));
                    }
                }
            }
        }

        return cost[m - 1][n - 1];
    }

    private boolean inArea(int i, int j) {
        return i >= 0 && i < m && j >= 0 && j < n;
    }

    static class Node {
        int id;
        int cost;

        public Node(int id, int cost) {
            this.id = id;
            this.cost = cost;
        }

        @Override
        public String toString() {
            return "id:" + id + ", cost:" + cost;
        }
    }
}
```

##### 0-1 广度优先搜索（双端队列实现）（最优解法）

```java
// 0-1 广度优先搜索(双端队列实现)(最优解法)
// 类似 Dijkstra, 貌似就是对 Dijkstra 中优先队列需要排序, 找到最小的代价节点的优化
// 使用双端节点, 每次选择代价为 0 (顺方向)的入队出队, 如果没有顺方向的, 再选择代价为 1 的入队
// 那这么说来其实双端队列就等于两个队列, 不需要代价的加入 0 队列, 需要代价的加入 1 队列, 当队列 0 为空时, 出队 1 队列
// 比起随机的两者添加到同一个队列中, 这种方式能够减少某些节点的入队次数, 从而节省时间消耗
class P1368_Solution {
    int[][] grid;
    int m;
    int n;
    // 右左下上
    final int[] dx = new int[]{0, 0, 1, -1};
    final int[] dy = new int[]{1, -1, 0, 0};
    int maxCost;

    public int minCost(int[][] grid) {
        // 题目保证 grid != null , 不为空
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.maxCost = m + n - 2;
        // 可删除
        if (m == 1 && n == 1) {
            return 0;
        }

        int[][] cost = new int[m][n];
        for (int[] row : cost) {
            Arrays.fill(row, maxCost);
        }
        cost[0][0] = 0;

        // 双端队列
        Deque<Integer> deque = new LinkedList<>();
        deque.add(0);

        int id, i, j;
        while (!deque.isEmpty()) {
            id = deque.removeFirst();
            i = id / n;
            j = id % n;

            // 需要记录当前(i,j)距离起点的距离最小值是否得到, 可以新建一个数组来记录, 亦或者通过改变 grid[i][j] 处的值来标记是否访问过(是否得到)
            // 如果已经访问过, 不再访问
            // 在常规的广度优先搜索中, 每个节点最多被添加进队列一次, 而在 0-1 广度优先搜索中, 每个节点最多被添加进双端队列两次(即队首一次, 队尾一次)
            // 因为我们求的是最短路径, 所以当第一次出队列时, 就将该节点标记为已读, 第二次出队列时就不用再处理了
            if (grid[i][j] > 4) {
                continue;
            }
            // 置为已经访问过, 起点(0,0)到当前节点(i,j)的距离已经在节点(i,j)添加到队列中时确定, 并且该路径是到目前为止的最短路径
            grid[i][j] += 4;

            int x, y;
            int minCost;
            for (int k = 0; k < 4; k++) {
                x = i + dx[k];
                y = j + dy[k];
                if (inArea(x, y)) {
                    // 是顺方向的没有代价(不加 1)
                    minCost = cost[i][j] + (grid[i][j] == k + 5 ? 0 : 1);

                    // 如果要此次从 (i,j) 到 (x,y), 更新, 那么应当比曾经到 (x,y) 的代价要更小
                    // 即 minCost < cost[x][y] 时, 找到新的一条到 (x,y) 的代价更小的路径, 则更新其代价值, 并将其添加到队列中
                    // 而又由于有可能需要代价或者不需要代价
                    // 那么为了先遍历无代价的, 更有可能先走到终点(代价也能最快最小), 可将其加入到队列 0, 而需要代价的加入到队列 1,
                    // 出队时, 只要队列 0 中有节点, 就先出队队列 0 的节点
                    // 这里的队列 0 1 用数据结构 Deque 双端队列来模拟, 分别添加到队列头和队列尾

                    if (minCost < cost[x][y]) {
                        cost[x][y] = minCost;
                        // 此处肯定 grid[x][y] <= 4
                        if (grid[i][j] == k + 5) {
                            deque.addFirst(x * n + y);
                        } else {
                            deque.addLast(x * n + y);
                        }
                    }
                }
            }
        }

        return cost[m - 1][n - 1];
    }

    private boolean inArea(int i, int j) {
        return i >= 0 && i < m && j >= 0 && j < n;
    }
}
```

#### [1405. 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/)

##### 贪心

```java
// 不知道采取了何种方法, 看了官方题解后, 原来是贪心
// 0ms 100%
class P1405_Solution {
    int[] abcNum;
    // 对应于 abcNum 中保存的 a,b,c 的下标
    static final int A = 0;
    static final int B = 1;
    static final int C = 2;

    public String longestDiverseString(int a, int b, int c) {
        // 可删除
        if (a == 0 && b == 0 && c == 0) {
            return "";
        }
        this.abcNum = new int[]{a, b, c};
        final String[] str = new String[]{"a", "b", "c", "aa", "bb", "cc"};
        StringBuilder sb = new StringBuilder();
        int addStrIndex = getStrIndex(-1);
        while (addStrIndex != -1) {
            // 添加所剩字符最多的一个或者两个字符到末尾
            sb.append(str[addStrIndex]);
            // 得到下一次是添加到末尾的字符是哪一种, 是一个还是两个
            // pre 表示上一次添加的是 abc 中的哪种字符(下标表示), 函数返回下一次要添加的字符以及个数(对应于 str 数组的索引)
            addStrIndex = getStrIndex(addStrIndex % 3);
        }
        return sb.toString();
    }

    private int getStrIndex1(int pre) {
        int a = abcNum[A];
        int b = abcNum[B];
        int c = abcNum[C];
        int max = -1;
        int mid = -1;
        if (a == b && a == c && a == 0) {
            return -1;
        }
        // a b c 的大小关系
        if (a >= b && a >= c) {
            // a 最大且 a 不等于 0
            max = A;
            if (max != pre) {
                if (a >= 2) {
                    abcNum[max] -= 2;
                    return max + 3;
                } else if (a == 1) {
                    abcNum[max]--;
                    return max;
                }
            }
            if (b >= c) {
                // a >= b >= c
                mid = B;
            } else {
                // a >= c >= b
                mid = C;
            }
        } else if (b >= a && b >= c) {
            // b 最大且 b 不等于 0
            max = B;
            if (max != pre) {
                if (b >= 2) {
                    abcNum[max] -= 2;
                    return max + 3;
                } else if (b == 1) {
                    abcNum[max]--;
                    return max;
                }
            }
            if (a >= c) {
                // b >= a >= c
                mid = A;
            } else {
                // b >= c >= a
                mid = C;
            }
        } else if (c >= a && c >= b) {
            // c 最大且 c 不等于 0
            max = C;
            if (max != pre) {
                if (c >= 2) {
                    abcNum[max] -= 2;
                    return max + 3;
                } else if (c == 1) {
                    abcNum[max]--;
                    return max;
                }
            }
            if (a >= b) {
                // c >= a >= b
                mid = A;
            } else {
                // c >= b >= a
                mid = B;
            }
        }
        // max == pre 时
        if (abcNum[mid] > 2) {
            if (abcNum[mid] * 2 < abcNum[max]) {
                abcNum[mid]--;
                return mid;
            } else {
                abcNum[mid] -= 2;
                return mid + 3;
            }
        } else if (abcNum[mid] == 1 || abcNum[mid] == 2) {
            // 此处当 abcNum[mid] == 2 时, 不要一次添加两个字符, 否则会出错(0,8,11)、(0,2,4)、(0,2,3)
            abcNum[mid]--;
            return mid;
        } else {
            return -1;
        }
    }

    // 代码逻辑优化
    private int getStrIndex(int pre) {
        int a = abcNum[A];
        int b = abcNum[B];
        int c = abcNum[C];
        // 最多字符和次多字符的位置(0,1,2)
        int max, mid;
        if (a == 0 && b == 0 && c == 0) {
            return -1;
        }
        // a b c 的大小关系
        if (a >= b && a >= c) {
            // a 最大且 a 不等于 0
            // a >= b >= c 或 a >= c >= b
            max = A;
            mid = b >= c ? B : C;
        } else if (b >= a && b >= c) {
            // b 最大且 b 不等于 0
            // b >= a >= c 或 b >= c >= a
            max = B;
            mid = a >= c ? A : C;
        } else {
            // c 最大且 c 不等于 0
            // c >= a >= b 或 c >= b >= a
            max = C;
            mid = a >= b ? A : B;
        }
        // 返回此次应当添加那种字符以及几个(对应于 str 数组的索引)
        return func(max, mid, pre);
    }

    private int func(int max, int mid, int pre) {
        // max != pre 时, 表示当前最多字符与上一次添加的字符不是同一个字符, 那么接下来这次就可以添加这个现有字符最多的字符
        // 而添加一个还是两个该字符则由它的个数 abcNum[max] 决定
        if (max != pre) {
            if (abcNum[max] >= 2) {
                abcNum[max] -= 2;
                return max + 3;
            } else if (abcNum[max] == 1) {
                abcNum[max]--;
                return max;
            }
        }
        // max == pre 时 表示当前最多字符与上一次添加的字符是同一个字符, 那么此次就不能添加这个上次添加过的字符, 而应当添加次多的字符
        // 而添加一个还是两个该字符则由它的个数 abcNum[mid] 以及与最多字符的个数 abcNum[max] 之间的关系共同决定
        if (abcNum[mid] > 2) {
            // 这一步是关键, < 或者 <= 都正确
            // 如果最多字符的个数 abcNum[max] 比次多字符的个数的两倍都多, 那么就要减缓添加次多字符的速度, 即只添加一个
            // 至于为何这样, 我也没有一个理性的认识, 只是感觉如此
            if (abcNum[mid] * 2 < abcNum[max]) {
                abcNum[mid]--;
                return mid;
            } else {
                abcNum[mid] -= 2;
                return mid + 3;
            }
        } else if (abcNum[mid] == 1 || abcNum[mid] == 2) {
            // 此处当 abcNum[mid] == 2 时这种情况, 不要将其放到上个条件判断中
            // 在上个条件判断中, 在最后 'b' 字符个数为 2 时, 会一次添加两个字符, 这样就出错了
            // 错误案例(0,8,11)
            // (0,2,4)、(0,2,3) 这两个案例是最后的某种状态, 之前添加的是 'c', 现在应当添加 'b'
            // 而如果一次添加两个 'b', 最终 'c' 就会有剩余(未添加)
            abcNum[mid]--;
            return mid;
        } else {
            // 次多字符个数为 0, 返回 -1, 不能再添加了
            return -1;
        }
    }
}
```



#### [1411. 给 N x 3 网格图涂色的方案数](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/)

##### 递推

##### 动态规划

```java
class P1411_Solution {
    public int numOfWays(int n) {
        final int divisor = 1000000007;
        long numABC;
        long numABA;
        // dp[0] 表示从前到这一行的三种颜色不一样(ABC)的情况的个数
        // dp[1] 表示从前到这一行的有两种颜色(ABA)的情况的个数
        long[] dp = new long[2];
        dp[0] = 6;
        dp[1] = 6;
        for (int i = 1; i < n; i++) {
            // 保存上一行的 ABC 和 ABA 情况
            numABC = dp[0];
            numABA = dp[1];

            // 下一行的 ABC 情况为上一行的 ABC 的 2 倍 + ABA 的 2 倍
            dp[0] = (numABC + numABA) * 2 % divisor;
            // 下一行的 ABA 情况为上一行的 ABC 的 2 倍 + ABA 的 3 倍
            dp[1] = (numABC * 2 + numABA * 3) % divisor;
        }
        // 返回两数之和
        return (int) (dp[0] + dp[1]) % divisor;
    }
}
```

#### [1414. 和为 K 的最少斐波那契数字数目](https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/)

##### 我的解法 - 递归 DFS

```java
// 我的解法 - 递归
// 2 ms 60.57%
class P1414_Solution1 {
    List<Integer> fibonacci;

    public int findMinFibonacciNumbers(int k) {
        fibonacci = new ArrayList<>();
        // 动态规划, 求出所有小于等于 k 的 fibonacci 数, 将其添加进 fibonacci 数组中
        fibonacciDP(k);
        // System.out.println(fibonacci);
        return getMinFibonacciNumbers(fibonacci.size() - 1, k);
    }

    public void fibonacciDP(int k) {
        int first = 1;
        int second = 1;
        fibonacci.add(first);
        fibonacci.add(second);
//        // 第一种写法
//        // 先计算(当前次要添加的 fibonacci 数), 当前次添加
//        int cur;
//        while (first + second <= k) {
//            // 当前次要添加进 fibonacci 数组的数
//            cur = first + second;
//            first = second;
//            second = cur;
//            fibonacci.add(cur);
//        }
        // 第二种写法, 变换一下代码顺序
        // 先添加(上次计算出的 fibonacci 数), 再计算(下次要添加的 fibonacci 数)
        int cur = first + second;
        while (cur <= k) {
            fibonacci.add(cur);
            first = second;
            second = cur;
            // 下一次要添加进 fibonacci 数组的数
            cur = first + second;
        }
    }

    public int getMinFibonacciNumbers(int index, int k) {
        int res = 0;
        for (int i = index; i >= 0; i--) {
            // 刚好相等, 说明找到, 返回 1(表示一个数)
            // 不能使用 fibonacci.contains(k) 来判断, 这样更慢
            if (fibonacci.get(i) == k) {
                return 1;
            }
//            // 数组中的数比 k 大, 进行下次循环, 找一个比 k 更小的数再 dfs
//            if (fibonacci.get(i) > k) {
//                continue;
//            }
//            // 数组中的数比 k 小, 就从当前位置处往前找是否存在等于 k - fibonacci.get(i) 的数
//            res = getMinFibonacciNumbers(i, k - fibonacci.get(i));
//            // 根据返回值 res 判断此次是否找到, 如果找到则说明找到了和为 k 的斐波那契数字的最少数目, 就退出循环
//            if (res > 0) {
//                break;
//            }

            // 代码简化
            // 数组中的数比 k 小, 就从当前位置处往前找是否存在等于 k - fibonacci.get(i) 的数
            // 如果比 k 大, 进行下次循环, 找一个比 k 更小的数再 dfs
            if (fibonacci.get(i) < k) {
                res = getMinFibonacciNumbers(i, k - fibonacci.get(i));
                // 根据返回值 res 判断此次是否找到, 如果找到则说明找到了和为 k 的斐波那契数字的最少数目, 就退出循环
                if (res > 0) {
                    break;
                }
            }
        }
        return res > 0 ? res + 1 : 0;
    }
}
```

##### 官方解法 - 贪心

```java
// 官方解法 - 贪心
class P1414_Solution {
    public int findMinFibonacciNumbers(int k) {
        List<Integer> f = new ArrayList<>();
        f.add(1);
        int a = 1, b = 1;
        while (a + b <= k) {
            int c = a + b;
            f.add(c);
            a = b;
            b = c;
        }
        int ans = 0;
        for (int i = f.size() - 1; i >= 0 && k > 0; i--) {
            int num = f.get(i);
            if (k >= num) {
                k -= num;
                ans++;
            }
        }
        return ans;
    }
}

/**
 * 贪心
 * 作者：AC_OIer
 * 链接：https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-rgty8/
 * 来源：力扣（LeetCode）
 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 */
class P1414_Solution {
    public int findMinFibonacciNumbers(int k) {
        int a = 1, b = 1;
        while (b <= k) {
            int c = a + b;
            a = b; b = c;
        }
        int ans = 0;
        while (k != 0) {
            if (k >= b) {
                k -= b; ans++;
            }
            int c = b - a;
            b = a; a = c;
        }
        return ans;
    }
}
```



#### [1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/)

##### 动态规划

```java
// 动态规划
class P1444_Solution {
    public int ways(String[] pizza, int k) {
        final int mod = (int) Math.pow(10, 9) + 7;
        int rows = pizza.length;
        int cols = pizza[0].length();
        int[][][] dp = new int[rows][cols][k + 1];
        int[][] apple = new int[rows + 1][cols + 1];
        // 遍历矩阵, 获取指定右下角矩阵中的苹果数量
/*        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                apple[i][j] = (pizza[i].charAt(j) == 'A' ? 1 : 0)
                        + apple[i + 1][j] + apple[i][j + 1] - apple[i + 1][j + 1];
            }
        }*/
        // 遍历每个小矩阵, 可得到将每个小矩阵切成 1 到 k 块的方案数
        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                // 该矩阵中的苹果数量
                apple[i][j] = (pizza[i].charAt(j) == 'A' ? 1 : 0)
                        + apple[i + 1][j] + apple[i][j + 1] - apple[i + 1][j + 1];
                // 该矩阵中有苹果, 如果没有苹果, 怎么切都没用, 直接下次循环
                if (apple[i][j] > 0) {
                    // 如果只切成一块, 方案数为 1;
                    dp[i][j][1] = 1;
                    // 如果切成 2...k 块, 枚举每种情况横着切和竖着切的方案和 dp[i][j][block]
                    // 本应是 block <= k, 但是如果本身此矩阵内的苹果数就小于要切成的块数 block,
                    // 这种要切成的块数情况不能满足每个块内都有苹果, 于是将结束条件设为
                    // [block <= Math.min(k, apple[i][j])], 可提前结束循环
                    for (int block = 2; block <= k; block++) {
                        // 横着切
                        // horCutNum 横着切的次数
                        for (int horCutNum = (rows - 1) - i; horCutNum >= 1; horCutNum--) {
                            // 如果当前横着切一刀后, 切掉的 [上边] 矩阵内有苹果, dp[i][j][block] 的值
                            // 应加上被切掉后剩下的 [下边] 矩阵切成 block - 1 块的方案数值
                            // 如果没有苹果, 说明此条 [水平线] 不能切, 接着循环判断下一条
                            if (apple[i][j] - apple[i + horCutNum][j] > 0) {
                                dp[i][j][block] = (dp[i][j][block] + dp[i + horCutNum][j][block - 1]) % mod;
                            }
                        }
                        // 竖着切
                        // verWaysNum 竖着切的次数
                        for (int verWaysNum = (cols - 1) - j; verWaysNum >= 1; verWaysNum--) {
                            // 如果当前竖着切一刀后, 切掉的 [左边] 矩阵内有苹果, dp[i][j][block] 的值
                            // 应加上被切掉后剩下的 [右边] 矩阵切成 block - 1 块的方案数值
                            // 如果没有苹果, 说明此条 [垂直线] 不能切, 接着循环判断下一条
                            if (apple[i][j] - apple[i][j + verWaysNum] > 0) {
                                dp[i][j][block] = (dp[i][j][block] + dp[i][j + verWaysNum][block - 1]) % mod;
                            }
                        }
                    }
                }
            }
        }
        // 返回将整个大矩阵切成 k 块的方案数
        return dp[0][0][k];
    }
}
```

> 给我做了一天，最后还是看别人的做的

#### [1447. 最简分数](https://leetcode-cn.com/problems/simplified-fractions/)

##### 数学题

```java
// 数学题 官方解 20 ms 55.32%
class P1447_Solution {
    public List<String> simplifiedFractions(int n) {
        List<String> ans = new ArrayList<>();
        for (int denominator = 2; denominator <= n; denominator++) {
            for (int numerator = 1; numerator < denominator; numerator++) {
                if (gcd(numerator, denominator) == 1) {
                    ans.add(numerator + "/" + denominator);
                }
            }
        }
        return ans;
    }

    // 欧几里得算法 求分子分母的最大公约数
    // 没看懂怎么求出来的
    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
}
```



#### [1462. 课程表 IV](https://leetcode-cn.com/problems/course-schedule-iv/)

##### 深度优先搜索（递归实现）

> 截止到2021.12.14，超过100%

```java
// 深度优先搜索(递归实现)
class P1462_Solution {
    // 答案链表
    List<Boolean> ans;
    // 邻接表构造有向图
    P1462_CourseNode[] adjList;
    // 记忆化是否可达, 1 代表可达, -1 代表不可达, 初始默认值为 0
    // 定义为 byte、short、int 貌似差别也并不大
    // 最开始定义为 boolean类型, 但是参考了他人的代码, 发现超时不能通过全部案例
    int[][] isReachable;

    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
        // 答案链表
        ans = new ArrayList<>(numCourses);
        // 邻接表构造有向图
        adjList = new P1462_CourseNode[numCourses];

        // 记忆化是否可达
        isReachable = new int[numCourses][numCourses];
        // 构建邻接表
        int from, to;
        for (int[] edge : prerequisites) {
            from = edge[0];
            to = edge[1];

            // 记忆可达到
            isReachable[from][to] = 1;
            isReachable[to][from] = -1;

            // 将该边添加进邻接表 adjList
            // 采用头插法构造图, 与注释的三行等价
            adjList[from] = new P1462_CourseNode(to, adjList[from]);
            /*
            P1462_CourseNode toNode = new P1462_CourseNode(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // DFS
        for (int[] query : queries) {
            from = query[0];
            to = query[1];

            if (dfs(from, to)) {
                isReachable[from][to] = 1;
                isReachable[to][from] = -1;
            }
            ans.add(isReachable[from][to] == 1);
        }

        return ans;
    }

    private boolean dfs(int from, int to) {
        if (from == to) {
            return true;
        }
        if (isReachable[from][to] == 1) {
            return true;
        }
        if (isReachable[from][to] == -1) {
            return false;
        }
        // 有向边的起点 from -> 终点 next
        P1462_CourseNode next = adjList[from];

        while (next != null) {
            if (dfs(next.value, to)) {
                isReachable[next.value][to] = 1;
                isReachable[to][next.value] = -1;
                return true;
            }
            next = next.next;
        }

        isReachable[from][to] = -1;
        return false;
    }
}

class P1462_CourseNode {
    // value 为课程编号
    int value;
    P1462_CourseNode next;

    public P1462_CourseNode(int value) {
        this.value = value;
    }

    public P1462_CourseNode(int value, P1462_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

##### 广度优先搜索（队列实现）

> 待定

##### 弗洛伊德（Floyd）算法

```java
// 弗洛伊德(Floyd)算法
// 效率不及 DFS
class P1462_Solution2 {
    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
        // 记忆化是否可达
        boolean[][] isReachable = new boolean[numCourses][numCourses];

        for (int[] edge : prerequisites) {
            isReachable[edge[0]][edge[1]] = true;
        }
        // 中转点
        for (int k = 0; k < numCourses; k++) {
            // 起点
            for (int i = 0; i < numCourses; i++) {
                // 终点
                for (int j = 0; j < numCourses; j++) {
//                    // 如果可达不执行任何操作, 如果不可达则判断通过中转点 k 是否可达
//                    if (!isReachable[i][j]) {
//                        isReachable[i][j] = isReachable[i][k] && isReachable[k][j];
//                    }
                    // 与上等价
                    isReachable[i][j] = isReachable[i][j] || (isReachable[i][k] && isReachable[k][j]);
                }
            }
        }
        // 答案链表
        List<Boolean> ans = new ArrayList<>();
        for (int[] query : queries) {
            ans.add(isReachable[query[0]][query[1]]);
        }
        return ans;
    }
}
```

#### [1494. 并行课程 II](https://leetcode-cn.com/problems/parallel-courses-ii/)

##### 拓扑排序 + 贪心算法（未通过）

##### 动态规划（状态压缩 DP）

```java
// 动态规划: 状态压缩 DP (改进后)
class P1494_Solution {
    public int minNumberOfSemesters(int n, int[][] relations, int k) {
        if (k == 1) {
            return n;
        }
        if (relations.length == 0) {
            return n % k != 0 ? n / k + 1 : n / k;
        }
        // 先修课程 二进制状态压缩
        // pre[i] 保存的是第 i(0到n-1) 门课程的先修课程, 用二进制来表示
        // 例如 i 的先修课程如果是 2 5 7 的话, 则 pre[i] 处保存的值的二进制为 (省略若干个 0 ) 0101 0010, 在第 j(1,4,6) 个位置上的值置为 1
        int[] pre = new int[n];
        // 构造 pre, 通过将 1 左移 (先修课程编号 - 1) 位实现, 这只是一门课程的二进制表示
        // 每当有一门先修课程, 还需要将 (1 左移后的二进制值) 与 (pre[i]) 进行 '或' 运算
        // 例如, 现有三个 relation: (2,1)(5,1)(7,1) , 表示课程 1 有三门先修课程, 分别是 2, 5, 7
        // 初始时: pre[1-1] = pre[0] = 0000 0000
        // 第 1 次: 1 << (2 - 1) = 0000 0010, 此时 pre[0]: 0000 0000 | 0000 0010 = 0000 0010
        // 第 2 次: 1 << (5 - 1) = 0001 0000, 此时 pre[0]: 0000 0010 | 0001 0000 = 0001 0010
        // 第 3 次: 1 << (7 - 1) = 0100 0000, 此时 pre[0]: 0001 0010 | 0100 0000 = 0101 0010
        // 最终得到课程 1(pre 中下标为 0) 的所有先修课程的集合(只是这个集合是以一个二进制形式保存而已, 更重要的是方便取其集合子集)
        for (int[] relation : relations) {
            pre[relation[1] - 1] |= 1 << (relation[0] - 1);
        }
        // 动态规划, 求出每种状态下的最少学习学期数
        // 总状态数 N, 状态可理解为现有 n 门课程, 每门课程有两种情况(可能已学习, 也可能未学习), 共计 2^n = 1 << n 种状态
        final int N = 1 << n;
        // dp[mask] 表示修完 mask 代表的所有课程的最少学习学期数
        // 动态规划就会遍历这 N 种状态, 得到每种状态下的最少学习学期数
        int[] dp = new int[N];
        // 对 dp 数组赋初值, 题目保证能全部修完, 初始化为最大值 n (或 >n 的数)即可
        // 因为不管有多少门课程, k(k>=1) 为多少, n 门课程最多不过 n 学期就能学完
        Arrays.fill(dp, n);
        // 当然对于 dp[0], 即状态 mask == 0, 代表学习 0 门课程的最少学习学期数, 当然是 0, 其余的情况未知, 设为最大值 n
        // 假设为 4 门课程, 初始 0 门课需要 0 学期 dp[0000] = 0, 最终目标是求 dp[1111]
        dp[0] = 0;

        // 其实上面还是没有完全讲清楚 2^n 种状态中的状态到底是什么, 每一种状态 mask 可以理解为
        // 假设现在学习了 (mask的二进制代表的) 这 m 门课程的情况下, 还能从剩下的还未学习的课程中学习哪些课程? 学习多少门课程?
        // 而能够学习的这些课程(肯定它的先修课程已经学完了, 已经存在 mask的二进制 中了)总数可能超过 k
        // 即便没有超过 k, 那学习哪几门课程呢? 这里就会产生多种学习课程组合, 而通过二进制保存的形式, 又能很方便地得到种种组合

        // (mask的二进制代表的)这 m 门课程 是指
        // mask 的值范围为 (0, 2^n), 对于其中一种特定的状态, 一个特定的 mask 值
        // 例如 mask 为 18 = 0001 0010 时, dp[mask] 表示学习(第 2 门课程 和 第 5 门课程)需要学习的最少学期数
        // 但是在以 mask = 18 的遍历过程中, 并不是理解成此轮循环是在求 dp[mask](dp[18])
        // 而是求在假定已经学习了 (课程 2 和 课程 5) 的情况下
        // 若还能学习其它若干门课程, 那么学习这 (课程 2 和 课程 5 以及加上这若干门课程) 的最少学习学期数 dp[newMask]
        // newMask 为 0001 0010 '或上' 这若干门课程集合的二进制表示

        // 优化 2, 使用 cnt 数组, 替代 if (Integer.bitCount(toStudy) <= k) 判断, 改为 if (cnt[toStudy] <= k)
        // cnt 表示 2^n 种情况, 2^n 个二进制数中 1 的个数
        // 即将每次都要计算 toStudy 的二进制数有多少个这个事件提前处理了, 通过数组保存下来, 当遇到时直接查阅与 k 比较即可
        int[] cnt = new int[N];
        cnt[0] = 0;
        for (int i = 1; i < N; i++) {
            // 这个算法很奇妙, 没细看, 我也不懂
            cnt[i] = cnt[i >> 1] + (i & 1);
        }

        // 遍历这 2^n 种状态
        for (int mask = 0; mask < N; mask++) {
            // 与优化 1-1 等价的优化 1-2, 也就是优化 1 那里的多行代码可以替换为 这里的三行代码, 达到同样的效果
            // 此处这么处理的原因在于, 当当前要遍历 mask 状态能否学习其它课程时,
            // 如果该处值还为 n, 说明此前遍历小于 mask 的所有状态时都没能通过学习其它课程到达现在这个状态,
            // 即当前 mask 状态是一个不可达状态, 当然也就不能通过该状态再转变为其它状态
            // 这里说的比较抽象, 举个例子, 假设课程 1 的先修课程是 (2,5,7), 某个状态是 (0000 0011)(12)
            // 那么现在能通过这个状态去学习其它课程吗? 显然不能
            // 因为要学习课程 1, 必须得先学完 (2,5,7), 而现在的状态是只学了 (12), 这是不可能的,
            // 即不能达到这个状态, 也不能从这个状态再转变
            // 那为什么达不到这个状态, 这个状态处的值 dp[mask] 就为 n 呢?
            // 因为在遍历前面几个状态 (0000 0000)( )、(0000 0001)(1)、(0000 0010)(2) 时, 都没有改变 dp[(0000 0011)(12)] 的值
            // 举例: 假设初始时这个有向图只有 (2,5,7) 这三个入度为 0 的节点, 它们是 1 的先修课程, 且 k = 2
            // 第 1 次遍历: 遍历 mask == 0(0000 0000) 时, dp[0] = 0, 遍历改变的是 dp[(2)(5)(7)(25)(27)(57)] 这六种状态的值, 均变为 1
            // 第 2 次遍历: 遍历 mask == 1(0000 0001) 时, dp[1] = n, 由于之前的所有遍历中都没有改变过 dp[1] 的值
            //             说明它不可达, 当然也不会更新其它状态值, 可跳过
            // 第 3 次遍历: 遍历 mask == 2(0000 0010) 时, dp[2] = 1, 由于之前的所有遍历中曾改变了 dp[2] 的值, 使得其值并不为 n,
            //             说明可以通过先学习 mask 代表的课程 2, 再学习其它课程达到其它状态, 更新其它状态值
            //             此轮改变的是 dp[(5)(7)(25)(27)(57)(257)] 这六种状态的值
            //             未改变前各值分别为(1,1,1,1,1,n), 更新后各值为(1,1,1,1,1,2)
            //             dp[(0101 0010)(257)] = dp[80] = min(dp[80],dp[2] + 1) = min(n, 1 + 1) = 2
            // 第 4 次遍历: 遍历 mask == 3(0000 0011) 时, dp[3] = n, 同第 2 次遍历一样, 之前的所有遍历中都没有改变过 dp[3] 的值
            //             说明它不可达, 当然也不会更新其它状态值, 可跳过
            // ......
            if (dp[mask] >= n) {
                continue;
            }
            // boolean valid = true;

            // 当前状态下可学习的所有课程集合(二进制表示)
            int canStudy = 0;
            // 得到当前状态下的 n 门课程中可学习的课程集合 canStudy, 设最终课程数为 c
            // 在 mask 表示的已经学习了 m 门课程的状态下, 对于任意一门课程 i(0<=i<n), 是否能学习课程 i 由两个条件决定
            // 条件 1: 课程 i 肯定是要未学习过的, 也就是课程 i 要不在 mask 表示的 m 门已经学过的课程中才又可能去学习它
            // 条件 2: 课程 i 的所有先修课程都已经学习完毕, 也就是所有的先修课程都包含在 mask 表示的 m 门已经学过的课程中
            // 总结: 能学习课程 i, 课程 i 必须保证之前还未学习过(学过了就不学了), 并且它的所有先修课程都已经学习完毕(先修课程没学完就学不了)
            for (int i = 0; i < n; i++) {

                // 条件 1: (mask & (1 << n)) == 0
                // 1 << i, 表示当前正在判断的这门是否能学习的课程 i 的二进制表示(1 的位置)
                // (mask & (1 << i)) != 0, 说明当前这门要学习的课程 i 已经在此次状态 mask 表示的 m 门已学习的课程中
                // 即已经学过它, 跳过, 不学习它; 反之, 则不存在, 后续条件 2 再判断它的先修课程是否已经学完, 学完则说明该课程 i 可以学习

                // 条件 2: (mask & pre[i]) == pre[i]
                // pre[i] 是课程 i 的所有先修课程, mask 是已经学习的所有课程, 现要判断后者是否包含前者, 也就是说在两者的二进制表示中
                // pre[i] 中为 1 的相应位置, mask 中也必须为 1; pre[i]中为 0 的位置, mask 中可能为 0 或 1
                // 将两者进行 & 运算, mask 中的(pre[i] 中为 1 的)相应位置必须也为 1, 除此外的其它位置置为 0, 最终得到的结果如果与 pre[i] 相等
                // 说明 mask 包含课程 i 的所有先修课程(还可能包含其它课程), 将其保存; 反之, 则不包含所有先修课程, 不能学习课程 i
/*                if ((mask & (1 << i)) == 0 && (mask & pre[i]) == pre[i]) {
                    // 课程 i 未学习过, 且 mask 包含课程 i 的所有先修课程, 则可以学习课程 i, 将课程 i 加入集合 canStudy
                    // canStudy 保存 mask 状态下的每一门可以学习的课程, 每有一门, 就将 canStudy 的相应二进制位置为 1, 表示保存
                    // 例如: 总共 n 门课程中能学习 2,5,7 号课程(下标 i 对应为 1,4,6)
                    // 就将 canStudy 的二进制表示 0000 0000 的第 2,5,7 个位置的 0 在三轮循环中依次置为 1
                    // 初始时: canStudy = 0000 0000
                    // 第 1 次, i == 1: 1 << 1 = 0000 0010, 此时 canStudy: 0000 0000 | 0000 0010 = 0000 0010
                    // 第 2 次, i == 4: 1 << 4 = 0001 0000, 此时 canStudy: 0000 0010 | 0001 0000 = 0001 0010
                    // 第 3 次, i == 6: 1 << 6 = 0100 0000, 此时 canStudy: 0001 0010 | 0100 0000 = 0101 0010
                    // 最终 canStudy 为 0101 0010, 表示当前 mask 这种已经学习了 m 门课程的状态下, 能选择学习的课程为 canStudy 表示的课程集合
                    canStudy |= 1 << i;
                }
*/
                // 优化 1-1 是对前面 if 的优化, 当然也可以不使用此处优化, 而选择优化 1-2 也可以, 同时选择优化 1-1 和 1-2 与单选两者之一的效果是一样的
                // 如果 mask 中包含了这门课程 i, 说明已经学习了这门课程 i, 那么 mask 就一定要包含课程 i 的所有先修课程
                // 才能使得 mask 这种状态作为正确的中转的状态, 能够转移到其它的状态, 不然就是不可能状态
                if ((mask & (1 << i)) != 0) {
                    // mask 包含了课程 i, 但是不包含或者不完全包含课程 i 的所有先修课程, 这种状态就是不对的, 可以跳过
                    if ((mask & pre[i]) != pre[i]) {
                        // 也可以设置 dp[i] == n 或者 n + 1; 来退出循环
                        dp[mask] = n;
                        // valid = false;
                        break;
                    }
                } else {
                    // 如果 mask 中不包含这门课程 i, 再根据是否包含这门课程 i 的所有先修课程, 决定是否能学习这门课程
                    // 包含所有先修课程, 则能学习; 反之, 则不能学习
                    if ((mask & pre[i]) == pre[i]) {
                        canStudy |= 1 << i;
                    }
                }
            }
//            // 如果 mask 是错误状态, 不可能存在的状态, 则直接进行下一次循环
//            if (!valid) {
//                continue;
//            }
            if (dp[mask] == n) {
                continue;
            }
            // 在得到了所有可以学习的课程集合 canStudy 后, 现在要学习这 canStudy 表示的若干门课程中的课程
            // 那究竟要学习几门课程、哪些课程呢? 并且由于每次最多学习 k 门课程, 说明选择学习的课程是不是会受到此条件的限制?

            // 假设 canStudy 为前面提到过的 0101 0010, 现在从这三门课程中挑选课程学习, 有多少种情况呢? 也就是 canStudy 有哪些子集合呢?
            // 列举一下, canStudy 代表 2,5,7 号课程, 所有子集合为 (2)(5)(7)(25)(27)(57)(257), 共 2^n-1 = 2^3-1 = 7 种(不包含空集合)
            // 此时根据 k 值的不同要学习的课程组合的情况也就不同, 例如:
            // k == 1 : 可选择 (2)(5)(7)                   | 表示每次只能在这 7 种组合中挑选出不多于 1 门课程的子集合课程进行学习
            // k == 2 : 可选择 (2)(5)(7)(25)(27)(57)       | 表示每次只能在这 7 种组合中挑选出不多于 2 门课程的子集合课程进行学习
            // k == 3 : 可选择 (2)(5)(7)(25)(27)(57)(257)  | 表示每次只能在这 7 种组合中挑选出不多于 3 门课程的子集合课程进行学习
            // k >= 4 : 同 k == 3, 因为总共可学习的课程就是三门, 也就是全部课程都能学习, 所有的组合情况都能学习
            // 以上是对问题思路的解决, 但是用代码怎么实现呢? 怎么枚举出可学习课程的所有子集呢?

            // 以下是一种枚举方法, 不知道谁发明的, 真是奇妙, 可以特别记忆一下
            /* 枚举可学习课程的子集进行状态转移
               例 1: canStudy = 1010(2,4), 其子集有 2^2-1 = 3 种, 用二进制表示为 (1010)(1000)(0010)
               首先子集一定在 (0000, 1010] 范围内, 过程如下
               第 1 个 初始时: 1010(24), 十进制值为 10
               第 2 个 (1010 - 1) & 1010 = 1001 & 1010 = 1000(4), 十进制值为 8
               第 3 个 (1000 - 1) & 1010 = 0111 & 1010 = 0010(2), 十进制值为 2
               第 4 个 (0010 - 1) & 1010 = 0001 & 1010 = 0000( ), 十进制值为 0, 不合法

               例 2: canStudy = 0101 0010, 其子集有 2^3-1 = 7 种
               用二进制表示为 0101 0010(257)、0101 0000(57)、0100 0010(27)、0100 0000(7)、0001 0010(25)、0001 0000(5)、0000 0010(2)
               首先子集一定在 (0000 0000, 0101 0010] 范围内, 过程如下
               第 1 个 初始时: 0101 0010(257), 十进制值为 2^6+2^4+2^1 = 82
               第 2 个 (0101 0010 - 1) & 0101 0010 = 0101 0001 & 0101 0010 = 0101 0000(57), 十进制值为 2^6+2^4+     = 80
               第 3 个 (0101 0000 - 1) & 0101 0010 = 0100 1111 & 0101 0010 = 0100 0010(27), 十进制值为 2^6+   + 2^1 = 66
               第 4 个 (0100 0010 - 1) & 0101 0010 = 0100 0001 & 0101 0010 = 0100 0000(7),  十进制值为 2^6+   +     = 64
               第 5 个 (0100 0000 - 1) & 0101 0010 = 0011 1111 & 0101 0010 = 0001 0010(25), 十进制值为    +2^4+ 2^1 = 18
               第 6 个 (0001 0010 - 1) & 0101 0010 = 0001 0001 & 0101 0010 = 0001 0000(5),  十进制值为    +2^4+     = 16
               第 7 个 (0001 0000 - 1) & 0101 0010 = 0000 1111 & 0101 0010 = 0000 0010(2),  十进制值为    +   + 2^1 = 2
               第 8 个 (0000 0010 - 1) & 0101 0010 = 0000 0001 & 0101 0010 = 0000 0000( ),  十进制值为    +   +     = 0, 不合法
            */
            for (int toStudy = canStudy; toStudy > 0; toStudy = (toStudy - 1) & canStudy) {
                // Integer.bitCount(study) : 二进制 toStudy 中的 1 的个数, 表示此子集代表的课程数量(假设为 t)
                // 如果能学习此子集代表的课程, 则其子集代表的课程的数量 t 必须要 <= k(一次最多能学习的课程数), 才能学习这个子集课程组合
                // 如果大于 k, 说明在 mask 这种已经学习了 m 门课程的状态下, 虽然有 canStudy 代表的 c 门课程可以选择学习
                // 但是不能通过一次学习就学完这种课程数超过 k 的子集代表的这 t 门课程
                if (cnt[toStudy] <= k) {
                    //  if (Integer.bitCount(toStudy) <= k) {
                    // if (bitCount(toStudy) <= k) {
                    // mask | toStudy 表示 [学习了 mask 代表的 m 门课程和学习了 toStudy 代表的 t(<= k) 门课程] 的
                    // 这种 (m+t) 门课程这种唯一一种组合的状态
                    // 每次更新的值 dp[mask | toStudy] 表示学习 mask | toStudy 这种状态的课程组合的最少学习学期数
                    // 其值等于 曾经的历史状态 dp[mask | toStudy] 与 待定想要更新的状态值 两者中的较小值
                    // 而这个待定想要更新的状态值是 在 mask 这种学习了 m 门课程的状态下的值 dp[mask] 通过一次学习操作(学习这 t 门课程, 学期数加 1)转变过来的
                    // 第 1 种理解:
                    // 即已知 dp[mask] 为学习 mask 代表的这 m 门课程的最少学习学期数, 那么现在要学习另外的 t 门课程
                    // 那么完成后的学期数为 dp[mask]+1, 对应的那个状态是 dp[mask | toStudy]
                    // 第 2 种理解:
                    // dp[mask | toStudy] 表示要学习 (m+t) 门的这种课程组合, 可以通过先学 mask 代表的这 m 门课程, 再在这已学 m 的条件下学另外的 t 门课程
                    // 由前一个状态转变过来, 先学 m 的学期数为 dp[mask], 后学 t 门课程, 需要 1 个学期, 其值为 dp[mask]+1
                    // System.out.println("dp[" + mask + " | " + toStudy + "] : " + dp[mask | toStudy]);
                    int newMask = mask | toStudy;
                    // dp[mask | toStudy] = Math.min(dp[mask | toStudy], dp[mask] + 1);
                    dp[newMask] = Math.min(dp[newMask], dp[mask] + 1);
                    // cnt[0]++;
                    // System.out.println("dp[" + mask + " | " + toStudy + "] : " + dp[mask | toStudy]);
                }
            }
            // 通过上面的描述以及理解, 最终可以总结
            // 其实每次遍历一种 mask 状态, 看可以通过它(mask)能够转变到哪些状态(mask | toStudy), 更新能够转变到的那种状态的 dp 值
            // 而如何转变就是学习 canStudy 中的若干个包含小于等于 k 的课程数的课程子集 toStudy, 满足要求的子集数就是更新状态的次数, 也是能够转变到的状态次数
            // 总结: 也就是每一种状态(mask)都可能由之前循环中的许多种不同状态(< mask)转变而来
            // 而每种状态(mask)也可以通过学习满足要求的 toStudy 课程转变到其它状态(mask | toStudy)
        }
        // System.out.println(Arrays.toString(dp));
        // System.out.println("个数" + cnt[0]);
        // 最种要得到的是学完 n 门课程的最少学习学期数, 即在最后那种 n 位二进制的 n 个位置上的值都为 1 的那个状态
        return dp[N - 1];
    }

    // 第一种求二进制中 1 的个数的方法
    // 这个自己写的和源码的效率相差太大了吧
    // 使用源码是 94 ms
    // 使用这个是 886 ms
    private int bitCount(int a) {
        int count = 0;
        while (a != 0) {
            if ((a & 0x1) == 1) {
                count++;
            }
            a = a >> 1;
        }
        return count;
    }

    // 第二种求二进制中 1 的个数的方法 99ms
    private int getBit(int x) {
        int res = 0;
        while (x > 0) {
            res++;
            x = x & (x - 1);
        }
        return res;
    }
}
```

#### [1687. 从仓库到码头运输箱子](https://leetcode-cn.com/problems/delivering-boxes-from-storage-to-ports/)

##### 动态规划 + 单调队列

```java
// 动态规划 + 单调队列
class P1687_Solution {
    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.length;
        // 将前 i 个箱子运送到对应码头需要变更的行程次数(不包括首尾的两次, 只计算中途变更的次数)
        int[] cntSteps = new int[n + 1];
        // 前 i 个箱子的总重量
        int[] sumWeight = new int[n + 1];
        // 没有箱子
        cntSteps[0] = 0;
        sumWeight[0] = 0;
        // 第一个箱子
        cntSteps[1] = 0;
        sumWeight[1] = boxes[0][1];
        // 预处理, 得到 cntSteps 和 sumWeight
        getSumStepsAndSumWeight(boxes, cntSteps, sumWeight);

        System.out.println("cntSteps  : " + Arrays.toString(cntSteps));
        System.out.println("sumWeight : " + Arrays.toString(sumWeight));

        // 单调队列(双端队列)
        Deque<Integer> deque = new LinkedList<>();
        // dp[i] = min(dp[i - 1] + 2, dp[j] + cnt[i] - cnt[j + 1] + 2) = min(dp[i - 1] + 2, dp[j] - cnt[j + 1] + cnt[i] + 2)
        // 等价于求 dp[j] - cnt[j + 1] 的最小值
        int[] dp = new int[n + 1];
        // 将前 0 个箱子运到相应码头的行程数
        dp[0] = 0;
        // 已经得到将前 0 个箱子运到相应码头的行程数, 首次时将 0 入队
        deque.add(0);

        // int diff = dp[0] - cntSteps[1] = 0;
        int diff;
/*
        for (int i = 1; i <= n; i++) {
            // 队列肯定不为空
            while (!deque.isEmpty() && (sumWeight[i] - sumWeight[deque.peek()] > maxWeight || i - deque.peek() > maxBoxes)) {
                // 不是 i - deque.peek() + 1
                // System.out.println("出队首 : " + deque.peek());
                deque.removeFirst();
            }
            // 队列肯定不为空
            if (!deque.isEmpty()) {
                dp[i] = dp[deque.peek()] + cntSteps[i] - cntSteps[deque.peek() + 1] + 2;
                // System.out.println(dp[deque.peek()] + "+" + cntSteps[i] + "-" + cntSteps[deque.peek() + 1] +"+2");
            }
            // System.out.println("dp[" + i + "] == " + dp[i]);
            if (i != n) {
                diff = dp[i] - cntSteps[i + 1];
                while (!deque.isEmpty() && diff < dp[deque.peekLast()] - cntSteps[deque.peekLast() + 1]) {
                    // System.out.println("出队尾 : " + deque.peekLast());
                    deque.removeLast();
                }
                deque.add(i);
                // System.out.println("入队尾 : " + i);
            }
        }
*/
        // 对上种方式的稍稍修改
        int j = 0, k;
        for (int i = 1; i <= n; i++) {
            // 找到最小的 dp[j] - cntSteps[j + 1], 此时得到的 dp[j] + cntSteps[i] - cntSteps[j + 1] + 2 最小, 即 dp[i] 最小
            // 队列肯定不为空
            while (!deque.isEmpty()) {
                j = deque.peek();
                // 移除不满足装运条件的 j, 直到遇到满足装运条件的 j 时退出循环
                if (sumWeight[i] - sumWeight[j] > maxWeight || i - j > maxBoxes) {
                    deque.removeFirst();
                } else {
                    break;
                }
            }

            dp[i] = dp[j] + cntSteps[i] - cntSteps[j + 1] + 2;

            if (i != n) {
                diff = dp[i] - cntSteps[i + 1];
                // 移除使得 dp[k] - cntSteps[k + 1] 大于 dp[i] - cntSteps[i + 1] 的 k
                // dp[i] - cntSteps[i + 1] 为最大时或者队列为空时退出循环, 将 i 入队
                while (!deque.isEmpty()) {
                    k = deque.peekLast();
                    if (diff < dp[k] - cntSteps[k + 1]) {
                        deque.removeLast();
                    } else {
                        break;
                    }
                }
                deque.add(i);
            }
        }

        System.out.println("dp        : " + Arrays.toString(dp));
        return dp[n];
    }

    private void getSumStepsAndSumWeight(int[][] boxes, int[] cntSteps, int[] sumWeight) {
        // 预处理前缀和
        // 从第二个箱子开始遍历
        for (int i = 1; i < boxes.length; i++) {
            // 前 i+1 个箱子运到相应码头所需的总行程(除去出发和返回的 2 次, 只统计变更行程的次数)
            // 例如: 10 个箱子依次要运到这些码头:          1 1 2 2 3 4 1 2 2 5
            // 对应的           cntSteps 值为: (首0填充) 0 0 1 1 2 3 4 5 5 6
            // 那么要运满足要求的其中几个箱子的行程数(出发和返回的 2 次)也就为相应位置处的 cntSteps 的差
            // 如这一次要运 2 2 3 4 1 这五个箱子, 那么中途需要变更行程的情况是 2->3->4->1 共 3 次, 也等于 (4-1)
            // 运送连续的两个或多个相同目的码头(也就是 2 )的箱子的行程数是不增加的
            if (boxes[i][0] != boxes[i - 1][0]) {
                cntSteps[i + 1] = cntSteps[i] + 1;
            } else {
                cntSteps[i + 1] = cntSteps[i];
            }
            // 前 i+1 个箱子的总重量
            sumWeight[i + 1] = sumWeight[i] + boxes[i][1];
        }
    }

    private void getSumStepsAndSumWeight1(int[][] boxes, int[] cntSteps, int[] sumWeight) {
        // 预处理前缀和
        // 从第二个箱子开始遍历
        for (int i = 2; i <= boxes.length; i++) {
            // 前 i 个箱子运到相应码头所需的总行程(除去出发和返回的 2 次, 只统计变更行程的次数)
            // 例如: 10 个箱子依次要运到这些码头:            1 1 2 2 3 4 1 2 2 5
            // 对应的        cntSteps 值为: [(首0填充)] 0 0 1 1 2 3 4 5 5 6
            // 那么要运满足要求的其中几个箱子的行程数(出发和返回的 2 次)也就为相应位置处的 cntSteps 的差
            // 如这一次要运 2 2 3 4 1 这五个箱子, 那么中途需要变更行程的情况是 2->3->4->1 共 3 次, 也等于 (4-1)
            // 运送连续的两个或多个相同目的码头(也就是 2 )的箱子的行程数是不增加的
            if (boxes[i - 1][0] != boxes[i - 2][0]) {
                cntSteps[i] = cntSteps[i - 1] + 1;
            } else {
                cntSteps[i] = cntSteps[i - 1];
            }
            // 前 i 个箱子的总重量
            sumWeight[i] = sumWeight[i - 1] + boxes[i - 1][1];
        }
    }
}
```

#### [1701. 平均等待时间](https://leetcode-cn.com/problems/average-waiting-time/)

##### 简单逻辑 基本操作

```java
class P1701_Solution {
    public double averageWaitingTime(int[][] customers) {
        int n = customers.length;
        // 所有顾客的总等待时间
        double totalWaitingTime = 0;
        // 做完某个顾客的菜后的结束时刻
        double endTime = 0;
        for (int[] customer : customers) {
            // 当前顾客 customer 到来的时刻
            int arrivalTime = customer[0];
            // 做当前顾客 customer 的菜需要的时间
            int cookTime = customer[1];
            // 如果当前顾客 customer 到来时, 厨师已经做完了上一位顾客的菜(期间厨师可能休息了 arrivalTime - endTime 的时间)
            // 那么厨师可以立刻马上就做当前顾客 customer 的菜
            if (arrivalTime >= endTime) {
                // 当前顾客 customer 无需等待厨师做之前到来的顾客的菜, 因为已经在到来之前就做完或者刚好做完了
                // 该顾客只需要等待厨师做自己的这份菜的时间 cookTime
                // 那么到目前为止的所有顾客的总等待时间是 totalWaitingTime = totalWaitingTime + cookTime
                totalWaitingTime += cookTime;
                // 厨师做完当前顾客的这份菜的结束时刻是 当前顾客到来的时间 arrivalTime + 做这道菜的时间 cookTime
                // 也可以理解为
                // 厨师做完上一位顾客的菜的结束时刻 endTime +
                // 厨师等待当前顾客 customer 到来中途休息的时间 arrivalTime - endTime +
                // 厨师做当前顾客 customer 的菜的时间 cookTime
                // 三者之和即为厨师做完当前顾客 customer 的这份菜的结束时刻 endTime = endTime + arrivalTime - endTime + costTime
                endTime = arrivalTime + cookTime;
            } else {
                // 当前顾客到来时, 厨师还在做之前到来的顾客的菜, 因此当前顾客需要等待厨师将之前到来的顾客的菜做完, 才能做当前顾客的菜
                // endTime - arrivalTime 为当前顾客 customer 等待厨师做之前到来的顾客的菜的时间
                // cookTime 为当前顾客 customer 等待厨师做自己的菜的时间
                // 两者之和(endTime - arrivalTime + cookTime) + 之前的所有顾客的等待时间 totalWaitingTime
                // 即为到目前为止的所有顾客的总等待时间
                totalWaitingTime += endTime - arrivalTime + cookTime;
                // 厨师做当前顾客 customer 的菜之前是没有休息的, 是紧接着做的, 因此
                // 厨师做完当前顾客 customer 的这份菜后的结束时刻是
                // 上次结束时刻 endTime + 做当前顾客的菜的时间 cookTime
                endTime += cookTime;
            }
        }
        return totalWaitingTime / n;
    }
}
```

#### [1712. 将数组分成三个子数组的方案数](https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/)

##### 超时

```java
// 超时做法 O(N^2)
class P1712_Solution1 {
    // 超时 O(N^2)
    public int waysToSplit1(int[] nums) {
        int ans = 0;
        int n = nums.length;
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }
        for (int left = 0; left <= n - 3; left++) {
            // for (int right = n - 2; right > left; right--) {
            for (int right = left + 1; right <= n - 2; right++) {
                int leftSum = pre[left + 1];
                int midSum = pre[right + 1] - leftSum;
                int rightSum = pre[n] - pre[right + 1];
                if (leftSum <= midSum && midSum <= rightSum) {
                    System.out.println("left = " + left + ", right = " + right);
                    // ans++;
                    ans = (ans + 1) % 1000000007;
                }
            }

        }
        return ans;
    }

    // 超时 O(N^2)
    public int waysToSplit2(int[] nums) {
        int ans = 0;
        int n = nums.length;
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }
        int firstRight = 1;
        for (int left = 0; left <= n - 3; left++) {
            // 错误语句
//            if (firstRight == -1) {
//                break;
//            }
            int right = firstRight;
            firstRight = -1;
            int leftSum = pre[left + 1];
            // for (int right = n - 2; right > left; right--) {
            for (; right <= n - 2; right++) {
                int midSum = pre[right + 1] - leftSum;
                int rightSum = pre[n] - pre[right + 1];
                if (leftSum <= midSum && midSum <= rightSum) {
                    System.out.println("left = " + left + ", right = " + right);
                    // ans++;
                    ans = (ans + 1) % 1000000007;
                    if (firstRight == -1) {
                        firstRight = right;
                    }
                }
            }
        }
        return ans;
    }
}
```

##### 前缀和 + 二分查找

```java
// 前缀和 + 二分查找
// O(N log N)
class P1712_Solution2 {
    // 60 ms 20.10%
    public int waysToSplit1(int[] nums) {
        final int mod = 1000000007;
        int ans = 0;
        int n = nums.length;
        // 前缀和
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }

        // 上一次 right 的最小值 minRight(minRight 要保证 >= left + 1)
        int lastMinRight = 1;
        int minRight = 1, maxRight;
        for (int left = 0; left <= n - 3; left++) {
            // 不能直接让 lastMinRight 直接等于 上次的 minRight, 因为有可能 left>=minRight （比如全 0 测试用例）
            lastMinRight = minRight == Integer.MAX_VALUE ? Math.max(left + 1, lastMinRight) : Math.max(left + 1, minRight);
            // right 的最小值 minRight
            minRight = minRightBinarySearch(pre, pre[left + 1], lastMinRight, n - 2);
            // 此时不能切割(没有方案数), 直接下次循环
            if (minRight == Integer.MAX_VALUE) {
                continue;
            }
            // right 的最大值 maxRight
            maxRight = maxRightBinarySearch(pre, pre[left + 1], lastMinRight, n - 2);
            // 方案数 maxRight - minRight + 1
            ans = (ans + maxRight - minRight + 1) % mod;
            System.out.println("left = " + left + ", minRight = " + minRight + ", maxRight = " + maxRight);
        }
        return ans;
    }

    // 优化
    // 49 ms 44.12%
    public int waysToSplit(int[] nums) {
        final int mod = 1000000007;
        int ans = 0;
        int n = nums.length;
        // 前缀和
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }

        // 上一次 right 的最小值 minRight(minRight 要保证 >= left + 1)
        int lastMinRight = 1;
        int minRight = 1, maxRight = 1;
        for (int left = 0; left <= n - 3; left++) {
            // 优化 2 49 ms 44.12% -> 45 ms 46.57%
            if (pre[left + 1] * 3 > pre[n]) {
                break;
            }
            // 不能直接让 lastMinRight 直接等于 上次的 minRight, 因为有可能 left>=minRight （比如全 0 测试用例）
            lastMinRight = minRight == Integer.MAX_VALUE ? Math.max(left + 1, lastMinRight) : Math.max(left + 1, minRight);
            // right 的最小值 minRight
            minRight = minRightBinarySearch(pre, pre[left + 1], lastMinRight, n - 2);
            // 此时不能切割(没有方案数), 直接下次循环
            if (minRight == Integer.MAX_VALUE) {
                continue;
            }
            // right 的最大值 maxRight
            // 此处的 lastMinRight 可以修改为 minRight
            // maxRight = maxRightBinarySearch(pre, pre[left + 1], lastMinRight, n - 2);
            // 优化过程 1
//            if (minRight >= maxRight) {
//                System.out.println("111111111111111111111");
//                maxRight = maxRightBinarySearch(pre, pre[left + 1], minRight, n - 2);
//            } else {
//                // 中间部分子数组和
//                int midSum = pre[maxRight + 1] - pre[left + 1];
//                // 右边部分子数组和
//                int rightSum = pre[n] - pre[maxRight + 1];
//                // 此时肯定满足 midSum >= pre[left + 1])
//                if (rightSum >= midSum) {
//                    maxRight = maxRightBinarySearch(pre, pre[left + 1], maxRight, n - 2);
//                    System.out.println("222222222222222222222");
//                } else {
//                    maxRight = maxRightBinarySearch(pre, pre[left + 1], minRight, maxRight - 1);
//                    System.out.println("333333333333333333333");
//                }
//            }
            // 优化结果
            // 貌似观察输出可以得到一个结论: maxRight 是非严格单调递增的, 于是以上的判断语句等价于
            maxRight = maxRightBinarySearch(pre, pre[left + 1], Math.max(minRight, maxRight), n - 2);

            // 方案数 maxRight - minRight + 1
            ans = (ans + maxRight - minRight + 1) % mod;
            System.out.println("left = " + left + ", minRight = " + minRight + ", maxRight = " + maxRight);
        }
        return ans;
    }

    // 右边最小值
    private int minRightBinarySearch(int[] pre, int leftSum, int left, int right) {
        int n = pre.length;
        int ans = Integer.MAX_VALUE;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 中间部分子数组和
            int midSum = pre[mid + 1] - leftSum;
            // 右边部分子数组和
            int rightSum = pre[n - 1] - pre[mid + 1];
            if (midSum >= leftSum) {
                if (rightSum >= midSum) {
                    // 左边找最小
                    ans = Math.min(ans, mid);
                    right = mid - 1;
                } else {
                    // 左边找最小
                    right = mid - 1;
                }
            } else {
                if (rightSum >= midSum) {
                    // 右边找最小
                    left = mid + 1;
                } else {
                    // 找不到了呀
                    break;
                }
            }
        }
        return ans;
    }

    // 右边最大值
    private int maxRightBinarySearch(int[] pre, int leftSum, int left, int right) {
        int n = pre.length;
        int ans = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 中间部分子数组和
            int midSum = pre[mid + 1] - leftSum;
            // 右边部分子数组和
            int rightSum = pre[n - 1] - pre[mid + 1];
            if (midSum >= leftSum) {
                if (rightSum >= midSum) {
                    // 右边找最大
                    ans = Math.max(ans, mid);
                    left = mid + 1;
                } else {
                    // 左边找最大
                    right = mid - 1;
                }
            } else {
                if (rightSum >= midSum) {
                    // 右边找最大
                    left = mid + 1;
                } else {
                    // 找不到了呀
                    break;
                }
            }
        }
        return ans;
    }
}
```

##### 三指针

```java
// 三指针
// O(N)
// 在使用前缀和 + 二分查找做题的过程中, 发现了 maxRight 是非严格单调递增的,
// 那么就可以将其转换为 三指针 来做, 不用每次使用二分再去查找 right 的大小值了
class P1712_Solution {
    // 9 ms 99.02%
    public int waysToSplit(int[] nums) {
        final int mod = 1000000007;
        int ans = 0;
        int n = nums.length;
        // 前缀和
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }

        int lastMinRight = 1;
        int minRight = 1, maxRight = 1;
        for (int left = 0; left <= n - 3; left++) {
            // 左边部分子数组和
            int leftSum = pre[left + 1];
            // 就这一个剪枝, 就能让这个方法实现从超时变成耗时 11 ms 击败 98.53%
            if (leftSum * 3 > pre[n]) {
                break;
            }
            lastMinRight = minRight == n - 1 ? Math.max(left + 1, lastMinRight) : Math.max(left + 1, minRight);
            minRight = lastMinRight;
            // 中间部分子数组和
            int midSum = pre[minRight + 1] - leftSum;
            // 右边部分子数组和
            int rightSum = pre[n] - pre[minRight + 1];
            while (minRight <= n - 2 && !(midSum >= leftSum && rightSum >= midSum)) {
                minRight++;
                // 中间部分子数组和
                midSum = pre[minRight + 1] - leftSum;
                // 右边部分子数组和
                rightSum = pre[n] - pre[minRight + 1];
            }
            if (minRight == n - 1) {
                System.out.println("continue");
                continue;
            }
            // 从当前对应 left 的 minRight 或者上一个 left 的 maxRight 处开始遍历
            maxRight = Math.max(minRight, maxRight);
            // 中间部分子数组和
            midSum = pre[maxRight + 1] - leftSum;
            // 右边部分子数组和
            rightSum = pre[n] - pre[maxRight + 1];
            while (maxRight <= n - 2 && (midSum >= leftSum && rightSum >= midSum)) {
                maxRight++;
                // 中间部分子数组和
                midSum = pre[maxRight + 1] - leftSum;
                // 右边部分子数组和
                rightSum = pre[n] - pre[maxRight + 1];
            }
            // 因为退出时 maxRight 并不满足切割条件, maxRight - 1 才满足切割条件
            maxRight = maxRight - 1;
            // 方案数 maxRight - minRight + 1
            ans = (ans + maxRight - minRight + 1) % mod;
            System.out.println("left = " + left + ", minRight = " + minRight + ", maxRight = " + maxRight + ", lastMinRight = " + lastMinRight);
        }
        return ans;
    }

    // 13 ms 88.24%
    // 冗余代码修改, 虽然这样使得代码更加简洁, 但是由于每次都要调用方法和创建局部变量, 反而更加耗时
    public int waysToSplit1(int[] nums) {
        final int mod = 1000000007;
        int ans = 0;
        int n = nums.length;
        // 前缀和
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }

        int lastMinRight = 1;
        int minRight = 1, maxRight = 1;
        int leftSum;
        for (int left = 0; left <= n - 3; left++) {
            // 左边部分子数组和
            leftSum = pre[left + 1];
            // 就这一个剪枝, 就能让这个方法实现从超时变成耗时 11 ms 击败 98.53%
            if (leftSum * 3 > pre[n]) {
                break;
            }
            /* 1. 找最大 */
            lastMinRight = minRight == n - 1 ? Math.max(left + 1, lastMinRight) : Math.max(left + 1, minRight);
            minRight = lastMinRight;
            // 找到 left 对应的满足切割条件的 right 最小的下标 minRight
            // 未找到之前一直循环, 找到后或者下标超出边界后退出循环
            while (minRight <= n - 2 && !splitCondition(pre, leftSum, minRight, pre[n])) {
                minRight++;
            }
            if (minRight == n - 1) {
                // System.out.println("continue");
                continue;
            }
            /* 2. 找最大 */
            // 从当前对应 left 的 minRight 或者上一个 left 的 maxRight 处开始遍历
            maxRight = Math.max(minRight, maxRight);
            // 找到 left 对应的满足切割条件的 right 最大的下标 maxRight
            // 退出循环时 maxRight 并不满足切割条件, maxRight - 1 才满足切割条件
            while (maxRight <= n - 2 && splitCondition(pre, leftSum, maxRight, pre[n])) {
                maxRight++;
            }
            // 减 1 后的 maxRight 才满足切割条件
            maxRight = maxRight - 1;
            /* 3. 累加方案数 maxRight - minRight + 1 */
            ans = (ans + maxRight - minRight + 1) % mod;
            System.out.println("left = " + left + ", minRight = " + minRight + ", maxRight = " + maxRight + ", lastMinRight = " + lastMinRight);
        }
        return ans;
    }

    private boolean splitCondition(int[] pre, int leftSum, int mid, int totalSum) {
        // 左边部分子数组和
        // int leftSum = pre[left + 1];
        // 中间部分子数组和
        int midSum = pre[mid + 1] - leftSum;
        // 右边部分子数组和
        int rightSum = totalSum - pre[mid + 1];
        return midSum >= leftSum && rightSum >= midSum;
    }
}
```

#### [1725. 可以形成最大正方形的矩形数目](https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/)

##### 基本操作

```java
class P1725_Solution {
    public int countGoodRectangles(int[][] rectangles) {
        int maxLen = 0;
        int count = 0;
        for (int[] lw : rectangles) {
            int edge = Math.min(lw[0], lw[1]);
            // 遇到更大的正方形, 保存最大长度和数量置为 1
            if (maxLen < edge) {
                maxLen = edge;
                count = 1;
            } else if (maxLen == edge) {
                // 相同长度数量加一
                count++;
            }
        }
        return count;
    }
}
```

#### [1748. 唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/)

##### 基本操作

```java
// 这方法叫状态机? 无语, 又是新名词
class P1748_Solution {
    // 本应该使用哈希表来解决本问题, 但是由于 nums 的数据范围较小
    // 所以可以采用 数组代替哈希表 的这种空间换时间的方式来做
    public int sumOfUnique(int[] nums) {
        // 可以赋给每个元素三个状态：
        // 0：该元素尚未被访问；
        // 1：该元素被访问过一次；
        // 2：该元素被访问超过一次。
        int[] frequency = new int[101];
        int sum = 0;
        for (int num : nums) {
            // 第一次出现, sum 加上 num
            if (frequency[num] == 0) {
                frequency[num]++;
                sum += num;
            } else if (frequency[num] == 1) {
                // 第二次出现, sum 需要减掉 num
                // 更多次出现不做任何操作
                frequency[num]++;
                sum -= num;
            }
        }
        return sum;
    }
}
```



#### [1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)

##### 枚举 暴力解法

```java
// 枚举 O(N^2) O(1)
// 4 ms
class P1763_Solution1 {
    public String longestNiceSubstring(String s) {
        int n = s.length();
        int maxPos = 0;
        int maxLen = 0;
        for (int i = 0; i < n; i++) {
            // lower 和 upper 的每一位表示是否有小写字母和大写字母
            int lower = 0;
            int upper = 0;
            for (int j = i; j < n; j++) {
                char ch = s.charAt(j);
                if (Character.isLowerCase(ch)) {
                    lower |= 1 << (ch - 'a');
                } else {
                    upper |= 1 << (ch - 'A');
                }
                // 相等时表示同一字母的小写字母和大写字母同时存在
                if (lower == upper && j - i + 1 > maxLen) {
                    maxPos = i;
                    maxLen = j - i + 1;
                }
            }
        }
        return s.substring(maxPos, maxPos + maxLen);
    }
}
```

##### 分治

```java
// 分治
// 0 ms
class P1763_Solution {
    private int maxPos;
    private int maxLen;

    public String longestNiceSubstring(String s) {
        this.maxPos = 0;
        this.maxLen = 0;
        dfs(s, 0, s.length() - 1);
        return s.substring(maxPos, maxPos + maxLen);
    }

    private void dfs(String s, int start, int end) {
        if (start >= end) {
            return;
        }
        // lower 和 upper 的每一位表示是否有小写字母和大写字母
        int lower = 0;
        int upper = 0;
        for (int i = start; i <= end; i++) {
            char ch = s.charAt(i);
            if (Character.isLowerCase(ch)) {
                lower |= 1 << (ch - 'a');
            } else {
                upper |= 1 << (ch - 'A');
            }
        }
        // 相等时表示同一字母的小写字母和大写字母同时存在
        if (lower == upper) {
            if (end - start + 1 > maxLen) {
                maxPos = start;
                maxLen = end - start + 1;
            }
            return;
        }
        // valid 表示大小写字母均存在的字母集合
        int valid = lower & upper;
        int pos = start;
        while (pos <= end) {
            start = pos;
            // pos 位置处的这个字母, 它的大小写字母在该子串中均存在
            while (pos <= end && (valid & (1 << Character.toLowerCase(s.charAt(pos)) - 'a')) != 0) {
                pos++;
            }
            // 退出 while 时 pos 处的这个字母大小写只出现其中之一
            // 遍历这个小子串, 是否为美好子串
            dfs(s, start, pos - 1);
            pos++;
        }
//        // 使用 for 循环
//        for (int pos = start; pos <= end; pos++) {
//            start = pos;
//            // pos 位置处的这个字母, 它的大小写字母在该子串中均存在
//            while (pos <= end && (valid & (1 << Character.toLowerCase(s.charAt(pos)) - 'a')) != 0) {
//                pos++;
//            }
//            // 退出 while 时 pos 处的这个字母大小写只出现其中之一
//            // 遍历这个小子串, 是否为美好子串
//            dfs(s, start, pos - 1);
//        }
    }
}
```

##### 滑动窗口

#### [1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索(队列实现) 多源 BFS
// 一次性通过, 都没有测试到更多的测试用例
class P1765_Solution {
    // 上左下右
    final int[] dx = new int[]{-1, 0, 1, 0};
    final int[] dy = new int[]{0, -1, 0, 1};

    // 51 ms
    // 使用 isVisited 记录是否以访问
    public int[][] highestPeak1(int[][] isWater) {
        int m = isWater.length;
        int n = isWater[0].length;
        int[][] gridHeight = new int[m][n];
        boolean[][] isVisited = new boolean[m][n];
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (isWater[i][j] == 1) {
                    queue.add(i * n + j);
                    gridHeight[i][j] = 0;
                    isVisited[i][j] = true;
                }
            }
        }
        while (!queue.isEmpty()) {
            int id = queue.remove();
            int x = id / n;
            int y = id % n;
            for (int i = 0; i < 4; i++) {
                int newX = x + dx[i];
                int newY = y + dy[i];
                if (newX >= 0 && newX < m && newY >= 0 && newY < n) {
                    if (isVisited[newX][newY]) {
                        continue;
                    }
                    gridHeight[newX][newY] = gridHeight[x][y] + 1;
                    isVisited[newX][newY] = true;
                    queue.add(newX * n + newY);

                }
            }
        }
        return gridHeight;
    }

    // 46 ms 78.32% 164.2 MB
    // 去掉 isVisited 数组, 改用 gridHeight[i][j] == -1, 表示已访问
    public int[][] highestPeak2(int[][] isWater) {
        int m = isWater.length;
        int n = isWater[0].length;
        int[][] gridHeight = new int[m][n];
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            // 置为 -1, 表示未访问过
            Arrays.fill(gridHeight[i], -1);
            for (int j = 0; j < n; j++) {
                if (isWater[i][j] == 1) {
                    // 置为 0, 表示水域处的高度为 0
                    gridHeight[i][j] = 0;
                    // 先将水域入队(以水域为起点)
                    queue.add(i * n + j);
                }
            }
        }
        while (!queue.isEmpty()) {
            int id = queue.remove();
            int x = id / n;
            int y = id % n;
            for (int i = 0; i < 4; i++) {
                int newX = x + dx[i];
                int newY = y + dy[i];
                // 边界内且没有被访问过, (newX,newY)高度比起(x,y)多 1
                if (newX >= 0 && newX < m && newY >= 0 && newY < n && gridHeight[newX][newY] == -1) {
                    gridHeight[newX][newY] = gridHeight[x][y] + 1;
                    queue.add(newX * n + newY);
                }
            }
        }
        return gridHeight;
    }

    // 43 ms 90.21% 141.1MB 71.33%
    // 队列 queue 中的元素由 i * n + j 改为 new int[]{i, j}
    public int[][] highestPeak(int[][] isWater) {
        int m = isWater.length;
        int n = isWater[0].length;
        int[][] gridHeight = new int[m][n];
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            // 置为 -1, 表示未访问过
            Arrays.fill(gridHeight[i], -1);
            for (int j = 0; j < n; j++) {
                if (isWater[i][j] == 1) {
                    // 置为 0, 表示水域处的高度为 0
                    gridHeight[i][j] = 0;
                    // 先将水域入队(以水域为起点)
                    queue.add(new int[]{i, j});
                }
            }
        }
        while (!queue.isEmpty()) {
            int[] grid = queue.remove();
            for (int i = 0; i < 4; i++) {
                int x = grid[0] + dx[i];
                int y = grid[1] + dy[i];
                // 边界内且没有被访问过, (x,y)高度比起(grid[0],grid[1])多 1
                if (x >= 0 && x < m && y >= 0 && y < n && gridHeight[x][y] == -1) {
                    gridHeight[x][y] = gridHeight[grid[0]][grid[1]] + 1;
                    queue.add(new int[]{x, y});
                }
            }
        }
        return gridHeight;
    }
}
```



#### [1857. 有向图中最大颜色值](https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/)

##### 拓扑排序（广度优先搜索 队列实现） + 动态规划

###### 第一次实现 - 2021.10.15

```java
public class P1857_LargestPathValue {
    public static void main(String[] args) {
        // 测试案例 1
        String colors = "abaca";
        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}};
//        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}, {1, 2}, {3, 1}}; // 存在环
//        // 测试案例 2
//        String colors = "a";
//        int[][] edges = {{0, 0}};
//        // 测试案例 3
//        String colors = "g";
//        int[][] edges = {};

        Solution solution = new Solution();
        int largestPathValue = solution.largestPathValue(colors, edges);

        System.out.println(largestPathValue);
    }
}

class Solution {
    public int largestPathValue(String colors, int[][] edges) {

        // 节点个数
        int nodeNum = colors.length();
        // 每个节点的入度
        int[] inDegree = new int[nodeNum];
        // 保存到达每个节点时, 该条路径上的各种颜色出现的次数
        int[][] pathValue = new int[nodeNum][26];
        // 创建邻接表
        Node[] adjList = new Node[nodeNum];

        // 把从 from 节点到所有 to 节点的所有边的关系都保存为
        // 从 from 节点指向的所有的 to 节点形成的一个链表
        // 例如：从字符 ’a‘ 这个节点到 字符 ’b‘’c‘’d‘ 这三个节点的五条边关系保存为
        // {aNode} --> [bNode] --> cNode --> dNode
        // 如果 ’b‘ 到 ’e‘’f‘ ，则
        // {bNode} --> [eNode] --> fNode
        // 其中,[]括号里的[bNode][eNode]两节点才保存在邻接表adjList[from]中
        // from 为相对应的’a‘’b‘在原字符串中的下标
        for (int[] edge : edges) {
            int from = edge[0], to = edge[1];
            // to 节点的入度更新,一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法，与注释的三行等价
            adjList[from] = new Node(to, adjList[from]);
            /*
            Node toNode = new Node(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // 保存入度为 0 的各个节点，有可能是非连通图
        LinkedList<Integer> queue = new LinkedList<>();
        for (int i = 0; i < inDegree.length; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }
        // 如果 queue 中一个都没有, 表示存在环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return -1;
        }

        // 如果无环,当循环结束时, bfsCount 应该等于节点数 nodeNum
        int bfsCount = 0;
        Node next;
        while (!queue.isEmpty()) {
            // 初始时前 initQueueSize = queue.size() 个 cur 代表入度为 0 的从该点开始遍历的出发节点的下标
            // 可以看作有 initQueueSize 个子图
            int cur = queue.remove();
            // adjList[cur] 处存储的是 cur 的下一个节点
            next = adjList[cur];

            // bfsCount 入度为 0 的点的个数
            bfsCount++;
            // 将当前路径上的该点处的相应颜色的值加 1
            pathValue[cur][colors.charAt(cur) - 97]++;
            // 遍历当前节点能够到达的其它所有节点
            while (next != null) {
                // 入度减 1, 减小到 0 时, 将其入队
                inDegree[next.value]--;
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }

                // 更新 next 所有颜色次数
                // 由于当前的这个节点在曾经可能已经在其它路径中被访问过,所以此次访问需要比较上次
                // pathValue[0].length == 26 小写字母个数
                for (int i = 0; i < pathValue[0].length; i++) {
                    pathValue[next.value][i] = Math.max(pathValue[next.value][i], pathValue[cur][i]);
                }
                // next 指向 cur 这个入度为 0 的节点的下一个与它相连的能组成边的点
                next = next.next;
            }
        }

        // 如果无环,当循环结束时, bfsCount 应该等于节点数 nodeNum
        if (bfsCount != nodeNum) {
            return -1;
        }

        // 从 pathValue 二维数组中获取最大值 largestPathValue
        int res = 0;
        for (int[] ints : pathValue) {
            res = Math.max(res, Arrays.stream(ints).max().getAsInt());
        }
//        for (int[] ints : pathValue) {
//            for (int j = 0; j < pathValue[0].length; j++) {
//                res = Math.max(res, ints[j]);
//            }
//        }
        return res;
    }
}

class Node {

    // value 表示第几个字符
    public int value;
    Node next;

    public Node(int value) {
        this.value = value;
    }

    public Node(int value, Node next) {
        this.value = value;
        this.next = next;
    }
}
```

###### 第二次实现 - 2021.12.05

```java
public class Second_P1857_LargestPathValue {
    public static void main(String[] args) {
        // 测试案例 1
        String colors = "abaca";
        int[][] edges = {{0, 1}, {0, 2}, {2, 3}, {3, 4}};
        int[][] edges1 = {{0, 1}, {0, 2}, {2, 3}, {3, 4}, {1, 2}, {3, 1}}; // 存在环

        // 测试案例 2
        String colors2 = "a";
        int[][] edges2 = {{0, 0}}; // 存在环

        // 测试案例 3
        String colors3 = "g";
        int[][] edges3 = {};

        Second_P1857_Solution solution = new Second_P1857_Solution();
        System.out.println(solution.largestPathValue(colors, edges)); // 3
        System.out.println(solution.largestPathValue(colors, edges1)); // -1
        System.out.println(solution.largestPathValue(colors2, edges2)); // -1
        System.out.println(solution.largestPathValue(colors3, edges3)); // 1
    }
}

// 拓扑排序(Topological sort)(BFS 队列实现) + 动态规划
class Second_P1857_Solution {
    public int largestPathValue(String colors, int[][] edges) {

        // 节点个数
        int nodeNum = colors.length();
        // 小写字母个数
        final int letterNum = 26;
        // 各个节点的入度
        int[] inDegree = new int[nodeNum];
        // 动态规划数组, 保存到达各个节点时, 该条路径上的各种颜色出现的次数
        int[][] pathValueDP = new int[nodeNum][letterNum];
        // 创建邻接表
        Node[] adjList = new Node[nodeNum];

        // 把从 from 节点到所有 to 节点的所有边的关系都保存为
        // 从 from 节点指向的所有的 to 节点形成的一个链表
        // 例如: 从字符 ’a‘ 这个节点到字符 ’b‘’c‘’d‘ 这三个节点的四条边关系保存为
        // {aNode} --> [bNode] --> cNode --> dNode
        // 如果字符 ’b‘ 能到 ’e‘’f‘, 则
        // {bNode} --> [eNode] --> fNode
        // 其中, []括号里的 [bNode]、[eNode] 两个节点才保存在邻接表 adjList[from] 中
        // from 为相对应的 ’a‘’b‘ 在原字符串中的下标
        int from, to;
        for (int[] edge : edges) {
            from = edge[0];
            to = edge[1];
            // 更新 to 节点的入度, 一条 from -> to 的边, 则 to 节点的入度 + 1
            inDegree[to]++;
            // 采用头插法, 与注释的三行等价
            adjList[from] = new Node(to, adjList[from]);
            /*
            Node toNode = new Node(to);
            toNode.next = adjList[from];
            adjList[from] = toNode;
             */
        }

        // BFS
        // 保存入度为 0 的各个节点的下标, 有可能是非连通图
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < inDegree.length; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // 如果 queue 中一个入度为 0 的节点都没有, 表示图存在环, 并且整个图是一个大环, 所有节点的入度都大于 0
        // 此判断可以删除
        if (queue.isEmpty()) {
            return -1;
        }

        // bfsCount 表示遍历过程中遍历了多少个入度为 0 的 节点
        // 如果无环, 当循环结束时, bfsCount 应该等于节点总数 nodeNum
        int bfsCount = 0;
        Node next;
        int cur;
        while (!queue.isEmpty()) {
            // 初始时前 initQueueSize = queue.size() 个 cur 代表入度为 0 的从该点开始遍历的出发节点的下标
            // 可以看作有 initQueueSize 个子图 (这个说法是错误的)

            // 出队一个入度为 0 的节点
            cur = queue.remove();
            // adjList[cur] 处存储的是 cur 能够到达的下一个节点 next
            next = adjList[cur];

            // bfsCount 为遍历过程中遍历了的入度为 0 的节点的个数
            bfsCount++;
            // 将当前路径上的该点处的相应颜色的值加 1
            pathValueDP[cur][colors.charAt(cur) - 97]++;

            // 遍历当前节点能够到达的其它所有节点
            while (next != null) {
                // 入度减 1, 减小后为 0 时, 将其入队
                inDegree[next.value]--;
                if (inDegree[next.value] == 0) {
                    queue.add(next.value);
                }

                // 动态规划, 更新 next 所有颜色次数
                // 由于当前的这个 next 节点在曾经可能已经在其它路径中被访问过, 所以此次访问需要比较上次
                // 以确保当前循环结束后, pathValueDP[next.value][i] 处保存的值为
                // 到目前为止, 到达该节点的各条路径中各种颜色(26个字母)出现的最多的次数
                // letterNum == pathValueDP[0].length == 26 小写字母个数
                for (int i = 0; i < letterNum; i++) {
                    pathValueDP[next.value][i] = Math.max(pathValueDP[next.value][i], pathValueDP[cur][i]);
                }
                // 再令 next 为 cur 这个入度为 0 的节点的其它下一个节点(与它相连的能形成有向边的节点)
                // 直到遍历完所有 next 节点后退出循环
                next = next.next;
            }
        }

        // 如果无环, 当循环结束时, bfsCount 应该等于节点总数 nodeNum
        // 如果无法遍历完所有的结点，则意味着当前的图不是有向无环图, 不存在拓扑排序
        if (bfsCount != nodeNum) {
            return -1;
        }

        // 从 pathValueDP 二维数组中获取最大值 largestPathValue
        int res = 0;
//        for (int[] ints : pathValueDP) {
//            res = Math.max(res, Arrays.stream(ints).max().getAsInt());
//        }
        for (int[] ints : pathValueDP) {
            for (int j = 0; j < letterNum; j++) {
                res = Math.max(res, ints[j]);
            }
        }
        return res;
    }
}

class Node {

    // value 表示第几个字符, 节点下标
    int value;
    Node next;

    public Node(int value) {
        this.value = value;
    }

    public Node(int value, Node next) {
        this.value = value;
        this.next = next;
    }
}
```



#### [1905. 统计子岛屿](https://leetcode-cn.com/problems/count-sub-islands/)

##### 深度优先搜索（递归实现）

```java
// 深度优先搜索(递归实现)
// 此题 DFS 效率比 BFS 高
class P1905_Solution {
    int[][] grid1;
    int[][] grid2;
    int m;
    int n;

    public int countSubIslands(int[][] grid1, int[][] grid2) {
        this.grid1 = grid1;
        this.grid2 = grid2;
        this.m = grid1.length;
        this.n = grid1[0].length;

        // grid2 中 子岛屿 的 数目
        int numSubIslands = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    if (dfs(i, j)) {
                        numSubIslands++;
                    }
                }
            }
        }

        return numSubIslands;
    }

    private boolean dfs(int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n) {
            return true;
        }

        if (grid2[i][j] == 0 || grid2[i][j] == 2) {
            return true;
        }
//        // 可以不创建 bl 变量, 使用 & 符号
//        // 1
//        boolean bl = true;
//
//        // 如果(i,j)处, grid1[i][j]为 0, grid2[i][j]为 1, 说明这个岛屿不是子岛屿
//        if (grid1[i][j] == 0) {
//            bl = false;
//        }
//
//        // 陆地标记已访问
//        grid2[i][j] = 2;
//
//        // 左上下右
//        bl = dfs(i, j - 1) && bl;
//        bl = dfs(i - 1, j) && bl;
//        bl = dfs(i + 1, j) && bl;
//        bl = dfs(i, j + 1) && bl;
//        return bl;


//        // 2
        // && 和 & 都是表示与，区别是 && 只要第一个条件不满足，后面条件就不再判断。
        // 而 & 要对所有的条件都进行判断。

        // 陆地标记已访问
        grid2[i][j] = 2;
        // 左上下右
        return dfs(i, j - 1)
                & dfs(i - 1, j)
                & dfs(i + 1, j)
                & dfs(i, j + 1)
                & grid1[i][j] == 1;
    }
}
```

##### 广度优先搜索（队列实现）

```java
// 广度优先搜索(队列实现)
class P1905_Solution1 {
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int m = grid1.length;
        int n = grid1[0].length;
        // 左上下右
        int[] dx = new int[]{0, -1, 1, 0};
        int[] dy = new int[]{-1, 0, 0, 1};
        // grid2 中 子岛屿 的 数目
        int numSubIslands = 0;
        boolean bl;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    Queue<Integer> queue = new LinkedList<>();
                    queue.add(i * n + j);
                    // 每次重新对 bl 赋初值
                    bl = grid1[i][j] == 1;
                    grid2[i][j] = 2;
                    int id, curX, curY;
                    while (!queue.isEmpty()) {
                        id = queue.poll();
                        curX = id / n;
                        curY = id % n;
                        int x, y;
                        // 左上下右
                        for (int k = 0; k < 4; k++) {
                            x = curX + dx[k];
                            y = curY + dy[k];
                            if (x < 0 || x >= m || y < 0 || y >= n) {
                                continue;
                            }
                            if (grid2[x][y] == 1) {
                                queue.add(x * n + y);
                                // 如果(i,j)处, grid1[i][j]为 0, grid2[i][j]为 1, 说明这个岛屿不是子岛屿
                                if (grid1[x][y] == 0) {
                                    bl = false;
                                }
                                // 陆地标记已访问
                                grid2[x][y] = 2;
                            }
                        }
                    }
                    // bl 为 false 时, 表示该岛屿不是子岛屿
                    if (bl) {
                        numSubIslands++;
                    }
                }
            }
        }
        return numSubIslands;
    }
}
```

#### [1984. 学生分数的最小差值](https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

##### 排序 + 滑动窗口

```java
// 先排序, 再滑动窗口遍历 基本操作
// 时间复杂度 O(n log n) 4ms 100%
// 空间复杂度 O(log n)   41.7 MB 5.17%
class P1984_Solution {
    public int minimumDifference(int[] nums, int k) {
        int n = nums.length;
        Arrays.sort(nums);
        int minDiff = Integer.MAX_VALUE;
        for (int i = 0; i <= n - k; i++) {
            minDiff = Math.min(minDiff, nums[i + k - 1] - nums[i]);
        }
        return minDiff;
    }
}
```



#### [2000. 反转单词前缀](https://leetcode-cn.com/problems/reverse-prefix-of-word/)

##### 基本操作

```java
class P2000_Solution {
    // 我的解法
    public String reversePrefix(String word, char ch) {
        int firstIndex = word.indexOf(ch);
        if (firstIndex == -1) {
            return word;
        }
//        // 第一种 27%
//        String reversedPrefix = new StringBuilder(word.substring(0, firstIndex + 1)).reverse().toString();
//        return firstIndex == word.length() - 1 ? reversedPrefix : reversedPrefix + word.substring(firstIndex + 1);
        // 第二种 效率比第一种高 100%
        StringBuilder reversedPrefix = new StringBuilder(word.substring(0, firstIndex + 1)).reverse();
        return firstIndex == word.length() - 1 ? reversedPrefix.toString() : reversedPrefix.append(word.substring(firstIndex + 1)).toString();
    }

    // 官方解法
    public String reversePrefix1(String word, char ch) {
        int index = word.indexOf(ch);
        if (index >= 0) {
            char[] arr = word.toCharArray();
            int left = 0, right = index;
            while (left < right) {
                char temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
            word = new String(arr);
        }
        return word;
    }
}
```



#### [2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

##### 基础操作

```java
class P2022_Solution {
    // 我的解法
    public int[][] construct2DArray1(int[] original, int m, int n) {
        int len = original.length;
        if (len != m * n) {
            return new int[][]{};
        }
        int[][] ans = new int[m][n];
        int k = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ans[i][j] = original[k];
                k++;
            }
        }
        return ans;
    }

    // 官方解法 效率好低呀！
    public int[][] construct2DArray(int[] original, int m, int n) {
        if (original.length != m * n) {
            return new int[0][];
        }
        int[][] ans = new int[m][n];
        for (int i = 0; i < original.length; i += n) {
            System.arraycopy(original, i, ans[i / n], 0, n);
        }
        return ans;
    }
}
```

#### [2034. 股票价格波动](https://leetcode-cn.com/problems/stock-price-fluctuation/)

##### 只使用一个TreeMap，超时

```java
// 超时
// 原因在于如果只使用一个 Map, 求最高价格和最低价格时需要遍历整个 Map
class StockPrice1 {
    TreeMap<Integer, Integer> stockPrice;

    // 初始化对象，当前无股票价格记录
    public StockPrice1() {
        this.stockPrice = new TreeMap<>((o1, o2) -> (o2 - o1));
    }

    // 在时间点 timestamp 更新股票价格为 price
    public void update(int timestamp, int price) {
        stockPrice.put(timestamp, price);
    }

    //  返回股票 最新价格
    public int current() {
        return stockPrice.get(stockPrice.firstKey());
    }

    // 返回股票 最高价格
    public int maximum() {
        int maxPrice = 0;
        for (int price : stockPrice.values()) {
            maxPrice = Math.max(maxPrice, price);
        }
        return maxPrice;
    }

    // 返回股票 最低价格
    public int minimum() {
        int minPrice = Integer.MAX_VALUE;
        for (int price : stockPrice.values()) {
            minPrice = Math.min(minPrice, price);
        }
        return minPrice;
    }
}
```

##### 哈希表 + 有序集合

```java
// 哈希表 + 有序集合
// 111 ms 官方的是 120 ms, 果然修改后比它快一点, 但貌似空间多耗了一点点
class StockPrice {
    // 最近时间戳, 最新价格的时间
    int recentTimestamp;
    // 保存股票价格记录 timestamp 与 price
    HashMap<Integer, Integer> stockTimePrice;
    // 保存价格与出现次数
    TreeMap<Integer, Integer> prices;

    // 初始化对象，当前无股票价格记录
    public StockPrice() {
        recentTimestamp = 0;
        this.stockTimePrice = new HashMap<>();
        this.prices = new TreeMap<>();
    }

    // 在时间点 timestamp 更新股票价格为 price
    public void update(int timestamp, int price) {
        // 比较更新股票最近时间
        recentTimestamp = Math.max(recentTimestamp, timestamp);
        // 添加或更新该时间点 timestamp 以及股票价格 price
        // 如果当前 timestamp 之前已经存在于 map 中, 则返回值 prevPrice 为前一个时间点 timestamp 的对应价格
        // 如果不在, 则 prevPrice 返回为 null
        Integer prevPrice = stockTimePrice.put(timestamp, price);
        //
        if (prevPrice != null) {
            // 前一个价格值的次数
            Integer prevPriceCount = prices.get(prevPrice);
            // 次数为 1, 此次要将其减 1, 则为 0 了, 为 0 的话, 就要删除它, 等价于等于 1 时直接删除
            if (prevPriceCount == 1) {
                prices.remove(prevPrice);
            } else {
                // prevPriceCount 肯定是大于 1 的
                prices.put(prevPrice, prevPriceCount - 1);
            }
        }
        // 当前时间点的对应价格的出现次数加 1
        prices.put(price, prices.getOrDefault(price, 0) + 1);
    }

    //  返回股票 最新价格
    public int current() {
        return stockTimePrice.get(recentTimestamp);
    }

    // 返回股票 最高价格
    public int maximum() {
        return prices.lastKey();
    }

    // 返回股票 最低价格
    public int minimum() {
        return prices.firstKey();
    }
}
```

#### [2045. 到达目的地的第二短时间](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/)

##### 广度优先搜索（队列实现）

```java
class P2045_Solution {
    // 超时, 需要加入类似记忆化的数组来解决
    public int secondMinimum1(int n, int[][] edges, int time, int change) {
        // 邻接表
        GraphNode[] adjList = new GraphNode[n + 1];
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // 头插法构建邻接表
            adjList[u] = new GraphNode(v, adjList[u]);
            adjList[v] = new GraphNode(u, adjList[v]);
            /*
            // 等价于这三行
            GraphNode vNode = new GraphNode(v);
            vNode.next = adjList[u];
            adjList[u] = vNode;
             */
        }
        // printAdjList(n, adjList);
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1);
        // 到达 N 节点的时间, 第二短时间就是说此次到达 N 节点的时间比前一次到达 N 节点的大, 此时结束程序并返回
        // 当然, 为了比较, 需在做判断时得排除未到达前的情况, 可赋初值为 -1
        // 注意通过到达 N 节点的次数(第二次到达)来判断第二次到达时的时间是第二短的
        int arriveNNodeTime = -1;
        int curTime = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            // 到达 curNode 节点时的时间为 curTime
            // 如果此时该节点是绿色的(通过下面这个条件判断), 则可以不用等待, 立即花费 time 时间到达下一个节点 next
            if (curTime / change % 2 == 0) {
                curTime += time;
            } else {
                // 如果此时该节点是红色的, 则需要等待 (change - curTime % change) 分钟后
                // 才能从 curNode 节点立即花费 time 时间到达下一个节点 next
                curTime += change - curTime % change + time;
            }
            for (int i = 0; i < size; i++) {
                // 从当前节点 curNode 出发
                int curNode = queue.remove();
                // 到达当前节点 curNode 的相邻节点 next
                GraphNode next = adjList[curNode];
                while (next != null) {
                    // 如果 next 恰好为终点 N 节点
                    if (next.value == n) {
                        // 并且如果之前从未有节点到达过终点, 则此次是最短时间到达, 时间为 (当前轮 curTime)
                        // 在同一轮的出队中, 可能有多个节点也是以最短时间 (当前轮 curTime) 到达
                        if (arriveNNodeTime == -1) {
                            arriveNNodeTime = curTime;
                        } else if (curTime > arriveNNodeTime) {
                            // 当曾经有节点到达过终点时, 如果当前到达时间 curTime 比曾经到达该节点时的时间 arriveNNodeTime(!= -1) 大
                            // 那么此次到达时间 curTime 即为第二短时间, 即刻返回
                            return curTime;
                        }
                    }
                    // System.out.println(next.value);
                    queue.add(next.value);
                    next = next.next;
                }
            }
        }
        // System.out.println("应该是永远不会执行到这里");
        return arriveNNodeTime;
    }

    // 跟据官方解法的思想添加数组记录(与官方解法的记录值不同, 但是基本原理还是一样的) 终于不再超时, 并且最终时间超过 98%
    public int secondMinimum2(int n, int[][] edges, int time, int change) {
        // 邻接表
        GraphNode[] adjList = new GraphNode[n + 1];
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // 头插法构建邻接表
            adjList[u] = new GraphNode(v, adjList[u]);
            adjList[v] = new GraphNode(u, adjList[v]);
            /*
            // 等价于这三行
            GraphNode vNode = new GraphNode(v);
            vNode.next = adjList[u];
            adjList[u] = vNode;
             */
        }
        // printAdjList(n, adjList);

        // arriveINodeTime[i][0] 为到达第 i 个节点的最短时间
        // arriveINodeTime[i][1] 为到达第 i 个节点的次最短时间
        int[][] arriveINodeTime = new int[n + 1][2];
        for (int[] arr : arriveINodeTime) {
            Arrays.fill(arr, Integer.MAX_VALUE);
        }
        // 初始化达到节点 1 时的最短时间为 0
        arriveINodeTime[1][0] = 0;

        // 到达 N 节点的时间, 第二短时间就是说此次到达 N 节点的时间比前一次到达 N 节点的大, 此时结束程序并返回
        // 当然, 为了比较, 需在做判断时得排除未到达前的情况, 可赋初值为 -1
        // 注意通过到达 N 节点的次数(第二次到达)来判断第二次到达时的时间是第二短的
        int arriveNNodeTime = -1;
        int curTime = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(1);
        while (!queue.isEmpty()) {
            int size = queue.size();
            // 到达 curNode 节点时的时间为 curTime
            // 如果此时该节点是绿色的(通过下面这个条件判断), 则可以不用等待, 立即花费 time 时间到达下一个节点 next
            if (curTime / change % 2 == 0) {
                curTime += time;
            } else {
                // 如果此时该节点是红色的, 则需要等待 (change - curTime % change) 分钟后
                // 才能从 curNode 节点立即花费 time 时间到达下一个节点 next
                curTime += change - curTime % change + time;
            }
            for (int i = 0; i < size; i++) {
                // 从当前节点 curNode 出发
                int curNode = queue.remove();
                // 到达当前节点 curNode 的相邻节点 next
                GraphNode next = adjList[curNode];
                while (next != null) {
                    /* 此段逻辑代码可删除, 通过 arriveINodeTime[n][1] 的值是否更新过来判断是否得到最短路径 */
                    // 如果 next 恰好为终点 N 节点
                    if (next.value == n) {
                        // 并且如果之前从未有节点到达过终点, 则此次是最短时间到达, 时间为 (当前轮 curTime)
                        // 在同一轮的出队中, 可能有多个节点也是以最短时间 (当前轮 curTime) 到达
                        if (arriveNNodeTime == -1) {
                            arriveNNodeTime = curTime;
                        } else if (curTime > arriveNNodeTime) {
                            // 当曾经有节点到达过终点时, 如果当前到达时间 curTime 比曾经到达该节点时的时间 arriveNNodeTime(!= -1) 大
                            // 那么此次到达时间 curTime 即为第二短时间, 即刻返回
                            return curTime;
                        }
                    }

                    // 当前次从 curNode 到达 next 节点的时间 curTime 与曾经历史到达 next 节点的最短时间相等时
                    // 以及大于曾经历史到达 next 节点的次最短时间时都不将该节点 next 再次入队
                    if (curTime < arriveINodeTime[next.value][0]) {
                        arriveINodeTime[next.value][0] = curTime;
                        queue.add(next.value);
                    } else if (curTime > arriveINodeTime[next.value][0] && curTime < arriveINodeTime[next.value][1]) {
                        arriveINodeTime[next.value][1] = curTime;
                        queue.add(next.value);
                    }

                    next = next.next;
                }
            }
        }
        // System.out.println("应该是永远不会执行到这里");
        return arriveNNodeTime;
    }

    // 广度优先搜索(队列实现) 29 ms 99.09%, 10.89%
    // 对到达终点的判断部分略微修改, 去掉使用 arriveNNodeTime 判断结束
    public int secondMinimum(int n, int[][] edges, int time, int change) {
        // 邻接表
        GraphNode[] adjList = new GraphNode[n + 1];
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // 头插法构建邻接表
            adjList[u] = new GraphNode(v, adjList[u]);
            adjList[v] = new GraphNode(u, adjList[v]);
            /*
            // 等价于这三行
            GraphNode vNode = new GraphNode(v);
            vNode.next = adjList[u];
            adjList[u] = vNode;
             */
        }
        // printAdjList(n, adjList);

        // arriveINodeTime[i][0] 为到达第 i 个节点的最短时间
        // arriveINodeTime[i][1] 为到达第 i 个节点的次最短时间
        int[][] arriveINodeTime = new int[n + 1][2];
        for (int[] arr : arriveINodeTime) {
            Arrays.fill(arr, Integer.MAX_VALUE);
        }
        // 初始化达到节点 1 时的最短时间为 0
        arriveINodeTime[1][0] = 0;

        // 到达当前节点时的时间为 curTime
        int curTime = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1);
        while (!queue.isEmpty()) {
            // 不能删除此行
            int size = queue.size();
            // 到达 curNode 节点时的时间为 curTime
            // 如果此时该节点是绿色的(通过下面这个条件判断), 则可以不用等待, 立即花费 time 时间到达下一个节点 next
            if (curTime / change % 2 == 0) {
                curTime += time;
            } else {
                // 如果此时该节点是红色的, 则需要等待 (change - curTime % change) 分钟后
                // 才能从 curNode 节点立即花费 time 时间到达下一个节点 next
                curTime += change - curTime % change + time;
            }
            for (int i = 0; i < size; i++) {
                // 从当前节点 curNode 出发
                int curNode = queue.remove();
                // 到达当前节点 curNode 的相邻节点 next
                GraphNode next = adjList[curNode];
                while (next != null) {
                    // 当前次从 curNode 到达 next 节点的时间 curTime 与曾经历史到达 next 节点的最短时间相等时
                    // 以及大于曾经历史到达 next 节点的次最短时间时都不将该节点 next 再次入队
                    if (curTime < arriveINodeTime[next.value][0]) {
                        arriveINodeTime[next.value][0] = curTime;
                        queue.add(next.value);
                    } else if (curTime > arriveINodeTime[next.value][0] && curTime < arriveINodeTime[next.value][1]) {
                        arriveINodeTime[next.value][1] = curTime;
                        queue.add(next.value);
                    }

                    next = next.next;

                    // 如果终点的第二短时间值刚刚被更新过, 说明得到了到达终点的第二最短路径(时间), 即刻返回
                    if (arriveINodeTime[n][1] != Integer.MAX_VALUE) {
                        return arriveINodeTime[n][1];
                    }
                }
            }
        }
        // System.out.println("应该是永远不会执行到这里");
        return arriveINodeTime[n][1];
    }

    // 打印
    private void printAdjList(int n, GraphNode[] adjList) {
        for (int i = 1; i <= n; i++) {
            GraphNode nextNode = adjList[i];
            System.out.print(i + " :");
            while (nextNode != null) {
                System.out.print(" " + nextNode.value);
                nextNode = nextNode.next;
            }
            System.out.println();
        }
    }
}

class GraphNode {

    // 节点编号
    int value;
    GraphNode next;

    public GraphNode(int value) {
        this.value = value;
    }

    public GraphNode(int value, GraphNode next) {
        this.value = value;
        this.next = next;
    }
}
```



#### [2050. 并行课程 III](https://leetcode-cn.com/problems/parallel-courses-iii/)

##### 拓扑排序（广度优先搜索 队列实现） + 动态规划

```java
// 拓扑排序(BFS 队列实现) + 动态规划
class P2050_Solution {
    public int minimumTime1(int n, int[][] relations, int[] time) {
        // 设置数组大小为 n + 1, 方便索引, 下标 0 不起作用
        // 邻接表
        P2050_CourseNode[] adjList = new P2050_CourseNode[n + 1];
        // 各个节点的入度, 每门课程的先修课程的数目
        int[] inDegree = new int[n + 1];
        // 该节点是否有出度, 是否是最后一门才能学习的课程, 或者是无入度无出度的可随时学习的课程
        boolean[] outDegree = new boolean[n + 1];
        // dp 数组, 记录到达各个节点(要学完此课程)所需的最少月份数
        int[] dp = new int[n + 1];
        // 学完所有课程所需要的 最少 月份数
        int minTime = 0;
        // 构造邻接表
        int from, to;
        for (int[] edge : relations) {
            // 有向边起点
            from = edge[0];
            // 有向边终点
            to = edge[1];
            // 头插法构造邻接表, adjList[from] 存储的是所有以 from 课程为先修课程的课程组成的链表
            adjList[from] = new P2050_CourseNode(to, adjList[from]);

            // 终点入度加 1
            inDegree[to]++;
            // from 有后修课程, 置为 true
            outDegree[from] = true;
        }

        // 将入度为 0 的各节点入队, 并更新初始学完这些入度为 0 (无先修课程)的课程的所需的时间就为 time[i - 1]
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
                dp[i] = time[i - 1];
            }
        }

        // 有向无环图
        int cur;
        P2050_CourseNode next;
        while (!queue.isEmpty()) {
            // 此次学习的课程
            cur = queue.poll();
            // 以 cur 课程为先修课程的一门课程 next
            next = adjList[cur];

            while (next != null) {
                // 入度减 1, 表示又学习了 next 的一门先修课程
                inDegree[next.value]--;
                // 当 next 入度减到 0 时, 说明 next 的所有的先修课程都学习完毕(刚学习完的 cur 课程就是它的最后一门先修课程)
                if (inDegree[next.value] == 0) {
                    // 将该 next 课程加入到队列中, 后续就可以学习该课程了
                    queue.add(next.value);
                }

                // 学习完课程 cur 至少需要的月份数为 dp[cur], 此次如果要学习课程 next, 需要的月份数为 dp[cur] + time[next.value - 1]
                // 课程 next 的先修课程课程有多个, 但是在学习 next 之前已经学过了, 它的 dp 值已经确定
                // 那么学完课程 next 所需的最少时间, 就是历次学完它的所有先修课程所花费的时间中的最大值 + 学习课程 next 所需要花费的时间 time[next.value - 1]
                dp[next.value] = Math.max(dp[next.value], dp[cur] + time[next.value - 1]);
                // 继续判断学习完 cur 课程后, 以 cur 课程为先修课程的下一门课程是否可以学习
                next = next.next;
            }
        }
        // 找到所有无出度(出度为 0 )的节点, 即终点, 比较到达终点的所有花费时间中的最大值就是学完所有课程花费的最少时间
        for (int i = 1; i <= n; i++) {
            if (!outDegree[i]) {
                minTime = Math.max(minTime, dp[i]);
            }
        }
        return minTime;
    }

    // 小优化
    public int minimumTime(int n, int[][] relations, int[] time) {
        // 设置数组大小为 n + 1, 方便索引, 下标 0 不起作用
        // 邻接表
        P2050_CourseNode[] adjList = new P2050_CourseNode[n + 1];
        // 各个节点的入度, 每门课程的先修课程的数目
        int[] inDegree = new int[n + 1];
        // 该节点是否有出度, 是否是最后一门才能学习的课程, 或者是无入度无出度的可随时学习的课程
        // boolean[] outDegree = new boolean[n + 1];
        // dp 数组, 记录到达各个节点(要学完此课程)所需的最少月份数
        int[] dp = new int[n + 1];
        // 学完所有课程所需要的 最少 月份数
        int minTime = 0;
        // 构造邻接表
        int from, to;
        for (int[] edge : relations) {
            // 有向边起点
            from = edge[0];
            // 有向边终点
            to = edge[1];
            // 头插法构造邻接表, adjList[from] 存储的是所有以 from 课程为先修课程的课程组成的链表
            adjList[from] = new P2050_CourseNode(to, adjList[from]);

            // 终点入度加 1
            inDegree[to]++;
            // from 有后修课程, 置为 true
            // outDegree[from] = true;
        }

        // 将入度为 0 的各节点入队, 并更新初始学完这些入度为 0 (无先修课程)的课程的所需的时间就为 time[i - 1]
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
                dp[i] = time[i - 1];
            }
        }

        // 有向无环图
        int cur;
        P2050_CourseNode next;
        while (!queue.isEmpty()) {
            // 此次学习的课程
            cur = queue.poll();
            // 以 cur 课程为先修课程的一门课程 next
            next = adjList[cur];

            // 不使用 outDegree
            // next == null, 说明 cur 课程不是任何课程的先修课程,
            // 也即 cur 课程随时可以学习或者 cur 的所有先修课程已经学习完毕并且没有以 cur 课程为先修课程的课程, 此拓扑排序到达了终点
            // 学完所有课程所需的时间就是学完这几门课程时, 它们所需时间的最大值, 所有 dp[cur] 中的最大值, cur 必须满足无后继学习课程(不是任何课程的先修课程)
            // 这样的课程数目, 也就是 minTime 比较次数就是所有课程组成的有向无环图的个数
            if (next == null) {
                minTime = Math.max(minTime, dp[cur]);
                continue;
            }

            while (next != null) {
                // 入度减 1, 表示又学习了 next 的一门先修课程
                inDegree[next.value]--;
                // 当 next 入度减到 0 时, 说明 next 的所有的先修课程都学习完毕(刚学习完的 cur 课程就是它的最后一门先修课程)
                if (inDegree[next.value] == 0) {
                    // 将该 next 课程加入到队列中, 后续就可以学习该课程了
                    queue.add(next.value);
                }

                // 学习完课程 cur 至少需要的月份数为 dp[cur], 此次如果要学习课程 next, 需要的月份数为 dp[cur] + time[next.value - 1]
                // 课程 next 的先修课程课程有多个, 但是在学习 next 之前已经学过了, 它的 dp 值已经确定
                // 那么学完课程 next 所需的最少时间, 就是历次学完它的所有先修课程所花费的时间中的最大值 + 学习课程 next 所需要花费的时间 time[next.value - 1]
                dp[next.value] = Math.max(dp[next.value], dp[cur] + time[next.value - 1]);
                // 继续判断学习完 cur 课程后, 以 cur 课程为先修课程的下一门课程是否可以学习
                next = next.next;
            }
        }
        /* // 找到所有无出度(出度为 0 )的节点, 即终点, 比较到达终点的所有花费时间中的最大值就是学完所有课程花费的最少时间
        for (int i = 1; i <= n; i++) {
            if (!outDegree[i]) {
                minTime = Math.max(minTime, dp[i]);
            }
        }*/
        return minTime;
    }
}

class P2050_CourseNode {
    // value 为课程编号
    int value;
    P2050_CourseNode next;

    public P2050_CourseNode(int value) {
        this.value = value;
    }

    public P2050_CourseNode(int value, P2050_CourseNode next) {
        this.value = value;
        this.next = next;
    }
}
```

#### [2121. 相同元素的间隔之和](https://leetcode-cn.com/problems/intervals-between-identical-elements/)

##### 超时 O(N^2)

```java
// 超时, 类似于我的那道面试题的做法
// O(N^2)
class P2121_Solution1 {
    public long[] getDistances1(int[] arr) {
        int n = arr.length;
        long[] intervals = new long[n];
        Map<Integer, ArrayList<Integer>> hashMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (!hashMap.containsKey(arr[i])) {
                ArrayList<Integer> list = new ArrayList<>();
                list.add(i);
                hashMap.put(arr[i], list);
            } else {
                ArrayList<Integer> list = hashMap.get(arr[i]);
                for (int index : list) {
                    intervals[index] += i - index;
                    intervals[i] += i - index;
                }
                list.add(i);
            }
        }
        return intervals;
    }

    // 修改代码实现逻辑, 本质不变
    public long[] getDistances(int[] arr) {
        int n = arr.length;
        long[] intervals = new long[n];
        Map<Integer, ArrayList<Integer>> hashMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            // 获取元素对应索引链表
            ArrayList<Integer> indexList = hashMap.get(arr[i]);
            // indexList == null 即 hashMap 不包含此元素
            if (indexList == null) {
                // 将该键值对(元素,索引链表)添加进 hashMap 中, 由于是第一次添加, 还需要新建链表
                indexList = new ArrayList<>();
                indexList.add(i);
                hashMap.put(arr[i], indexList);
            } else {
                // 两个位置都要加上这个间隔值
                for (int index : indexList) {
                    intervals[index] += i - index;
                    intervals[i] += i - index;
                }
                // 最后将该索引加入链表
                indexList.add(i);
            }
        }
        return intervals;
    }
}
```

##### 哈希表 + 前缀后缀和 O(N)

```java
// 哈希表 + 前缀后缀和
// O(N) = 2N
// 46 ms 87.95%
// O(N)
// 64.4 M 83.89%
class P2121_Solution {
    public long[] getDistances(int[] arr) {
        int n = arr.length;
        long[] intervals = new long[n];

        // 前缀和
        long[] prefix = new long[n];
        // value 值 indexAndCount[] 的长度为 2
        // indexAndCount[0] 为与当前元素相同的前一个元素的下标
        // indexAndCount[1] 为与当前元素相同的元素总共出现的次数
        Map<Integer, int[]> hashMap1 = new HashMap<>();
        for (int i = 0; i < n; i++) {
            // 获取 key 对应 value
            int[] indexAndCount = hashMap1.get(arr[i]);
            // indexList == null 即 hashMap 不包含此元素, 需要创建该元素 key 对应的 value 数组
            if (indexAndCount == null) {
                // 将该键值对(元素, 数组)添加进 hashMap 中, 由于是第一次添加, 还需要新建数组
                indexAndCount = new int[]{i, 1};
                hashMap1.put(arr[i], indexAndCount);
            } else {
                // prefix[i] 表示的是 arr[i] 与左边与之相同的元素的间隔和
                // 通过前一个与之相同的元素处的 prefix[] 和 arr[i] 总出现次数计算得到
                prefix[i] += prefix[indexAndCount[0]] + (long) (i - indexAndCount[0]) * indexAndCount[1];
                // 更新 indexAndCount
                indexAndCount[0] = i;
                indexAndCount[1]++;
            }
        }
        // 后缀和
        long[] suffix = new long[n];
        Map<Integer, int[]> hashMap2 = new HashMap<>();
        for (int i = n - 1; i >= 0; i--) {
            // 获取 key 对应 value
            int[] indexAndCount = hashMap2.get(arr[i]);
            // indexList == null 即 hashMap 不包含此元素, 需要创建该元素 key 对应的 value 数组
            if (indexAndCount == null) {
                // 将该键值对(元素, 数组)添加进 hashMap 中, 由于是第一次添加, 还需要新建数组
                indexAndCount = new int[]{i, 1};
                hashMap2.put(arr[i], indexAndCount);
            } else {
                // suffix[i] 表示的是 arr[i] 与右边与之相同的元素的间隔和
                // 通过前一个与之相同的元素处的 suffix[] 和 arr[i] 总出现次数计算得到
                suffix[i] += suffix[indexAndCount[0]] + (long) (indexAndCount[0] - i) * indexAndCount[1];
                // 更新 indexAndCount
                indexAndCount[0] = i;
                indexAndCount[1]++;
            }
            // 可将最后的结果计算赋值提前到此处
            intervals[i] = prefix[i] + suffix[i];
        }
//        // 结果计算
//        for (int i = 0; i < n; i++) {
//            intervals[i] = prefix[i] + suffix[i];
//        }
        return intervals;
    }
}
```



## 剑指 Offer II（待定）

## 编程过程中遇到的报错问题

P123_在IDEA上并没有此错误，但是在LeetCode中报错了

```java
java.util.ConcurrentModificationException
  at line 1495, java.base/java.util.HashMap$HashIterator.nextNode
  at line 1518, java.base/java.util.HashMap$KeyIterator.next
    
    for (Integer ind : hashSet) {
        if (prices[ind] >= prices[i]) {
            hashSet.remove(ind);
        }
    }
```

> 不能这么操作，要使用迭代器的方式
>

